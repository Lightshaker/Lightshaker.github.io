<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lightshaker.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="C++ Design Patterns  李建忠 C++ 设计模式 《设计模式 可复用面向对象软件的基础》  设计模式初探 什么是设计模式？  每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。 ——Christopher Alexander “设计模式”某种程度上是为了弥补语言上的不足实现的。  底层思维与抽象思维">
<meta property="og:type" content="article">
<meta property="og:title" content="C++设计模式">
<meta property="og:url" content="https://lightshaker.cn/archives/c185f75e/index.html">
<meta property="og:site_name" content="Journey">
<meta property="og:description" content="C++ Design Patterns  李建忠 C++ 设计模式 《设计模式 可复用面向对象软件的基础》  设计模式初探 什么是设计模式？  每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。 ——Christopher Alexander “设计模式”某种程度上是为了弥补语言上的不足实现的。  底层思维与抽象思维">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/1.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/2.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/3.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/4.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/5.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/6.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/7.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/8.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/9.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/10.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/12.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/13.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/14.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/15.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/16.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/17-1.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/17.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/18.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/19.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/20.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/21.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/22.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/23.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/24.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/25-1.png">
<meta property="og:image" content="https://lightshaker.cn/archives/c185f75e/25.png">
<meta property="article:published_time" content="2023-06-12T12:27:10.000Z">
<meta property="article:modified_time" content="2023-06-21T10:04:17.249Z">
<meta property="article:author" content="Lightshaker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lightshaker.cn/archives/c185f75e/1.png">

<link rel="canonical" href="https://lightshaker.cn/archives/c185f75e/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++设计模式 | Journey</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Journey</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lightshaker.cn/archives/c185f75e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lightshaker">
      <meta itemprop="description" content="It is our choices that show what we truly are, far more than our abilities.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Journey">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++设计模式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-12 20:27:10" itemprop="dateCreated datePublished" datetime="2023-06-12T20:27:10+08:00">2023-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-21 18:04:17" itemprop="dateModified" datetime="2023-06-21T18:04:17+08:00">2023-06-21</time>
              </span>

          
            <span id="/archives/c185f75e/" class="post-meta-item leancloud_visitors" data-flag-title="C++设计模式" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/archives/c185f75e/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/archives/c185f75e/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="c-design-patterns">C++ Design Patterns</h1>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yr4y157Ci">李建忠 C++
设计模式</a></p>
<p>《设计模式 可复用面向对象软件的基础》</p>
</blockquote>
<h2 id="设计模式初探">设计模式初探</h2>
<p><strong>什么是设计模式？</strong></p>
<blockquote>
<p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。
——Christopher Alexander</p>
<p>“设计模式”某种程度上是为了弥补语言上的不足实现的。</p>
</blockquote>
<p><strong>底层思维与抽象思维</strong></p>
<ul>
<li><p><strong>底层思维：</strong>向下，语言构造、编译转换、内存模型、运行时机制</p></li>
<li><p><strong>抽象思维：</strong>向上，面向对象、组件封装、设计模式、架构模式</p></li>
</ul>
<p><strong>向下：深入理解三大面向对象机制</strong></p>
<ul>
<li>封装：隐藏内部实现</li>
<li>继承：复用现有代码</li>
<li>多态：改写对象行为</li>
</ul>
<p><strong>向上：深刻把握面向对象机制带来的抽象意义，理解如何用这些机制表达现实世界，用抽象思维进行评判，掌握什么是“好的面向对象设计”</strong></p>
<p>需求的变化很多时候会冲击整个软件架构，因此在设计软件时要考虑应对复杂性的方式：</p>
<ul>
<li><p><strong>分解：</strong>分而治之，大问题分成小问题，整体流程分成小流程，复杂问题分成简单问题</p></li>
<li><p><strong>抽象：</strong>由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型</p></li>
</ul>
<span id="more"></span>
<h2 id="is-a与has-a">Is-a与Has-a</h2>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45590473/article/details/107294520">Has-a与Is-a的区别</a></p>
</blockquote>
<p><strong>Is-a：class A is a kind of class B，A类是B类。</strong></p>
<p>通过<strong>public继承</strong>实现Is-a，最大化保留了基类的public接口，并在基类的基础上进行补充和扩展。</p>
<p><strong>例如：</strong>class B=哺乳动物的主要特征（Base），class
A=人的主要特征（Derived），由于哺乳动物是人的主要属性，A需要继承B的全部接口，因此
A is B</p>
<p><strong>Has-a：class A has a kind of
B，A类是B类的一部分。</strong></p>
<p>通过<strong>private继承</strong>实现Has-a，完全舍弃了基类的public接口。</p>
<p><strong>例如：</strong>class B=机翼（Base），class
A=飞机（Derived），由于机翼是飞机的部分组成，但机翼的信息只需提供给飞机使用，由飞机最后给出供外部使用的public接口，因此飞机（A）不应该保留机翼（B）的任何接口，此时A
has a kind of B。</p>
<h2 id="面向对象设计原则">面向对象设计原则</h2>
<p><strong>面向对象针对的问题是：对代码结构造成冲击的需求变化</strong></p>
<p><strong>理解隔离变化</strong></p>
<ul>
<li>从宏观层面看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小</li>
</ul>
<p><strong>各司其职</strong></p>
<ul>
<li>从微观层面看，面向对象的方式更强调的各个类的“责任”</li>
<li>由于需求变化导致的新增类型不应该影响原来类型的实现 -- 各负其职</li>
</ul>
<p><strong>对象是什么</strong></p>
<ul>
<li>从语言实现层面来看，对象封装了代码和数据</li>
<li>从规格层面讲，对象是一系列可被使用的公共接口</li>
<li>从概念层面讲，对象是某种拥有责任的抽象</li>
</ul>
<h3 id="八大设计原则">八大设计原则</h3>
<ul>
<li><strong>依赖倒置原则（DIP）</strong>
<ul>
<li>高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）</li>
<li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象</li>
</ul></li>
<li><strong>开放封闭原则（OCP）</strong>
<ul>
<li>对扩展开放，对更改封闭</li>
<li>类模块应该是可扩展的，但是不可修改</li>
</ul></li>
<li><strong>单一职责原则（SRP）</strong>
<ul>
<li>一个类应该仅有一个引起它变化的原因</li>
<li>变化的方向隐含着类的责任</li>
</ul></li>
<li><strong>Liskov替换原则（LSP）</strong>
<ul>
<li>实际使用时，子类必须能够替换它们的基类（<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/Is-a/15813994?fr=aladdin">IS-A</a>,
subsumption）</li>
<li>继承表达类型抽象（一般化与特殊化）</li>
</ul></li>
<li><strong>接口隔离原则（ISP）</strong>
<ul>
<li>不应该强迫客户程序依赖它们不用的方法</li>
<li>接口应该小而完备</li>
</ul></li>
<li><strong>组合优于继承</strong>
<ul>
<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”</li>
<li>继承在某种程度上破坏了封装性，子类父类耦合度高</li>
<li>对象组合只要求被组合的对象具有良好定义的接口，耦合度低</li>
</ul></li>
<li><strong>封装变化点</strong></li>
<li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层之间的松耦合'</li>
<li><strong>针对接口编程，而不针对实现编程</strong>
<ul>
<li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li>
<li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口</li>
<li>减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案</li>
</ul></li>
</ul>
<p><strong>将设计原则提升为设计经验</strong></p>
<ul>
<li><p><strong>设计习语（Design
Idioms）</strong>：描述与特定编程语言相关的低层模式、技巧与惯用法</p></li>
<li><p><strong>设计模式（Design
Patterns）</strong>：描述类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式等方面</p></li>
<li><p><strong>架构模式（Architectural
Patterns）</strong>：描述系统中与基本结构组织关系密切的高层模式，包括子系统划分、职责，以及如何组织它们之间关系的规则</p></li>
</ul>
<h2 id="种设计模式">23种设计模式</h2>
<blockquote>
<p><strong>继承是稳定的，组合是变化的</strong></p>
<p><strong>编译时复用，运行时多态</strong></p>
</blockquote>
<h3 id="模式分类">模式分类</h3>
<p><strong>从目的来看</strong></p>
<ul>
<li><strong>创建型（Creational）</strong>模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。</li>
<li><strong>结构型（Structural）</strong>模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。</li>
<li><strong>行为型（Behavioral）</strong>模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。</li>
</ul>
<p><strong>从范围来看</strong></p>
<ul>
<li>类模式处理类与子类的静态关系。</li>
<li>对象模式处理对象间的动态关系。</li>
</ul>
<p><strong>从封装变化角度来看</strong></p>
<ul>
<li><strong>组建协作：</strong>Template
Method、Strategy、observer/Event</li>
<li><strong>单一职责：</strong>Decorator、Bridge</li>
<li><strong>对象创建：</strong>Factory、Abstract、Prototype、Builder</li>
<li><strong>对象性能：</strong>Singleton、Flyweight</li>
<li><strong>接口隔离：</strong>Facade、Proxy、Mediator、Adapter</li>
<li><strong>状态变化：</strong>Mememto、State</li>
<li><strong>数据结构：</strong>Composite、Iterator、Chain of
Responsibility</li>
<li><strong>行为变化：</strong>Command、Visitor</li>
<li><strong>领域问题：</strong>Interpreter</li>
</ul>
<p><strong>重构的关键技法：</strong></p>
<ul>
<li>静态 -&gt; 动态</li>
<li>早绑定 -&gt; 晚绑定</li>
<li>继承 -&gt; 组合</li>
<li>编译时依赖 -&gt; 运行时依赖</li>
<li>紧耦合 -&gt; 松耦合</li>
</ul>
<h3 id="组件协作模式">组件协作模式</h3>
<p>现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过<strong>晚期绑定</strong>，来实现<strong>框架与应用程序之间的松耦合</strong>，是二者之间协作时常用的模式</p>
<p><strong>典型模式：</strong>Template
Method、strategy、Observer/Event</p>
<h4 id="template-method-模板样板方法">Template Method 模板/样板方法</h4>
<p><strong>动机（Motivation）：</strong>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p>
<p><strong>问题场景：</strong>如何在<strong>确定稳定操作结构的前提下</strong>，来灵活应对各个<strong>子步骤的变化或者晚期实现需求</strong>？</p>
<p>Library开发时间早，
Application开发时间晚，晚开发的依赖于早开发的，称为<strong>早绑定</strong>，反之称为<strong>晚绑定</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序库开发人员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用程序开发人员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Step4</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Library <span class="title">lib</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Application <span class="title">app</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    lib.<span class="built_in">Step1</span>();</span><br><span class="line">    <span class="keyword">if</span> (app.<span class="built_in">Step2</span>())&#123;</span><br><span class="line">        lib.<span class="built_in">Step3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        app.<span class="built_in">Step4</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    lib.<span class="built_in">Step5</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Template Method 模式定义</strong></p>
<p>定义一个操作中的算法的<strong>骨架
(稳定)</strong>，而将一些步骤<strong>延迟(变化)</strong>到子类中。<strong>Template
Method使得子类可以不改变(复用)一个算法的结构即可重定义(override
重写)该算法的某些特定步骤</strong>。</p>
<p><strong>例如：</strong>算法<strong>主流程是稳定的</strong>，即<code>Run</code>的流程是稳定的，因此将其中不稳定（变化）的<code>Step2</code>和<code>Step4</code>隔离开，由后来者来定义它们，而不影响其在整体流程中的位置和作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序库开发人员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//稳定 template method</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">Step1</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Step2</span>()) &#123; <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">            <span class="built_in">Step3</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">Step4</span>(); <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Step5</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Library</span>()&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;<span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Step4</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//变化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用程序开发人员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> : <span class="keyword">public</span> Library &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">//... 子类重写实现 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Step4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... 子类重写实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Library* pLib = <span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">    lib-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    <span class="keyword">delete</span> pLib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Template Method 总结</strong></p>
<ul>
<li><p>Template
Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（<strong>虚函数的多态性</strong>）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。</p></li>
<li><p>除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template
Method的典型应用。</p></li>
<li><p>在具体实现方面，被Template
Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为<strong>protected</strong>方法。</p></li>
</ul>
<p><img src="1.png"></p>
<p><img src="2.png"></p>
<h4 id="strategy-策略模式">Strategy 策略模式</h4>
<blockquote>
<p><strong>开放封闭原则</strong></p>
</blockquote>
<p><strong>动机（Motivation）：</strong>在软件构建过程中，<strong>某些对象使用的算法可能多种多样，经常改变</strong>，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。如何在运行时根据需要透明地更改对
象的算法？<strong>将算法与对象本身解耦</strong>，从而避免上述问题？</p>
<p><strong>问题场景：</strong>现要根据不同国家的税率做相应的计算，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TaxBase</span> &#123;</span><br><span class="line">    CN_Tax,</span><br><span class="line">    US_Tax,</span><br><span class="line">    DE_Tax,</span><br><span class="line">    FR_Tax       <span class="comment">//更改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalesOrder</span>&#123;</span><br><span class="line">    TaxBase tax;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tax == CN_Tax) &#123; <span class="comment">/* ********** */</span>  &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == US_Tax) &#123; <span class="comment">/* ********** */</span>  &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == DE_Tax) &#123; <span class="comment">/* ********** */</span>  &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == FR_Tax) &#123; <span class="comment">/* ********** */</span>  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Strategy 模式定义</strong></p>
<p>定义一系列算法，把它们<strong>一个个封装起来</strong>，并且使它们<strong>可互相替换</strong>（变化）。该模式<strong>使得算法可独立于使用它的客户程序(稳定)而变化</strong>（扩展，子类化）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaxStrategy</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Calculate</span><span class="params">(<span class="type">const</span> Context&amp; context)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TaxStrategy</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CNTax</span> : <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Calculate</span><span class="params">(<span class="type">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//CNTax</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USTax</span> : <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Calculate</span><span class="params">(<span class="type">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//USTax</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DETax</span> : <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Calculate</span><span class="params">(<span class="type">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//DETax</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FRTax</span> : <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Calculate</span><span class="params">(<span class="type">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//FRTax</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TaxStrategy：抽象接口</span></span><br><span class="line"><span class="comment">// Factory：创建对象</span></span><br><span class="line"><span class="comment">// SalesOrder：使用对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalesOrder</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaxStrategy* strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">SalesOrder</span>(StrategyFactory* strategyFactory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategyFactory-&gt;<span class="built_in">NewStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SalesOrder</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">Context <span class="title">context</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="type">double</span> val = strategy-&gt;<span class="built_in">Calculate</span>(context); <span class="comment">//多态调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Strategy 总结</strong></p>
<ul>
<li>Strategy及其子类为组件提供了一系列<strong>可重用</strong>的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行<strong>切换</strong>。</li>
<li>Strategy模式提供了用条件判断语句以外的另一种选择，<strong>消除条件判断语句，就是在解耦合</strong>。<strong>含有许多条件判断语句的代码通常都需要Strategy模式</strong>。</li>
<li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。</li>
</ul>
<p><img src="3.png"></p>
<h4 id="observer-观察者模式">Observer 观察者模式</h4>
<p><strong>动机（Motivation）：</strong>在软件构建过程中，我们需要为某些对象建立一种<strong>“通知依赖关系”</strong>
——<strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知</strong>。如果这样的依赖关系<strong>过于紧密</strong>，将使软件不能很好地抵御变化。<strong>（依赖倒置原则）</strong></p>
<p><strong>问题场景：</strong>发现实际代码中存在依赖实现细节（依赖于某个对象，例如<code>FileSplitter依赖于ProgressBar</code>）的问题，造成当需要修改细节的表达方式（比如想换一种表示进度的方法）时不得不修改所有关于
<code>ProgressBar</code>
的代码。想通过寻找依赖对象的父类解决依赖细节的问题，但又发现父类并不具备实际需要的方法（例如<code>ProgressBar</code>的父类并不具备表示“进度”的方法）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    TextBox* txtFilePath;</span><br><span class="line">    TextBox* txtFileNumber;</span><br><span class="line">    ProgressBar* progressBar;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        string filePath = txtFilePath-&gt;<span class="built_in">getText</span>();</span><br><span class="line">        <span class="type">int</span> number = <span class="built_in">atoi</span>(txtFileNumber-&gt;<span class="built_in">getText</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number, progressBar)</span></span>;</span><br><span class="line">        splitter.<span class="built_in">split</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSplitter</span></span><br><span class="line">&#123;</span><br><span class="line">    string m_filePath;</span><br><span class="line">    <span class="type">int</span> m_fileNumber;</span><br><span class="line">    ProgressBar* m_progressBar; <span class="comment">// 依赖ProgressBar的实现细节，违背依赖倒置原则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileSplitter</span>(<span class="type">const</span> string&amp; filePath, <span class="type">int</span> fileNumber, ProgressBar* progressBar) :</span><br><span class="line">    <span class="built_in">m_filePath</span>(filePath), </span><br><span class="line">    <span class="built_in">m_fileNumber</span>(fileNumber),</span><br><span class="line">    <span class="built_in">m_progressBar</span>(progressBar)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.读取大文件</span></span><br><span class="line">        <span class="comment">//2.分批次向小文件中写入吗</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line">            <span class="type">float</span> progressValue = m_fileNumber;</span><br><span class="line">            progressValue = (i + <span class="number">1</span>) / progressValue;</span><br><span class="line">            <span class="comment">// 需求：文件分割进度条</span></span><br><span class="line">            m_progressBar-&gt;<span class="built_in">setValue</span>(progressValue); <span class="comment">// 依赖ProgressBar的setValue函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Observer 模式定义</strong></p>
<p>定义对象间的一种<strong>一对多（变化）的依赖关系</strong>，以便当一个对象(Subject)的状态<strong>问题场景：</strong>如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类规模膨胀问题？发生改变时，所有依赖于它的对象都得到通知并自动更新。使用面向对象技术，可以将这种依赖关系<strong>弱化</strong>，并形成一种稳定的依赖关系。从而实现软件体系结构的<strong>松耦合</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者抽象接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IProgress</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoProgress</span><span class="params">(<span class="type">float</span> value)</span></span>=<span class="number">0</span>; <span class="comment">// 执行&quot;通知&quot;动作的接口</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IProgress</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外的观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleNotifier</span> : <span class="keyword">public</span> IProgress &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoProgress</span><span class="params">(<span class="type">float</span> value)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承的合适用法：继承一个普通基类+多个纯接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form, <span class="keyword">public</span> IProgress </span><br><span class="line">&#123;</span><br><span class="line">    TextBox* txtFilePath;</span><br><span class="line">    TextBox* txtFileNumber;</span><br><span class="line">    ProgressBar* progressBar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        string filePath = txtFilePath-&gt;<span class="built_in">getText</span>();</span><br><span class="line">        <span class="type">int</span> number = <span class="built_in">atoi</span>(txtFileNumber-&gt;<span class="built_in">getText</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        ConsoleNotifier cn; <span class="comment">//另一个观察者</span></span><br><span class="line">        <span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number)</span></span>;</span><br><span class="line">        splitter.<span class="built_in">addIProgress</span>(<span class="keyword">this</span>); <span class="comment">//添加观察者1</span></span><br><span class="line">        splitter.<span class="built_in">addIProgress</span>(&amp;cn)； <span class="comment">//添加观察者2</span></span><br><span class="line">        splitter.<span class="built_in">split</span>();</span><br><span class="line">        splitter.<span class="built_in">removeIProgress</span>(<span class="keyword">this</span>); <span class="comment">//移除观察者</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoProgress</span><span class="params">(<span class="type">float</span> value)</span></span>&#123;</span><br><span class="line">        progressBar-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSplitter</span></span><br><span class="line">&#123;</span><br><span class="line">    string m_filePath;</span><br><span class="line">    <span class="type">int</span> m_fileNumber;</span><br><span class="line">    List&lt;IProgress*&gt;  m_iprogressList; <span class="comment">// 抽象通知机制，支持多个观察者</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileSplitter</span>(<span class="type">const</span> string&amp; filePath, <span class="type">int</span> fileNumber) :</span><br><span class="line">        <span class="built_in">m_filePath</span>(filePath), </span><br><span class="line">        <span class="built_in">m_fileNumber</span>(fileNumber)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.读取大文件</span></span><br><span class="line">        <span class="comment">//2.分批次向小文件中写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="type">float</span> progressValue = m_fileNumber;</span><br><span class="line">            progressValue = (i + <span class="number">1</span>) / progressValue;</span><br><span class="line">            <span class="built_in">onProgress</span>(progressValue);<span class="comment">//发送通知</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者（实际传入IProgress的子类对象地址）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addIProgress</span><span class="params">(IProgress* iprogress)</span></span>&#123;</span><br><span class="line">        m_iprogressList.<span class="built_in">push_back</span>(iprogress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeIProgress</span><span class="params">(IProgress* iprogress)</span></span>&#123;</span><br><span class="line">        m_iprogressList.<span class="built_in">remove</span>(iprogress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 调用每一个观察者的DoProgress接口进行通知</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onProgress</span><span class="params">(<span class="type">float</span> value)</span></span>&#123;</span><br><span class="line">        List&lt;IProgress*&gt;::iterator itor=m_iprogressList.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (itor != m_iprogressList.<span class="built_in">end</span>())&#123;</span><br><span class="line">            (*itor)-&gt;<span class="built_in">DoProgress</span>(value); <span class="comment">//更新进度条</span></span><br><span class="line">            itor++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Observer 总结</strong></p>
<ul>
<li>使用面向对象的抽象，Observer模式使得我们可以<strong>独立地改变目标与观察者</strong>，从而使二者之间的<strong>依赖关系达致松耦合</strong>。</li>
<li>目标发送通知时，<strong>无需指定观察者</strong>，通知（可以携带通知信息作为参数）会<strong>自动传播</strong>。</li>
<li>观察者<strong>自己决定是否需要订阅通知</strong>，目标对象对此一无所知。</li>
<li>Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。</li>
</ul>
<p><img src="4.png"></p>
<h3 id="单一职责模式">单一职责模式</h3>
<p>在软件组件的设计中，如果<strong>责任划分不清晰</strong>，使用继承得到的结果往往是<strong>随着需求的变化，子类急剧膨胀</strong>，同时<strong>充斥着重复代码</strong>，这时候的关键是<strong>划清责任</strong>。</p>
<p><strong>典型模式：</strong>Decorator、Bridge</p>
<h4 id="decorator-装饰模式">Decorator 装饰模式</h4>
<blockquote>
<p><strong>该模式是“组合优于继承”原则的典型体现</strong></p>
<p><strong>Decorator的精髓在于用组合+继承的方式使用多态，实现
“运行时装配”，即运行时根据需求将不同功能装配（附着/组装）在一起
，而编译时每个功能是指责单一且代码统一的</strong></p>
<p><strong>Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义（组装/装配/附着/附加）</strong></p>
</blockquote>
<p><strong>动机（Motivation）：</strong>在某些情况下我们可能会“<strong>过度地使用继承来扩展对象的功能</strong>”，由于继承为类型引入的<strong>静态</strong>特质，使得这种扩展方式<strong>缺乏灵活性</strong>；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多<strong>子类规模的膨胀</strong>以及<strong>代码的大量重复</strong>。如何使<strong>“对象功能的扩展”</strong>能够根据需要来<strong>动态地实现</strong>？同时避免“扩展功能的增多”带来的子类规模膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？</p>
<p><strong>问题场景：</strong>有一个表示“流”的抽象基类<code>Stream</code>和三个分别表示文件流、网络流和内存流的子类<code>FileStream</code>、<code>NetworkStream</code>和<code>MemoryStream</code>，现在需要对每一种流分别实现包括加密、缓冲和加密且缓冲在内的三种功能扩展，而若使用继承的方式实现，会出现大量相似的类且有部分重复代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">char</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileStream</span>: <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkStream</span> :<span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryStream</span> :<span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展操作问题所在：为了扩展功能而不得不创建多个形式类似内容仅有部分区别（例如CryptoFileStream和BufferedFileStream对文件流的操作相同，仅仅是加密/缓冲的操作有区别）的子类，造成大量代码重复和子类规模膨胀</span></span><br><span class="line"><span class="comment">// 例如 要实现加密流，就需要为File、Network、Memory三种流都创建一个子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoFileStream</span> :<span class="keyword">public</span> FileStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Read</span>(number);<span class="comment">//读文件流 （此处反映了继承引入的“静态”特质，即该方法是唯一选项且不可修改）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoNetworkStream</span> : :<span class="keyword">public</span> NetworkStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Read</span>(number);<span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Write</span>(data);<span class="comment">//写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoMemoryStream</span> : <span class="keyword">public</span> MemoryStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::<span class="built_in">Read</span>(number);<span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::<span class="built_in">Write</span>(data);<span class="comment">//写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如 要实现缓冲流，就需要为File、Network、Memory三种流都创建一个子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedFileStream</span> : <span class="keyword">public</span> FileStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedNetworkStream</span> : <span class="keyword">public</span> NetworkStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedMemoryStream</span> : <span class="keyword">public</span> MemoryStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要同时实现加密和缓冲操作，也需要创建三个子类，同时产生了重复代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoBufferedFileStream</span> :<span class="keyword">public</span> FileStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Read</span>(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CryptoFileStream *fs1 = <span class="keyword">new</span> <span class="built_in">CryptoFileStream</span>();</span><br><span class="line">    BufferedFileStream *fs2 = <span class="keyword">new</span> <span class="built_in">BufferedFileStream</span>();</span><br><span class="line">    CryptoBufferedFileStream *fs3 =<span class="keyword">new</span> <span class="built_in">CryptoBufferedFileStream</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模式定义</strong></p>
<p><strong>动态（组合）</strong>地给一个对象<strong>增加</strong>一些额外的<strong>职责</strong>。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（<strong>消除重复代码</strong>
&amp; <strong>减少子类个数</strong>）。</p>
<p><strong>重构版本 0.5：</strong>保留
<code>Stream</code>、<code>FileStream</code>、<code>NetworkStream</code>和<code>MemoryStream</code>
，通过将抽象类<code>Stream</code>以组合的形式融入子类中，实现将扩展需求相同（例如都需要加密）但流类型不同的子类（如<code>CryptoFileStream</code>、<code>CryptoNetworkStream</code>、<code>CryptoMemoryStream</code>）合并为同一个子类（<code>CryptoStream</code>）的目的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展操作</span></span><br><span class="line"><span class="comment">// 继承Stream仍然是必要的，一方面确保接口规范，另一方面是为了使用多态的特性来组合不同功能的子类，比如当需要同时实现Crypto和Buffer两种功能时，需要将 CryptoStream* 以 Stream* 的形式（多态）传递给 BufferedStream，才能使BufferedStream中的Read、Seek和write方法调用CryptoStream的同名方法执行加密操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoStream</span>: <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    Stream* stream; <span class="comment">// 组合与多态的“动态”特质，编译时代码相同，运行时功能多态</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CryptoStream</span>(Stream* strm):<span class="built_in">stream</span>(strm)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Read</span>(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedStream</span> : <span class="keyword">public</span> Stream&#123;</span><br><span class="line">    Stream* stream; <span class="comment">// 组合与多态的“动态”特质，编译时代码相同，运行时功能多态</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferedStream</span>(Stream* stm):<span class="built_in">stream</span>(stm)&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    FileStream* s1 = <span class="keyword">new</span> <span class="built_in">FileStream</span>();</span><br><span class="line">    CryptoStream* s2 = <span class="keyword">new</span> <span class="built_in">CryptoStream</span>(s1);  <span class="comment">// 实现了一个 CryptoFileStream</span></span><br><span class="line">    BufferedStream* s3 = <span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s1); <span class="comment">// 实现了一个 BufferedFileStream</span></span><br><span class="line">    BufferedStream* s4 = <span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s2); <span class="comment">// 实现了一个 CryptoBufferedFileStream</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重构版本
1.0：</strong>重构理论中，如果某一个类有多个子类有同一个字段时，应该将该字段往上提（即该字段应该归属于更高层的类）。在本例重构版本0.5中，二级衍生类
<code>CryptoStream</code>和<code>BufferedStream</code>拥有相同字段<code>Stream* stream</code>，因此一种方式是将该字段提到<code>Stream</code>抽象类中，但又由于一级衍生类<code>FileStream</code>、<code>NetworkStream</code>和<code>MemoryStream</code>不需要该字段就已经功能完整了，因此可以设计一个中间类
<code>Decorator</code>，让子类可以选择性地继承该字段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展操作</span></span><br><span class="line"><span class="comment">// 中间件，区分于直接继承Stream，子类在继承DecoratorStream时会带有一个stream组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorStream</span> : <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Stream* stream;</span><br><span class="line">    <span class="built_in">DecoratorStream</span>(Stream * stm):<span class="built_in">stream</span>(stm)&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoStream</span>: <span class="keyword">public</span> DecoratorStream &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CryptoStream</span>(Stream* stm):<span class="built_in">DecoratorStream</span>(stm)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Read</span>(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedStream</span> : <span class="keyword">public</span> DecoratorStream&#123;</span><br><span class="line">    Stream* stream;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferedStream</span>(Stream* stm):<span class="built_in">DecoratorStream</span>(stm)&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    FileStream* s1 = <span class="keyword">new</span> <span class="built_in">FileStream</span>();</span><br><span class="line">    CryptoStream* s2 = <span class="keyword">new</span> <span class="built_in">CryptoStream</span>(s1);  <span class="comment">// 实现了一个 CryptoFileStream</span></span><br><span class="line">    BufferedStream* s3 = <span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s1); <span class="comment">// 实现了一个 BufferedFileStream</span></span><br><span class="line">    BufferedStream* s4 = <span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s2); <span class="comment">// 实现了一个 CryptoBufferedFileStream</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>通过采用<strong>组合+继承</strong>的手法（该模式中继承是为了接口规范以及运行时能够嵌套使用，不等同于一般的继承目的），
Decorator模式实现了在<strong>运行时动态扩展对象功能的能力</strong>，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。</li>
<li>Decorator类在接口上表现为<strong>is-a</strong>
Component的继承关系，即Decorator类继承了Component类<strong>所有的接口</strong>。但在实现上又表现为<strong>has-a</strong>
Component的组合关系，即Decorator类又使用了<strong>另外一个</strong>Component类。</li>
<li>Decorator模式的目的<strong>并非</strong>解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决<strong>“主体类在多个方向上的扩展功能”</strong>——是为“装饰”的含义</li>
</ul>
<p><img src="5.png"></p>
<p><img src="6.png"></p>
<h4 id="bridge-桥模式">Bridge 桥模式</h4>
<blockquote>
<p><strong>从解决问题的类型看，Decorator模式要解决“为了扩展一个类的功能，不得不创建多个子类分别继承它，而当扩展子类功能时又要创建子类”所带来的问题，而Bridge模式要解决“不同发展维度杂糅成一个了类，导致要扩展某个维度的功能时不得不创建子类从而又继承了其他维度的功能”的问题</strong></p>
<p><strong>从解决方式的角度看，Decorator更多是一种“合并”，Bridge则更倾向于“拆分”</strong></p>
<p><strong>从实现方式的角度看，Decorator模式通过组合+继承的方式合并了同一个功能方向的各个扩展，而Bridge模式则以“拆分+组合”的方式使不同发展方向独立成不同的类</strong></p>
<p><strong>"Bridge"体现在拆分了不同维度之后，又通过组合的方式将它们联系起来，这种联系就像是Bridge一样</strong></p>
</blockquote>
<p><strong>动机（Motivation）：</strong>由于某些类型的<strong>固有的实现逻辑</strong>，使得它们具有两个变化的维度，乃至多个纬度的变化。如何应对这种<strong>“多维度的变化”</strong>？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而<strong>不引入额外的复杂度</strong>？</p>
<p><strong>问题场景：</strong>为了写一个PC端的Lite版平台，由于PC端的底层功能实现与Lite版需求的业务功能杂糅在一个类里，导致不得不创建一个子类，先实现PC端底层功能、再实现Lite版业务功能，下一次需要实现Mobile端的Perfect版平台，也得按这个流程来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务功能+平台实现 抽象为同一个基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Messager</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//平台实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCMessagerBase</span> : <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MobileMessagerBase</span> : <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCMessagerLite</span> : <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MobileMessagerLite</span> : <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        MobileMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        MobileMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        MobileMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCMessagerPerfect</span> : <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MobileMessagerPerfect</span> : <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//编译时装配</span></span><br><span class="line">	Messager *m = <span class="keyword">new</span> <span class="built_in">MobileMessagerPerfect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模式定义</strong></p>
<p><strong>将抽象部分(业务功能)与实现部分(平台实现)分离</strong>，使它们都可以独立地变化</p>
<p><strong>将两种不同的变化方向分离开，将它们所带动的行为的多态实现也分开发展</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平台实现抽象</span></span><br><span class="line"><span class="comment">// 平台实现例如：播放音效、绘制图案、创建连接等</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessagerImp</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">MessagerImp</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务功能抽象</span></span><br><span class="line"><span class="comment">// 业务功能例如：登录、发送消息、传输图片等</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Messager</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    MessagerImp* messagerImp; <span class="comment">// 原本该字段在MessagerLite和MessagerPerfect中，出于设计的要求将其提升至父类中</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Messager</span>(MessagerImp* msgIMp)&#123; messagerImp = msgImp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不同的平台实现（例如PC端和移动端需要用不同的方法实现播放音效、画图等平台基础功能） n</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCMessagerImp</span> : <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MobileMessagerImp</span> : <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不同的业务抽象（例如清量版和完整版可能需要不同的登录、发送效果） m</span></span><br><span class="line"><span class="comment">//类的数目：1+n+m</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessagerLite</span> : <span class="keyword">public</span> Messager &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MessageLite</span>(MessagerImp* msgImp) : <span class="built_in">Messager</span>(msgImp)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessagerPerfect</span> : <span class="keyword">public</span> Messager &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MessagerPerfect</span>(MessagerImp* msgImp) : <span class="built_in">Messager</span>(msgImp)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    MessagerImp* mImp = <span class="keyword">new</span> <span class="built_in">PCMessagerImp</span>(); <span class="comment">// PC端的平台实现</span></span><br><span class="line">    Messager *m = <span class="keyword">new</span> <span class="built_in">MessagerLite</span>(mImp); <span class="comment">// 实现一个PC端Lite版的Messager</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>Bridge模式使用“对象间的<strong>组合</strong>关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓<strong>抽象和实现沿着各自纬度的变化，即“子类化”它们</strong>。</li>
<li>Bridge模式有时候类似于多继承方案，但是多继承方案往往<strong>违背单一职责原则</strong>（即一个类只有一个变化的原因），复用性比较差。Bridge模式是<strong>比多继承方案更好的解决方法</strong>。</li>
<li>Bridge模式的应用一般在<strong>“两个非常强的变化维度”</strong>，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式</li>
</ul>
<p><img src="7.png"></p>
<h3 id="对象创建模式">对象创建模式</h3>
<p>通过“对象创建”
模式<strong>绕开new</strong>，来避免对象创建（new）过程中所导致的<strong>紧耦合（依赖具体类）</strong>，从而支持<strong>对象创建的稳定</strong>。它是<strong>接口抽象之后的第一步工作</strong>。</p>
<p><strong>典型模式：</strong>Factory Method、Abstract
Factory、Prototype、Builder</p>
<h4 id="factory-method-工厂方法">Factory Method 工厂方法</h4>
<blockquote>
<p><strong>将产品抽象化，且将创建产品的工厂抽象化，在使用时用具体工厂创建具体产品，但不论是具体工厂或具体产品，都使用抽象指针替代，实现多态性</strong></p>
<p><strong>一个抽象产品类，一个抽象工厂类，一种具体工厂生产一种产品</strong></p>
</blockquote>
<p><strong>动机（Motivation）：</strong>在软件系统中，经常面临着创建对象的工作；由于需求的变化，<strong>需要创建的对象的具体类型经常变化</strong>。如何应对这种变化？如何<strong>绕过常规的对象创建方法(new)</strong>，提供一种<strong>“封装机制”</strong>来避免客户程序和这种<strong>“具体对象创建工作”的紧耦合</strong>？</p>
<p><strong>问题场景：</strong>需要根据需求创建不同的<code>Splitter</code>具体对象，如<code>BinarySplitter</code>、<code>TxtSplitter</code>、<code>PictureSplitter</code>、<code>VideoSplitter</code>等，但<code>new</code>创建对象的过程是写死的，不得不依赖于对象所属的类，造成了紧耦合。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ISplitter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ISplitter</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySplitter</span> : <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxtSplitter</span>: <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PictureSplitter</span>: <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSplitter</span>: <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">      ISplitter * splitter= <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>();<span class="comment">//依赖具体类</span></span><br><span class="line">      splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>模式定义</strong></p>
<p>定义一个用于创建对象的接口，让<strong>子类决定实例化哪一个类</strong>。Factory
Method使得一个类的实例化延迟（<strong>目的：解耦，手段：虚函数</strong>）到子类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ISplitter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ISplitter</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySplitter</span> : <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxtSplitter</span>: <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PictureSplitter</span>: <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSplitter</span>: <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SplitterFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SplitterFactory</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySplitterFactory</span>: <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxtSplitterFactory</span>: <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PictureSplitterFactory</span>: <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PictureSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSplitterFactory</span>: <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainForm以来SplitterFactory，而该类是抽象的（稳定的）</span></span><br><span class="line"><span class="comment">// 根据需求，在初始化MainForm时传入不同类型的工厂，以达到创建不同对象的目的</span></span><br><span class="line"><span class="comment">// 这样以来，在需要扩展新对象或修改创建的对象时，不需要直接修改创建对象过程的具体代码，而在运行时根据需求修改参数即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    SplitterFactory* factory;<span class="comment">//工厂</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>(SplitterFactory* factory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;factory=factory;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ISplitter * splitter = factory-&gt;<span class="built_in">CreateSplitter</span>(); <span class="comment">//多态new</span></span><br><span class="line">        splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>Factory
Method模式用于<strong>隔离类对象的使用者和具体类型之间的耦合关系</strong>。面对一个<strong>经常变化</strong>的具体类型，<strong>紧耦合关系(new)会导致软件的脆弱</strong>。</li>
<li>Factory
Method模式通过面向对象的手法，<strong>将所要创建具体对象的工作延迟到子类</strong>，从而实现一种<strong>扩展（而非更改）的策略</strong>，较好地解决了这种紧耦合关系。</li>
<li>Factory
Method模式解决“单个对象”的需求变化。<strong>缺点在于要求创建方法/参数相同</strong>。</li>
</ul>
<p><img src="8.png"></p>
<h4 id="abstract-factory-抽象工厂">Abstract Factory 抽象工厂</h4>
<blockquote>
<p><strong>Abstract Factory 应该叫 Family Factory 更合适</strong></p>
<p><strong>多个抽象产品类，一个抽象工厂类，一个具体工厂能创建多个具体产品</strong></p>
<p><strong>Abstract Factory 将有一系列有关联的工厂（对象创建抽象）
整合到一起，具备创建多个产品的能力</strong></p>
<p><strong>Factory Method方法是Abstract Factory的特例，当Abstract
Factory抽象工厂类内仅创建一个产品时二者等价</strong></p>
</blockquote>
<p><strong>动机（Motivation）：</strong>在软件系统中，经常面临着<strong>“一系列相互依赖的对象”</strong>的创建工作；同时，由于需求的变化，往往<strong>存在更多系列对象的创建工作</strong>。如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种<strong>“多系列具体对象创建工作”</strong>的紧耦合？</p>
<p><strong>问题场景：</strong>现要实现一个兼容多种数据库的交互模块，已知对数据库的操作在抽象层面是统一的（例如都有建立连接、增删改查等），由于这些操作之间存在相互依赖关系（例如建立连接是执行其他操作的必要条件），于是对每一种操作都使用工厂方法，并将具体工厂集中在<code>EmployeeDAO</code>内。然而，针对不同数据库的操作是不可互相依赖的（例如建立了对sqlserver的连接之后无法读写Oracle数据库），这就要求<code>EmployeeDAO</code>必需创建同一个系列的工厂才能运作，在客户端如果不加注意传入不同类型的Factory，会引入不必要的麻烦。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库访问有关的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDBConnection</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDBConnectionFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConn ection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDBCommand</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDBCommandFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDataReader</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDataReaderFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持SQL Server</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnection</span>: <span class="keyword">public</span> IDBConnection&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnectionFactory</span>:<span class="keyword">public</span> IDBConnectionFactory&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlCommand</span>: <span class="keyword">public</span> IDBCommand&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlCommandFactory</span>:<span class="keyword">public</span> IDBCommandFactory&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlDataReader</span>: <span class="keyword">public</span> IDataReader&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlDataReaderFactory</span>:<span class="keyword">public</span> IDataReaderFactory&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持Oracle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OracleConnection</span>: <span class="keyword">public</span> IDBConnection&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OracleCommand</span>: <span class="keyword">public</span> IDBCommand&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OracleDataReader</span>: <span class="keyword">public</span> IDataReader&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeDAO</span>&#123;</span><br><span class="line">    IDBConnectionFactory* dbConnectionFactory;</span><br><span class="line">    IDBCommandFactory* dbCommandFactory;</span><br><span class="line">    IDataReaderFactory* dataReaderFactory;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IDBConnection* connection = dbConnectionFactory-&gt;<span class="built_in">CreateDBConnection</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">ConnectionString</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        IDBCommand* command = dbCommandFactory-&gt;<span class="built_in">CreateDBCommand</span>();</span><br><span class="line">        command-&gt;<span class="built_in">CommandText</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        command-&gt;<span class="built_in">SetConnection</span>(connection); <span class="comment">//关联性</span></span><br><span class="line">        IDBDataReader* reader = command-&gt;<span class="built_in">ExecuteReader</span>(); <span class="comment">//关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;<span class="built_in">Read</span>()) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>模式定义</strong></p>
<p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相关性例如：执行数据库操作需要先建立connection</span></span><br><span class="line"><span class="comment">// 抽象产品1与具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDBConnection</span>&#123;...&#125;; <span class="comment">// 抽象：数据库连接 (Interface DataBase Connection)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnection</span> : <span class="keyword">public</span> IDBConnection&#123;...&#125;; <span class="comment">// 具体 sqlserver</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OracleConnection</span> : <span class="keyword">public</span> IDBConnection&#123;...&#125;; <span class="comment">// 具体 oracle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品2与具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDBCommand</span>&#123;...&#125;;    <span class="comment">// 抽象：数据库指令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlCommand</span>: <span class="keyword">public</span> IDBCommand&#123;...&#125;; <span class="comment">// 具体 sqlserver</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OracleCommand</span>: <span class="keyword">public</span> IDBCommand&#123;...&#125;; <span class="comment">// 具体 oracle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品3与具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDataReader</span>&#123;...&#125;;   <span class="comment">// 抽象：数据获取</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlDataReader</span>: <span class="keyword">public</span> IDataReader&#123;...&#125;; <span class="comment">// 具体 sqlserver</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OracleDataReader</span>: <span class="keyword">public</span> IDataReader&#123;...&#125;; <span class="comment">// 具体 oracle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDBFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">// 抽象产品1创建器</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">// 抽象产品2创建器</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;  <span class="comment">// 抽象产品3创建器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlDBFactory</span>:<span class="keyword">public</span> IDBFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OracleDBFactory</span>:<span class="keyword">public</span> IDBFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用SqlDBFactory或OracleDBFactory对象初始化dbFactory成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeDAO</span>&#123;</span><br><span class="line">    IDBFactory* dbFactory;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IDBConnection* connection = dbFactory-&gt;<span class="built_in">CreateDBConnection</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">ConnectionString</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        IDBCommand* command = dbFactory-&gt;<span class="built_in">CreateDBCommand</span>();</span><br><span class="line">        command-&gt;<span class="built_in">CommandText</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        command-&gt;<span class="built_in">SetConnection</span>(connection); <span class="comment">//关联性</span></span><br><span class="line">        IDBDataReader* reader = command-&gt;<span class="built_in">ExecuteReader</span>(); <span class="comment">//关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;<span class="built_in">Read</span>())&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>如果没有应对<strong>“多系列对象构建”</strong>的需求变化，则没有必要使用Abstract
Factory模式，这时候使用简单的工厂完全可以。</li>
<li>“系列对象”指的是<strong>在某一特定系列下的对象之间有相互依赖、或作用的关系</strong>。不同系列的对象之间不能相互依赖。</li>
<li>Abstract
Factory模式主要在于应对<strong>“新系列”</strong>的需求变动。其缺点在于难以应对<strong>“新对象”</strong>的需求变动。</li>
</ul>
<p><img src="9.png"></p>
<h4 id="prototype-原型模式">Prototype 原型模式</h4>
<blockquote>
<p>当对象复杂较为复杂，初始状态不适合直接使用时（即需要灵活保留某种中间状态），Protype比Factory更具有优势</p>
</blockquote>
<p><strong>动机（Motivation）：</strong>在软件系统中，经常面临着<strong>”某些结构复杂的对象“</strong>的创建工作；由于需求的变化，这些<strong>对象常常面临剧烈的变化</strong>，但它们<strong>却拥有比较稳定一致的接口</strong>。如何应对这种变化？如何向”客户程序（使用这些对象的程序）“隔离出”这些易变对象“，从而使得”以来这些易变对象的客户程序“不随需求改变而改变？</p>
<p><strong>模式定义</strong></p>
<p>使用原型实例指定创建对象的种类，然后通过<strong>深拷贝</strong>这些原型来创建新的对象</p>
<p>Prototype模式将工厂方法的抽象工厂<code>SplitterFactory</code>与抽象产品<code>ISplitter</code>合并，并用<code>clone</code>的方法取代了原本工厂创建产品的方法<code>CreateSplitter</code>，通过克隆自己来创建新产品</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ISplitter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">//通过克隆自己来创建对象</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ISplitter</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySplitter</span> : <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxtSplitter</span>: <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PictureSplitter</span>: <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PictureSplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSplitter</span>: <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoSplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端，根据传入对象的具体类型保存Prototype，传入什么就clone什么</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    ISplitter * prototype;<span class="comment">//原型对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>(ISplitter*  prototype)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prototype = prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ISplitter * splitter = prototype-&gt;<span class="built_in">clone</span>(); <span class="comment">//克隆原型</span></span><br><span class="line">        splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有“稳定的接口”。</li>
<li>Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活地动态创建“拥有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone。</li>
<li>Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝（常见于非C++语言）。</li>
</ul>
<p><img src="10.png"></p>
<h4 id="builder-构建器">Builder 构建器</h4>
<blockquote>
<p><strong>构建流程相同，流程中的步骤细节不同，与Template
Method类似，Builder应用于对象创建中</strong></p>
</blockquote>
<p><strong>动机（Motivation）：</strong>在软件系统中，有时候面临着<strong>“一个复杂对象”</strong>的创建工作，其<strong>通常由各个部分的子对象用一定的算法构成</strong>；由于需求的变化，这个复杂对象的各个部分经常面临着<strong>剧烈的变化</strong>，但是<strong>将它们组合在一起的算法却相对稳定</strong>。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？</p>
<p><strong>模式定义</strong></p>
<p>将一个复杂对象的构建流程与细节拆分，使得同样的构建过程（稳定）可以创建不同的表示（变化）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">House</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoneHouse</span>: <span class="keyword">public</span> House&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">House* <span class="title">GetResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">HouseBuilder</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">		House* pHouse;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoneHouseBuilder</span>: <span class="keyword">public</span> HouseBuilder&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//pHouse-&gt;Part1 = ...;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseDirector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HouseBuilder* pHouseBuilder;</span><br><span class="line">    <span class="built_in">HouseDirector</span>(HouseBuilder* pHouseBuilder)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">House* <span class="title">Construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        pHouseBuilder-&gt;<span class="built_in">BuildPart1</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            pHouseBuilder-&gt;<span class="built_in">BuildPart2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag=pHouseBuilder-&gt;<span class="built_in">BuildPart3</span>();</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            pHouseBuilder-&gt;<span class="built_in">BuildPart4</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        pHouseBuilder-&gt;<span class="built_in">BuildPart5</span>();</span><br><span class="line">        <span class="keyword">return</span> pHouseBuilder-&gt;<span class="built_in">GetResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>Builder
模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</li>
<li>变化点在哪里，封装哪里——
Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。</li>
<li>在Builder模式中，要注意不同语言中构造器内调用虚函数的差别（C++ vs.
C#)</li>
</ul>
<h3 id="对象性能模式">对象性能模式</h3>
<p>面向对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。</p>
<p><strong>典型模式：</strong>Singleton、Flyweight</p>
<h4 id="singleton-单件模式">Singleton 单件模式</h4>
<p><strong>动机（Motivation）：</strong>在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性以及良好的效率。如何绕过常规的构造器，提供一种机制来确保一个类只有一个实例？这应该是设计者的责任，而不是使用者的责任。</p>
<p><strong>模式定义：
</strong>保证一个类仅有一个实例，并提供一个该实例的全局访问点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(); <span class="comment">// 构造函数私有化</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other); <span class="comment">// 拷贝构造私有化	</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>; <span class="comment">// 静态成员方法</span></span><br><span class="line">    <span class="type">static</span> Singleton* m_instance; <span class="comment">// 静态成员方法</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Singleton* Singleton::m_instance = <span class="literal">nullptr</span>; <span class="comment">// 静态成员的初始化</span></span><br></pre></td></tr></table></figure>
<p><strong>V0.5 线程不安全</strong></p>
<p>假设有两个线程调用此函数，当线程1的<code>new</code>操作未结束时，线程2执行了该函数，那么线程2中<code>if</code>依然成立，<code>m_instance</code>会被构造两次</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程非安全版本</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>V1.0 线程安全，但代价过高</strong></p>
<p>为了解决线程不安全的问题，在任意一个线程进入该函数时都上锁。<code>Lock</code>可以理解为一种全局信号量，其工作逻辑是同一时间仅允许对<code>lock</code>进行一次访问。这样假设线程1先执行，那么线程2会因无法取得<code>Lock</code>而被阻塞在第一句，也就阻止了线程2对<code>m_instance</code>的重复构造，在线程1完成构造后<code>if</code>就不再成立了。</p>
<p>这种写法虽然线程安全，但在初始化完成后，由于该方法仅仅是一个读<code>m_instance</code>的操作，给读操作上线程锁是一种资源浪费，反而引入新的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程安全版本，但锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>V1.0 双检查锁 构造过程内存读写reoder不安全</strong></p>
<p>为了在安全的前提下兼顾程序效率，采用双检查锁的方式。假设线程1先执行，则线程被阻塞直到线程1完成<code>new</code>操作。在初始化完成后，外层<code>if</code>条件不再成立，也就确保之后调用该函数时不再上锁。</p>
<p>然而，由于编译器底层逻辑与代码层逻辑存在差异，在代码层面，执行<code>new</code>操作遵循“分配空间-&gt;根据构造规则初始化数据-&gt;返回首地址指针”的顺序，而编译器可能会将后两个步骤调序，即分配空间后先返回指针，再进行数据初始化，导致<code>m_instance</code>存在未被初始化即被使用的安全隐患。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双检查锁，但由于内存读写reorder不安全</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>V3.0 C++11的跨平台实现（volatile）</strong></p>
<p>针对双检查锁的安全隐患，Java/C#语言利用volatile关键字声明构造器的执行过程不可被reorder。C++11通过atomic库的<code>std::atomic_thread_fence</code>方法实现了该功能。</p>
<blockquote>
<p><strong>对于同一个atomic，在线程A中使用memory_order_release调用store()，在线程B中使用memory_order_acquire调用load()。这种模型保证在store()之前发生的所有读写操作(A线程)不会在store()后调用，在load()之后发生的所有读写操作(B线程)不会在load()的前调用，A线程的所有写入操作对B线程可见。Ref：</strong><a
target="_blank" rel="noopener" href="https://blog.csdn.net/xiongya8888/article/details/100555413">C++
atomic和memory_order</a></p>
</blockquote>
<p>假设线程1先执行，线程2后执行。线程1用<code>memory_order_acquire</code>调用<code>load</code>，线程2用<code>memory_order_release</code>调用<code>load</code></p>
<p><code>store</code>之后发生的读写操作不会在<code>store</code>之前调用，表示线程1中对<code>tmp</code>内存的初始化操作在<code>return</code>之前执行，即保证了先初始化内存，再返回指针。</p>
<p><code>load</code>之后发生的读写操作不会在<code>load</code>之前调用，表示仅可通过调用<code>load</code>获取对某块内存的权限。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 11版本之后的跨平台实现 (volatile)</span></span><br><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire); <span class="comment">//获取内存fence，此处针对上一行由load返回的指针，若空则为nullptr，非空则为对象地址</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123; <span class="comment">// 双检查1</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">// 上锁</span></span><br><span class="line">        tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123; <span class="comment">// 双检查2</span></span><br><span class="line">            tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line">            std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.<span class="built_in">store</span>(tmp, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>Singleton模式中的实例构造器可以设置为<strong>protected</strong>以允许子类派生。</li>
<li>Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷相违背。</li>
<li>如何实现多线程环境下安全的Singleton？注意对<strong>双检查锁</strong>的正确实现。</li>
</ul>
<p><img src="12.png"></p>
<h4 id="flyweight-享元模式">Flyweight 享元模式</h4>
<p><strong>动机（Motivation）：</strong>在软件系统采用纯粹对象方案的问题在于<strong>大量细粒度的对象</strong>会很快充斥在系统中，从而带来很高的<strong>运行时代价</strong>——主要指内存需求方面的代价。如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来操作？</p>
<p><strong>问题场景：</strong>假设要用纯面向对象方式实现一个字符处理系统，每一种字符字体都创建一个对象的内存开销太大。</p>
<p><strong>模式定义：</strong>运用<strong>共享技术</strong>有效地支持大量细粒度的对象，用对象池的方式存储细粒度对象，在用户使用对象时查询对象池，存在即返回，不存在即创建并入池。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//unique object key</span></span><br><span class="line">    string key;</span><br><span class="line">    <span class="comment">//object state</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Font</span>(<span class="type">const</span> string&amp; key)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FontFactory</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string,Font* &gt; fontPool;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Font* <span class="title">GetFont</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span>&#123;</span><br><span class="line">        map&lt;string,Font*&gt;::iterator item=fontPool.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(item!=footPool.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> fontPool[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Font* font = <span class="keyword">new</span> <span class="built_in">Font</span>(key);</span><br><span class="line">            fontPool[key]= font;</span><br><span class="line">            <span class="keyword">return</span> font;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>面向对象很好地解决了抽象性问题，但是作为一个运行在机器中程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</li>
<li>Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。</li>
<li>对象的数量太大从而导致对象内存开销加大——什么样的数量才算大？这需要我们仔细地根据具体应用情况进行评估，而不能凭空臆断。</li>
</ul>
<p><img src="13.png"></p>
<h3 id="接口隔离模式">接口隔离模式</h3>
<p>在组件构建过程中，某些<strong>接口之间直接的依赖</strong>常常会带来很多问题、甚至根本无法实现。采用<strong>添加一层间接（稳定）接口</strong>，来隔离本来互相紧密关联的接口是一种常见的解决方案。</p>
<p><strong>典型模式：</strong>Facade、Proxy、Adapter、Mediator</p>
<h4 id="facade-门面模式">Facade 门面模式</h4>
<p><img src="14.png"></p>
<p><strong>动机（Motivation）：</strong>
上述A方案的问题在于组件的客户和组件中<strong>各种复杂的子系统有了过多的耦合</strong>，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。如何简化外部客户程序和系统间的交互接口？<strong>如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？</strong></p>
<p><strong>模式定义</strong></p>
<p>为子系统中的一组接口提供一个一致（稳定）的界面，Facade模式定义了一个高层接口。这个接口使得这一子系统更加容易使用（复用）</p>
<p><strong>总结</strong></p>
<ul>
<li>从客户程序的角度来看，Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“解耦“的效果——内部子系统的任何变化不会影响到Facade接口的变化。</li>
<li>Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。</li>
<li>Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件的内部应该是”相互耦合关系比较大的一系列组件“，而不是一个简单的功能集合。</li>
</ul>
<h4 id="proxy-代理模式">Proxy 代理模式</h4>
<p><strong>动机（Motivation）：</strong>在面向系统对象中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者或系统结构带来很多麻烦。如何在不失去<strong>透明操作</strong>（即用同一种接口操作，不需要考虑背后的细节）对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。</p>
<p><strong>模式定义</strong></p>
<p>为其他对象提供一种代理以控制（隔离、使用接口）对这个对象的访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ISubject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Proxy的设计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubjectProxy</span>: <span class="keyword">public</span> ISubject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//对RealSubject的一种间接访问</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientApp</span>&#123;</span><br><span class="line">    ISubject* subject;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClientApp</span>()&#123;</span><br><span class="line">        subject=<span class="keyword">new</span> <span class="built_in">SubjectProxy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        subject-&gt;<span class="built_in">process</span>();</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>”增加一层间接层“是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中
,
直接使用某些对象会带来很多问题，作为间接层的proxy对象便是解决这一问题的常用手段
。</li>
<li>具体proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做proxy。</li>
<li>Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。</li>
</ul>
<p><img src="15.png"></p>
<h4 id="adapter-适配器">Adapter 适配器</h4>
<p><strong>动机（Motivation）：</strong>在软件系统中，由于应用环境的变化，常常需要将”一些<strong>现存的对象</strong>“放在<strong>新的环境中应用</strong>，但是新环境要求的接口是这些现存对象所<strong>不满足</strong>的。如何应对这种”迁移的变化“？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？</p>
<p><strong>模式定义</strong></p>
<p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标接口（新接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ITarget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留接口（老接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IAdaptee</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">bar</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldClass</span>: <span class="keyword">public</span> IAdaptee&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>: <span class="keyword">public</span> ITarget&#123; <span class="comment">//继承新接口</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    IAdaptee* pAdaptee;<span class="comment">//组合老接口</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adapter</span>(IAdaptee* pAdaptee)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAdaptee=pAdaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123; <span class="comment">//调用老接口</span></span><br><span class="line">        <span class="type">int</span> data=pAdaptee-&gt;<span class="built_in">bar</span>();</span><br><span class="line">        pAdaptee-&gt;<span class="built_in">foo</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>: <span class="keyword">public</span> ITarget, <span class="keyword">protected</span> OldClass&#123; <span class="comment">//多继承</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IAdaptee* pAdaptee=<span class="keyword">new</span> <span class="built_in">OldClass</span>();</span><br><span class="line">    ITarget* pTarget=<span class="keyword">new</span> <span class="built_in">Adapter</span>(pAdaptee);</span><br><span class="line">    pTarget-&gt;<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span>&#123;</span><br><span class="line">    deqeue container;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line">    deqeue container;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>Adapter模式主要应用于”希望复用一些现存的类，但是接口又与复用环境要求不一致“的情况，在遗留代码复用、类库迁移等方面非常有用。</li>
<li>GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。<strong>但类适配器采用”多继承“的实现方式，一般不推荐使用。对象适配器采用”对象组合“方式，更符合松耦合精神。</strong></li>
<li>Adapter模式可以实现得非常灵活，不必拘泥于Gof23中定义的两种结构。例如，完全可以将Adapter模式中的”现存对象“作为新的接口方法参数，来达到适配的目的。</li>
</ul>
<p><img src="16.png"></p>
<h4 id="mediater-中介者">Mediater 中介者</h4>
<p><strong>动机（Motivation）：</strong>在软件构建过程中，经常会出现<strong>多个对象互相关联交互</strong>的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化；在这种情况下,我们可使用一个<strong>中介对象、来管理对象间的关联关系</strong>，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。</p>
<p><strong>模式定义</strong></p>
<p>用一个<strong>中介对象</strong>来<strong>封装一系列的对象交互</strong>（封装变化），中介者使各对象<strong>不需要显式的相互引用</strong>（编译时依赖-&gt;运行时依赖），从而使其耦合松散（管理变化），而且可以独立地变它们之间的交互。</p>
<p><img src="17-1.png"></p>
<p><strong>总结</strong></p>
<ul>
<li>将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变”多个对象相互关联“为”多个对象和一个中介者关联“，简化了系统的维护，抵御了可能的变化。</li>
<li>随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分解处理。</li>
<li>Facade模式是解耦系统间（单向）的对象关联关系Mediator模式是解耦系统内各个对象之间（双向）的关联关系。</li>
</ul>
<p><img src="17.png"></p>
<h3 id="状态变化模式">状态变化模式</h3>
<p>在组建构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效管理？同时又维持高层模块的稳定？“状态变化“模式为这一问题提供了一种解决方案。</p>
<p><strong>典型模式：</strong>State、Memento</p>
<h4 id="state-状态模式">State 状态模式</h4>
<blockquote>
<p><strong>State与Strategy的区别在于状态之间的联系，在State模式中，状态与状态之间有稳定的次序关联，每一种状态执行完毕后都将切换至下一种固定的状态。而在Strategy模式中，仅仅是将不同的case抽象出来，将接口与细节拆分。</strong></p>
</blockquote>
<p><strong>动机（Motivation）：</strong>在软件构建过程中，<strong>某些对象的状态如果改变，其行为也会随之而发生变化</strong>，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。如何在运行时根据对象的状态来透明地更改对象的行为？而不会为对象操作和状态转化之间引入耦合？</p>
<p><strong>问题场景：</strong>现有一个网络应用，该应用会根据网络的状态进行调整，例如有三种状态分别是打开、关闭和连接，要根据不同的状态执行不同的操作，而使用<code>if-else</code>违反开闭原则，当需求更改时必须更改源码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">NetworkState</span></span><br><span class="line">&#123;</span><br><span class="line">    Network_Open,</span><br><span class="line">    Network_Close,</span><br><span class="line">    Network_Connect,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkProcessor</span>&#123;</span><br><span class="line">    NetworkState state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == Network_Open)&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            state = Network_Close;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Close)&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            state = Network_Connect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Connect)&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            state = Network_Open;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == Network_Open)&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            state = Network_Connect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Close)&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            state = Network_Open;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Connect)&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            state = Network_Close;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>模式定义</strong></p>
<p>允许一个对象在其内部状态改变时改变它的行为，从而使对象看起来似乎被动修改了行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkState</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NetworkState* pNext;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NetworkState</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenState</span> :<span class="keyword">public</span> NetworkState&#123;</span><br><span class="line">    <span class="type">static</span> NetworkState* m_instance; <span class="comment">// Singleton</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> NetworkState* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">OpenState</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pNext = CloseState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pNext = ConnectState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pNext = OpenState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectState</span>:<span class="keyword">public</span> NetworkState &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CloseState</span>:<span class="keyword">public</span> NetworkState &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkProcessor</span>&#123;</span><br><span class="line">    NetworkState* pState; <span class="comment">// 例如用 OpenState 对象初始化该指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NetworkProcessor</span>(NetworkState* pState)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pState = pState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation1</span>(); <span class="comment">// 内部状态的改变，OpenState对象内部的pNext指针指向了CloseState对象，但这不会影响NetworkProcessor的pState</span></span><br><span class="line">        pState = pState-&gt;pNext; <span class="comment">// 将OpenState的pNext新对象赋给NetworkProcessor的pState指针</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation2</span>();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation3</span>();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。</li>
<li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。</li>
<li>如果State对象没有实例变量，那么各个上下为可以共享同一个State对象，从而节省对象开销。</li>
</ul>
<p><img src="18.png"></p>
<h4 id="memento-备忘录模式">Memento 备忘录模式</h4>
<p><strong>动机（Motivation）：</strong>在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，<strong>要求程序能够回溯到对象之前处于某个点时的状态</strong>。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。如何实现对象状态的良好保护与恢复？但<strong>同时又不会因此而破坏对象本身的封装性。</strong></p>
<p><strong>模式定义</strong></p>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span></span><br><span class="line">&#123;</span><br><span class="line">    string state;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(<span class="type">const</span> string &amp; s) : <span class="built_in">state</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(<span class="type">const</span> string &amp; s)</span> </span>&#123; state = s; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原发器（原始对象）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> </span><br><span class="line">&#123;</span><br><span class="line">    string state;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Originator</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">// 捕获对象状态，并存储到备忘录（该对象的状态是state的字符串值）</span></span><br><span class="line">    <span class="function">Memento <span class="title">createMomento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">Memento <span class="title">m</span><span class="params">(state)</span></span>; <span class="comment">// 当前对象的内存状态snapshot（例如base64序列化存储）</span></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMomento</span><span class="params">(<span class="type">const</span> Memento &amp; m)</span> </span>&#123;</span><br><span class="line">        state = m.<span class="built_in">getState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Originator orginator;</span><br><span class="line">    <span class="comment">//捕获对象状态，存储到备忘录</span></span><br><span class="line">    Memento mem = orginator.<span class="built_in">createMomento</span>();</span><br><span class="line">    <span class="comment">//... 改变orginator状态</span></span><br><span class="line">    <span class="comment">//从备忘录中恢复</span></span><br><span class="line">    orginator.<span class="built_in">setMomento</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器状态。</li>
<li>Memento模式的核心是信息隐藏，及Originator需要向外界隐藏信息，保持其封装性。但同时又需要将状态保持到外界。</li>
<li>由于现代语言运行时（如C#、Java）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来实现Memento模式。</li>
</ul>
<p><img src="19.png"></p>
<h3 id="数据结构模式">数据结构模式</h3>
<p>常常有<strong>一些组件在内部具有特定的数据结构</strong>，如果让客户程序依赖这些特定数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</p>
<p><strong>典型模式：</strong>Composite、Iterator、Chain of
Responsibility</p>
<h4 id="composite-组合模式">Composite 组合模式</h4>
<blockquote>
<p><strong>系统可拆分为具有明显上下级与执行顺序的小组件时，可以使用该模式</strong></p>
</blockquote>
<p><strong>动机（Motivation）：</strong>软件在某些情况下，客户代码过多地依赖于<strong>对象容器复杂的内部实现结构</strong>，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。如何<strong>将”客户代码与复杂的对象容器结构“解耦</strong>？让对象容器自己来实现自身的复杂结构，从而使客户代码就像处理简单对象一样来处理复杂的对象容器？</p>
<p><strong>模式定义</strong></p>
<p>将对象组合成<strong>树形结构</strong>以表示”部分-整体“的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性（稳定）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component&#123;</span><br><span class="line">    string name;</span><br><span class="line">    list&lt;Component*&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="type">const</span> string &amp; s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.<span class="built_in">remove</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. process current node</span></span><br><span class="line">        <span class="comment">//2. process leaf nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : elements)</span><br><span class="line">            e-&gt;<span class="built_in">process</span>(); <span class="comment">//多态调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叶子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaf</span>(string s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//process current node</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Invoke</span><span class="params">(Component &amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.<span class="built_in">process</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Composite <span class="title">root</span><span class="params">(<span class="string">&quot;root&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode1</span><span class="params">(<span class="string">&quot;treeNode1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode2</span><span class="params">(<span class="string">&quot;treeNode2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode3</span><span class="params">(<span class="string">&quot;treeNode3&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode4</span><span class="params">(<span class="string">&quot;treeNode4&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat1</span><span class="params">(<span class="string">&quot;left1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat2</span><span class="params">(<span class="string">&quot;left2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    root.<span class="built_in">add</span>(&amp;treeNode1);</span><br><span class="line">    treeNode1.<span class="built_in">add</span>(&amp;treeNode2);</span><br><span class="line">    treeNode2.<span class="built_in">add</span>(&amp;leaf1);</span><br><span class="line"></span><br><span class="line">    root.<span class="built_in">add</span>(&amp;treeNode3);</span><br><span class="line">    treeNode3.<span class="built_in">add</span>(&amp;treeNode4);</span><br><span class="line">    treeNode4.<span class="built_in">add</span>(&amp;leaf2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Invoke</span>(root);</span><br><span class="line">    <span class="built_in">Invoke</span>(leaf2);</span><br><span class="line">    <span class="built_in">Invoke</span>(treeNode3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>Composite模式采用树形结构来实现普遍存在的对象容器，从而<strong>将”一对多“的关系转化为”一对一“的关系</strong>（“一对多”指的是process内部需要判断各种各样的case），使得客户代码可以一致地（复用）处理对象和对象容器，无需关心处理的是单个对象还是组合的对象容器。</li>
<li>”将客户代码与复杂的对象容器结构解耦“是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口，而非对象容器的内部实现结构，发生依赖，从而更能“应对变化”。</li>
<li>Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li>
<li><img src="20.png"></li>
</ul>
<h4 id="iterator-迭代器模式">Iterator 迭代器模式</h4>
<blockquote>
<p><strong>由于基于面向对象实现，这种（利用虚数函数）间接迭代器在当今的C++中已过时，以泛型、模板实现的迭代器能达到更好的性能</strong></p>
</blockquote>
<p><strong>动机（Motivation）：</strong>在软件构建过程中，<strong>集合对象</strong>内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种<strong>“透明遍历“</strong>也为<strong>“同一种算法在多种集合对象上进行操作“</strong>提供了可能。</p>
<p><strong>模式定义</strong></p>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">first</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isDone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">current</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCollection</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">GetIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollectionIterator</span> : <span class="keyword">public</span> Iterator&lt;T&gt;&#123;</span><br><span class="line">    MyCollection&lt;T&gt; mc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CollectionIterator</span>(<span class="type">const</span> MyCollection&lt;T&gt; &amp; c): <span class="built_in">mc</span>(c)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isDone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">current</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyAlgorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyCollection&lt;<span class="type">int</span>&gt; mc;</span><br><span class="line">    Iterator&lt;<span class="type">int</span>&gt; iter= mc.<span class="built_in">GetIterator</span>();</span><br><span class="line">    <span class="keyword">for</span> (iter.<span class="built_in">first</span>(); !iter.<span class="built_in">isDone</span>(); iter.<span class="built_in">next</span>())&#123;</span><br><span class="line">        cout &lt;&lt; iter.<span class="built_in">current</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示</li>
<li>迭代多态：力道历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li>
<li>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题</li>
</ul>
<p><img src="21.png"></p>
<h4 id="chain-of-responsibility-职责链模式">Chain of Responsibility
职责链模式</h4>
<blockquote>
<p><strong>过时</strong></p>
</blockquote>
<p><strong>动机（Motivation）：</strong>在软件构建过程中，<strong>一个请求可能被多个对象处理</strong>，但是每个请求在运行时只能有一个接受者，如果显式指定，将必不可少地带来请求发送者与接受者的紧糖合。<strong>如何使请求的发送者不需要指定具体的接受者？</strong>让请求的接受者自己在运行时决定来处理请求，从而使两者解耦</p>
<p><strong>模式定义</strong></p>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。<strong>将这些对象连成一条链（链表），并沿着这条链传递请求</strong>，直到有一个对象处理它为止.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">RequestType</span></span><br><span class="line">&#123;</span><br><span class="line">    REQ_HANDLER1,</span><br><span class="line">    REQ_HANDLER2,</span><br><span class="line">    REQ_HANDLER3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Request</span></span><br><span class="line">&#123;</span><br><span class="line">    string description;</span><br><span class="line">    RequestType reqType;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Request</span>(<span class="type">const</span> string &amp; desc, RequestType type) : <span class="built_in">description</span>(desc), <span class="built_in">reqType</span>(type) &#123;&#125;</span><br><span class="line">    <span class="function">RequestType <span class="title">getReqType</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> reqType; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">getDescription</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> description; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChainHandler</span>&#123;</span><br><span class="line">    ChainHandler *nextChain;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendReqestToNextHandler</span><span class="params">(<span class="type">const</span> Request &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextChain != <span class="literal">nullptr</span>)</span><br><span class="line">        nextChain-&gt;<span class="built_in">handle</span>(req);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="type">const</span> Request &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ChainHandler</span>() &#123; nextChain = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNextChain</span><span class="params">(ChainHandler *next)</span> </span>&#123; nextChain = next; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">const</span> Request &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canHandleRequest</span>(req))</span><br><span class="line">            <span class="built_in">processRequest</span>(req);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">sendReqestToNextHandler</span>(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler1</span> : <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="type">const</span> Request &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler1 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler2</span> : <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="type">const</span> Request &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler2 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler3</span> : <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="type">const</span> Request &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Request &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler3 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Handler1 h1;</span><br><span class="line">    Handler2 h2;</span><br><span class="line">    Handler3 h3;</span><br><span class="line">    h1.<span class="built_in">setNextChain</span>(&amp;h2);</span><br><span class="line">    h2.<span class="built_in">setNextChain</span>(&amp;h3);</span><br><span class="line"></span><br><span class="line">    <span class="function">Request <span class="title">req</span><span class="params">(<span class="string">&quot;process task ... &quot;</span>, RequestType::REQ_HANDLER3)</span></span>;</span><br><span class="line">    h1.<span class="built_in">handle</span>(req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>Chain of Responsibility
模式的应用场合在于<strong>”一个请求可能有多个接受者，但是最后真正的接受者只有一个“</strong>，这时候请求发送者与接受者的耦合有可能出现”变化脆弱“的症状，职责链的目的就是将二者解耦，从而更好地应对变化。</li>
<li>应用了Chain of
Responsibility模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。</li>
<li>如果请求传递到职责链的未尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li>
</ul>
<p><img src="22.png"></p>
<h3 id="行为变化模式">行为变化模式</h3>
<p>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。”行为变化“模式<strong>将组件的行为和组件本身进行解耦，从而支持组件行为的变化</strong>，实现两者之间的松耦合。</p>
<p><strong>典型模式：</strong>Command、Visitor</p>
<h4 id="command-命令模式">Command 命令模式</h4>
<p><strong>动机（Motivation）：</strong>在软件构建过程中，行为请求者与行为实现者通常呈现一种“紧耦合”。但在某些场合一一比如需要对行为进行“记录、撤销（undo）/重做（redo）、事务”等处理,，种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将请求者与实现者解耦？将一组行为抽象成对象，可以实现二者的松耦合。</p>
<p><strong>模式定义</strong></p>
<p>将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand1</span> : <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    string arg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand1</span>(<span class="type">const</span> string &amp; a) : <span class="built_in">arg</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;#1 process...&quot;</span>&lt;&lt;arg&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand2</span> : <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    string arg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand2</span>(<span class="type">const</span> string &amp; a) : <span class="built_in">arg</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;#2 process...&quot;</span>&lt;&lt;arg&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacroCommand</span> : <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;Command*&gt; commands;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCommand</span><span class="params">(Command *c)</span> </span>&#123; commands.<span class="built_in">push_back</span>(c); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : commands)</span><br><span class="line">        &#123;</span><br><span class="line">            c-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ConcreteCommand1 <span class="title">command1</span><span class="params">(<span class="string">&quot;Arg ###&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ConcreteCommand2 <span class="title">command2</span><span class="params">(<span class="string">&quot;Arg $$$&quot;</span>)</span></span>;</span><br><span class="line">    MacroCommand macro;</span><br><span class="line">    macro.<span class="built_in">addCommand</span>(&amp;command1);</span><br><span class="line">    macro.<span class="built_in">addCommand</span>(&amp;command2);</span><br><span class="line">    macro.<span class="built_in">execute</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>Command模式的根本目的在于将“行为请求者”与“行为实现者”解耦，在面向对象语言中，常见的实现手段是“将行为抽象为对象”。</li>
<li>实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式，可以将多个命令封装为一个复合命令MacroCommand。</li>
<li>Command模式与C++中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command以面向对象中的“接口-实现”来定义行为接口规范，更严格（例如限制了函数名、参数类型、返回值），但有性能损失（运行时动态绑定）；C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高（编译时静态绑定）。</li>
</ul>
<p><img src="23.png"></p>
<h4 id="visitor-访问器模式">Visitor 访问器模式</h4>
<p><strong>动机（Motivation）：</strong>在软件构建过程中，由于需求的改变，<strong>某些类层次结构中常常需要增加新的行为（方法）</strong>，如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，而避免上述问题?</p>
<p><strong>模式定义</strong></p>
<p>表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> </span>= <span class="number">0</span>; <span class="comment">//第一次多态辨析，调用具体ElementX子类的accept</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Element</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementA</span> : <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor-&gt;<span class="built_in">visitElementA</span>(<span class="keyword">this</span>); <span class="comment">//第二次多态辨析，调用具体visitor类型的visitElementX</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementB</span> : <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor-&gt;<span class="built_in">visitElementB</span>(<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visitElementA</span><span class="params">(ElementA* element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visitElementB</span><span class="params">(ElementB* element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Visitor</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//==================================</span></span><br><span class="line"><span class="comment">//扩展1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor1</span> : <span class="keyword">public</span> Visitor&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitElementA</span><span class="params">(ElementA* element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Visitor1 is processing ElementA&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitElementB</span><span class="params">(ElementB* element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Visitor1 is processing ElementB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor2</span> : <span class="keyword">public</span> Visitor&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitElementA</span><span class="params">(ElementA* element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Visitor2 is processing ElementA&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitElementB</span><span class="params">(ElementB* element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Visitor2 is processing ElementB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Element* element = <span class="keyword">new</span> <span class="built_in">ElementA</span>();</span><br><span class="line">    Visitor* visitor = <span class="keyword">new</span> <span class="built_in">Visitor2</span>();</span><br><span class="line">    element-&gt;<span class="built_in">accept</span>(visitor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>Visitor模式通过所谓的双重分发（double
dispatch）来实现在<strong>不更改（不添加新的编译时操作）Element类层次结构（Element、ElementA、ElementB继承结构）的前提下</strong>，在运行时透明地为类层次结构上的<strong>各个类</strong>动态添加新的操作（支持变化）。</li>
<li>所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：第一个为accept方法的多态辨析；第二个为visitElementX方法的多态辨析。</li>
<li>Visitor模式的<strong>最大缺点</strong>在于<strong>扩展类层次结构（增添新的Element子类）会导致Visitor类的改变</strong>（因为Visitor通过接受一个Element抽象类的方式访问Element子类，在Visitor中需要实现针对每一个Element子类的新方法，这就要求Element子类稳定）。因此Visitor模式
<strong>适用于“Element类层次结构稳定，而其中的操作却经常面临频繁改动“</strong>的情况。</li>
</ul>
<p><img src="24.png"></p>
<h3 id="领域规则模式">领域规则模式</h3>
<p>在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。</p>
<p><strong>典型模式：</strong>Interpreter</p>
<h4 id="interpreter-解析器模式">Interpreter 解析器模式</h4>
<p><strong>动机（Motivation）：</strong>在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这些句子，从而达到解决问题的目的。</p>
<p><strong>问题场景：</strong>要实现一个支持字符串输入的加减运算器，可将表达式抽象为由”符号表达式“和”变量表达式“组合成的表达式树结构。</p>
<p><img src="25-1.png"></p>
<p><strong>模式定义</strong></p>
<p>给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">interpreter</span><span class="params">(map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; var)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Expression</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VarExpression</span>: <span class="keyword">public</span> Expression &#123;</span><br><span class="line">    <span class="type">char</span> key;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VarExpression</span>(<span class="type">const</span> <span class="type">char</span>&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpreter</span><span class="params">(map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; var)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//符号表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SymbolExpression</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 运算符左右两个参数</span></span><br><span class="line">    Expression* left;</span><br><span class="line">    Expression* right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SymbolExpression</span>(Expression* left,  Expression* right):</span><br><span class="line">      <span class="built_in">left</span>(left),<span class="built_in">right</span>(right)&#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法运算</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddExpression</span> : <span class="keyword">public</span> SymbolExpression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AddExpression</span>(Expression* left, Expression* right):</span><br><span class="line">      <span class="built_in">SymbolExpression</span>(left,right)&#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpreter</span><span class="params">(map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; var)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;<span class="built_in">interpreter</span>(var) + right-&gt;<span class="built_in">interpreter</span>(var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法运算</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubExpression</span> : <span class="keyword">public</span> SymbolExpression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SubExpression</span>(Expression* left, Expression* right):</span><br><span class="line">    <span class="built_in">SymbolExpression</span>(left,right)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpreter</span><span class="params">(map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; var)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;<span class="built_in">interpreter</span>(var) - right-&gt;<span class="built_in">interpreter</span>(var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建表达式树</span></span><br><span class="line"><span class="function">Expression*  <span class="title">analyse</span><span class="params">(string expStr)</span> </span>&#123;</span><br><span class="line">    stack&lt;Expression*&gt; expStack;</span><br><span class="line">    Expression* left = <span class="literal">nullptr</span>;</span><br><span class="line">    Expression* right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;expStr.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(expStr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="comment">// 加法运算</span></span><br><span class="line">                left = expStack.<span class="built_in">top</span>();</span><br><span class="line">                right = <span class="keyword">new</span> <span class="built_in">VarExpression</span>(expStr[++i]);</span><br><span class="line">                expStack.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">AddExpression</span>(left, right));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="comment">// 减法运算</span></span><br><span class="line">                left = expStack.<span class="built_in">top</span>();</span><br><span class="line">                right = <span class="keyword">new</span> <span class="built_in">VarExpression</span>(expStr[++i]);</span><br><span class="line">                expStack.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">SubExpression</span>(left, right));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 变量表达式</span></span><br><span class="line">                expStack.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">VarExpression</span>(expStr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Expression* expression = expStack.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(Expression* expression)</span></span>&#123;</span><br><span class="line">    <span class="comment">//由底向上后序释放表达式树的节点内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    string expStr = <span class="string">&quot;a+b-c+d-e&quot;</span>;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; var;</span><br><span class="line">    var.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">5</span>));</span><br><span class="line">    var.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>));</span><br><span class="line">    var.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>));</span><br><span class="line">    var.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;d&#x27;</span>,<span class="number">6</span>));</span><br><span class="line">    var.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;e&#x27;</span>,<span class="number">10</span>));</span><br><span class="line">    <span class="comment">// analyse最终栈顶元素为SymbolExpression（包含left=a+b-c+d和right=e，具体类型为SubExpression）</span></span><br><span class="line">    Expression* expression= <span class="built_in">analyse</span>(expStr);</span><br><span class="line">    <span class="comment">// 执行interpreter，从栈顶SubExpression的interpreter开始执行，递归调用left与right的interpreter，返回最终计算值</span></span><br><span class="line">    <span class="type">int</span> result=expression-&gt;<span class="built_in">interpreter</span>(var);</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">release</span>(expression);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>Interpreter模式的应用场合是Interpreter模式应用中的难点，只有满足”业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题“才适合使用Interpreter模式。</li>
<li>使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地”扩展“文法。</li>
<li>Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。</li>
</ul>
<p><img src="25.png"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/archives/fd90faa3/" rel="prev" title="Git 简记">
      <i class="fa fa-chevron-left"></i> Git 简记
    </a></div>
      <div class="post-nav-item">
    <a href="/archives/74088985/" rel="next" title="C语言实现一个支持任意类型的动态数组">
      C语言实现一个支持任意类型的动态数组 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c-design-patterns"><span class="nav-number">1.</span> <span class="nav-text">C++ Design Patterns</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2"><span class="nav-number">1.1.</span> <span class="nav-text">设计模式初探</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#is-a%E4%B8%8Ehas-a"><span class="nav-number">1.2.</span> <span class="nav-text">Is-a与Has-a</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.3.</span> <span class="nav-text">面向对象设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.3.1.</span> <span class="nav-text">八大设计原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">23种设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="nav-number">1.4.1.</span> <span class="nav-text">模式分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.2.</span> <span class="nav-text">组件协作模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#template-method-%E6%A8%A1%E6%9D%BF%E6%A0%B7%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Template Method 模板&#x2F;样板方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#strategy-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">Strategy 策略模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#observer-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">Observer 观察者模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.3.</span> <span class="nav-text">单一职责模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#decorator-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">Decorator 装饰模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bridge-%E6%A1%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">Bridge 桥模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.4.</span> <span class="nav-text">对象创建模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#factory-method-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">Factory Method 工厂方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#abstract-factory-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">Abstract Factory 抽象工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prototype-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">Prototype 原型模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#builder-%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">Builder 构建器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.5.</span> <span class="nav-text">对象性能模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#singleton-%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">Singleton 单件模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flyweight-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">Flyweight 享元模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.6.</span> <span class="nav-text">接口隔离模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#facade-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">Facade 门面模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#proxy-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">Proxy 代理模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#adapter-%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">1.4.6.3.</span> <span class="nav-text">Adapter 适配器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mediater-%E4%B8%AD%E4%BB%8B%E8%80%85"><span class="nav-number">1.4.6.4.</span> <span class="nav-text">Mediater 中介者</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.7.</span> <span class="nav-text">状态变化模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#state-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">State 状态模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memento-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.7.2.</span> <span class="nav-text">Memento 备忘录模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.8.</span> <span class="nav-text">数据结构模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#composite-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">Composite 组合模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">Iterator 迭代器模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#chain-of-responsibility-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.8.3.</span> <span class="nav-text">Chain of Responsibility
职责链模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.9.</span> <span class="nav-text">行为变化模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#command-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.9.1.</span> <span class="nav-text">Command 命令模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#visitor-%E8%AE%BF%E9%97%AE%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.9.2.</span> <span class="nav-text">Visitor 访问器模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%86%E5%9F%9F%E8%A7%84%E5%88%99%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.10.</span> <span class="nav-text">领域规则模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#interpreter-%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.10.1.</span> <span class="nav-text">Interpreter 解析器模式</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lightshaker</p>
  <div class="site-description" itemprop="description">It is our choices that show what we truly are, far more than our abilities.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lightshaker</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'j3EqSOqSYjPS414YtmiadN5W-gzGzoHsz',
      appKey     : '429Gb8wTQv1P09Fjbeyd9k5w',
      placeholder: "Hello",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
