<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lightshaker.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文是个人初学C++基础部分的备忘笔记  变量 常见整数类型：char，short，int，long，long long(long int)，对应大小：1, 2, 4, 4, 8（byte） 定义float类型变量时，编译器可能还是会隐式地设置为double类型，所以最好在数值末尾加上“f”或“F”，如float a &#x3D; 3.2f 函数  定义一个明确返回值类型但是函数体内并没有返回值的函数，在">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 基础笔记">
<meta property="og:url" content="https://lightshaker.cn/archives/11d9/index.html">
<meta property="og:site_name" content="Journey">
<meta property="og:description" content="本文是个人初学C++基础部分的备忘笔记  变量 常见整数类型：char，short，int，long，long long(long int)，对应大小：1, 2, 4, 4, 8（byte） 定义float类型变量时，编译器可能还是会隐式地设置为double类型，所以最好在数值末尾加上“f”或“F”，如float a &#x3D; 3.2f 函数  定义一个明确返回值类型但是函数体内并没有返回值的函数，在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/unicode.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/initialize.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/initialize2.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/virtual_destructor.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/virtual_destructor2.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/copy_and_move.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/derived1.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/derived2.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/clock_normal.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/clock_error.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/clock_debug.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/clock_new.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/clock_unique.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/reload%20debug.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/overload.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/struct.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/union.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/union_output.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/static_cast_2.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/static_cast_1.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/static_cast_4.png">
<meta property="og:image" content="https://lightshaker.cn/archives/11d9/static_cast_3.png">
<meta property="article:published_time" content="2020-04-12T08:17:54.000Z">
<meta property="article:modified_time" content="2023-06-16T07:32:44.500Z">
<meta property="article:author" content="Lightshaker">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lightshaker.cn/archives/11d9/unicode.png">

<link rel="canonical" href="https://lightshaker.cn/archives/11d9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ 基础笔记 | Journey</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Journey</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lightshaker.cn/archives/11d9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lightshaker">
      <meta itemprop="description" content="It is our choices that show what we truly are, far more than our abilities.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Journey">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 基础笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-12 16:17:54" itemprop="dateCreated datePublished" datetime="2020-04-12T16:17:54+08:00">2020-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-16 15:32:44" itemprop="dateModified" datetime="2023-06-16T15:32:44+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          
            <span id="/archives/11d9/" class="post-meta-item leancloud_visitors" data-flag-title="C++ 基础笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/archives/11d9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/archives/11d9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>本文是个人初学C++基础部分的备忘笔记</p>
</blockquote>
<h2 id="变量">变量</h2>
<p>常见整数类型：<code>char</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>long long(long int)</code>，对应大小：1,
2, 4, 4, 8（byte）</p>
<p>定义float类型变量时，编译器可能还是会隐式地设置为double类型，所以最好在数值末尾加上“f”或“F”，如<code>float a = 3.2f</code></p>
<h2 id="函数">函数</h2>
<blockquote>
<p>定义一个明确返回值类型但是函数体内并没有返回值的函数，在外部不调用该函数返回值的情况下，使用Release模式编译能通过，使用Debug模式编译会报错。（“Debug”意义非常鲜明了
）</p>
</blockquote>
<h3 id="从函数中创建并返回多个数据">从函数中创建并返回多个数据</h3>
<h4 id="数据类型相同">数据类型相同</h4>
<p>返回数组或std:::vector或std::array，返回值均可使用索引值与操作符
<code>[]</code> 获取元素；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回数组</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">GetRawArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* temp = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">GetVector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回array</span></span><br><span class="line"><span class="function">std::array&lt;std::string, 2&gt; <span class="title">GetArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::array&lt;std::string, <span class="number">2</span>&gt; &#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="数据类型不同">数据类型不同</h4>
<p><strong>方法一：</strong>使用 <code>std::make_pair()</code>
打包并返回 <code>std::tuple</code>；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">float</span>&gt; <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">make_pair</span>&lt;<span class="type">int</span>, <span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::tuple&lt;<span class="type">int</span>, <span class="type">float</span>&gt; t = <span class="built_in">Get</span>();</span><br><span class="line">	<span class="type">int</span> a = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t);</span><br><span class="line">	<span class="type">float</span> b = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t);</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：</strong>将数据打包成结构体再返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">float</span> y;</span><br><span class="line">	std::string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Data <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;name&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Data d = <span class="built_in">Get</span>();</span><br><span class="line">	std::cout &lt;&lt; d.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d.y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d.s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数接收并返回多个数据">函数接收并返回多个数据</h3>
<p>以左值引用 <code>&amp;</code>
的方式接收参数，并在函数内进行修改，返回类型置
<code>void</code>即可，不受类型影响，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Modify</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">float</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="number">10</span>;</span><br><span class="line">	y = <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="type">float</span> b = <span class="number">6.7</span>;</span><br><span class="line">	<span class="built_in">Modify</span>(a, b);</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="头文件">头文件</h2>
<h3 id="功能简述">功能简述</h3>
<p>头文件一般存放函数声明、公共宏等多个文件同时需要使用的内容，在不使用头文件的情况下，我们需要把这些声明和宏拷贝到每一个调用到这些东西的文件中去，真这么干就很可能在维护时出现各种各样的问题。所以预处理指令<code>#include</code>的用处就在这种时候体现，它的功能就是直白的复制粘贴，借助头文件把公共的声明和宏集中起来管理。</p>
<h3 id="引号与尖括号的区别">引号与尖括号的区别</h3>
<p>配置完开发环境后，系统中就会存在一个存放各种自带库头文件的目录，如果需要引用的头文件属于这些库，比如<code>cstdlib</code>，<code>iostream</code>等标准库，使用方括号与引号均可。</p>
<p>当需要引用的头文件是工程内自定义的，或是网上下载下来的第三方库时，如果把整个库的内容都放在工程中，在引用时只能使用引号，指明该头文件存放于可能的相对路径中。如果把库安装在系统默认路径下，可使用方括号。但是如果库的安装位置不是系统默认路径，并且使用方括号引用，那么一定是找不到的。</p>
<h3 id="易错点">易错点</h3>
<p>为了避免一个头文件被多次<code>#include</code>到<strong>同一个翻译单元</strong>里，比如同一个工程中有<code>log.h</code>和<code>add.h</code>，其中<code>log.h</code>文件中包含了<code>add.h</code>，但是在代码量比较大的时候，我们很难随时严格地理清楚到各个文件之间的<code>#include</code>关系，可能就会出现在<code>main.cpp</code>中既<code>#include</code>了<code>log.h</code>又<code>#include</code>了<code>add.h</code>的情况，此时<code>add.h</code>无形中就同时被<code>main.cpp</code>包含了两次，这样链接时会报重复的错，所以需要一些手段来避免这样的错误。</p>
<p>常见的手段一般有两种：</p>
<ul>
<li>在头文件内的起始位置加上预处理指令
<code>#pragma once</code>，指明该头文件只能被同一个翻译单元<code>#include</code>一次</li>
<li>使用控制宏<code>#ifndef - #define - #endif</code>指令囊括整个头文件，也可以达到同样的目的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ADD_H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//_ADD_H</span></span></span><br></pre></td></tr></table></figure>
<h2 id="指针">指针</h2>
<h3 id="概述">概述</h3>
<p>一个指针是一个<strong>在内存中</strong>存放<strong>地址</strong>的<strong>整数</strong>，指针的<strong>类型</strong>取决于在那个地址中的<strong>数据</strong>类型；</p>
<p>计算机内存地址是<strong>一维线性</strong>、<strong>连续</strong>的，可想象成一条非常长的街道，路边是等间距的房子，每个房子就是一个内存地址。房子的数量一定是整数，所以房子的编号也是整数，即地址是个整数；但这个整数的位数（bit数）取决于使用的系统的位数，32位系统一个地址码就是32位，即32bit或4byte，同理64位系统一个地址码位64位或8byte。一个内存地址的储存空间是一个储存单元，一般以8位2进制即2位16进制作为一个储存单元，也就是256的大小；一个存储器的容量用字节来衡量，容量大小为储存单元的个数；</p>
<h3 id="使用">使用</h3>
<p><code>void* ptr = 0</code>
：指针类型任意，指向为0的内存地址，因为0是无效的内存地址，所以该指针是空指针，相当于<code>NULL</code>或<code>nullptr</code>（c++17）
;</p>
<p><code>*ptr = 10</code>：利用<code>*</code>对指针进行解引用，就是对指针地址的内存进行操作；</p>
<p><code>char* buffer = new char[8]</code>：在堆（heap）上申请了8个char大小的内存空间，并返回一个指向起始地址的指针；</p>
<p><code>memset(buffer, 0, 8)</code>：向指针buffer的内存区域填充8个字节的0；</p>
<p><code>delete[] buffer</code>：释放<code>new</code>在heap上申请的内存空间；</p>
<p><code>buffer = nullptr</code>：重新将buffer指针地址置空，即回收指针，避免野指针的出现；</p>
<p><code>char** secondPtr = &amp;buffer</code>：二级指针，该指针地址的<strong>值</strong>为指针<code>buffer</code>的地址；</p>
<p><strong>ps：</strong>在一行内定义多个指针变量需要注意，每个变量名之前都要加上<code>*</code>表示指针变量，如<code>int *a, *b;</code>，否则<code>int *a, b</code>
只定义指针变量a，而b则是普通的int类型变量；</p>
<h3 id="引用">引用</h3>
<p>引用<code>&amp;</code>是指针的一种拓展，是用来引用<strong>现有</strong>变量的一种手段，具体的方式可以理解为<strong>传递指针并进行解引用</strong>，与指针最大的区别就是只能引用已经存在的变量，不能凭空创造。</p>
<p>一个变量不能同时创建多个引用，也就是说如果有<code>int a = 5; int b = 8;</code>，现在定义<code>int&amp; ref = a</code>，就不能再令<code>ref = b</code>，此时会创建一种<code>a = 5 = b = 8</code>的假命题。因此如果想改变引用的对象，还是需要以指针的形式操作，如<code>int *ref = &amp;a; ref = &amp;b</code>；</p>
<p>在使用有参函数的时候，如果以<code>Function(int a, int b)</code>的形式传参，会在内存中<strong>新</strong>分配两个int大小的空间，对a与b分别进行一次<strong>深拷贝</strong>，即分配了新的空间与地址，这样一来不论在函数中对拷贝的a与b进行怎样的修改，都<strong>不会影响</strong>到原来的a和b的值。在参数占用资源较少的情况下可以使用，如本例中的两个int，但在占用资源多的情况下，比如用一个STL的实例进行全拷贝的值传递是<strong>很浪费</strong>的。因此需要以引用的形式传参
<code>Function(int&amp; a, int&amp;b)</code>
节省资源。此时对a与b进行的是<strong>浅拷贝</strong>，也就是不会分配新的空间与地址，将a与b所在的地址交给函数管理，在函数中进行修改<strong>会直接影响</strong>原来的a与b的值。</p>
<p>由于以引用的形式传递参数能够有效地节省资源，所以建议在不需要修改参数值时，以<code>const type&amp; var</code>的形式传递参数。</p>
<h3 id="指针与数组">指针与数组</h3>
<blockquote>
<p><strong>字符指针和字符数组、字符串相关问题不在此标题下讨论</strong></p>
</blockquote>
<h4 id="二者的简单关系">二者的简单关系</h4>
<p>数组名可以理解为指向数组中第一个元素（数组在内存中的起始地址）的指针，但是又不太一样，举个例子说明：</p>
<p>现在有一个<code>int</code>类型的数组
<code>int example[5];</code>以及一个<code>int</code>类型指针
<code>int* ptr;</code>可以直接令<code>ptr = example</code>，现在对<code>*(ptr + 2)</code>进行操作与对<code>example[2]</code>进行操作是等价的，操作的对象均是数组<code>example</code>的第二个元素，但是使用<code>example[i]</code>对数组元素进行操作时，有一个界限的问题，在<code>Debug</code>模式下，索引值需要满足既不小于0又不大于元素个数的条件，否则会报<code>index error</code>的错误，而使用指针<code>*(ptr + i)</code>却没有限制，意味着我可以修改数组所在的内存范围之外的数据，这是不安全的，使用时要格外注意。</p>
<p>另外，因为数组<code>example</code>的类型为<code>int</code>，因此每个元素占4个byte的内存空间，<code>ptr + 2</code>由前一个<code>int</code>元素跳转到了下一个<code>int</code>元素，实际上内存的跨度是<code>2 * 4 = 8bit</code>，因此也可以使用
<code>*((char*)ptr + 8)</code>来操作同一个元素。</p>
<h4 id="利用指针创建数组">利用指针创建数组</h4>
<p><code>int* another = new int[5];</code>
使用关键字<code>new</code>创建了一个新的<code>int</code>类型数组，与上文的<code>example</code>不同的是，<code>example</code>创建于栈（stack）上，在程序执行至所在代码段的<code>&#125;</code>之外时会被自动销毁，而通过<code>new</code>创建的数组是分配在堆（heap）上的，意味着它的生命周期并不受任何<code>&#123;&#125;</code>的影响，而是直到手动添加的<code>delete</code>语句被执行时才被销毁。使用<code>delete</code>销毁数组指针的简单语法是：<code>delete[] array;</code>　另外，两种方式创建的数组在使用方式上没有任何区别，<code>new</code>一般在函数中创建并返回数组时使用。</p>
<p>值得一提的是，<strong>在类中</strong>，如果在栈上定义成员数组并初始化，那么这个数组就会在这个类的实例的栈地址上连续地扩充５个byte，意味着它们的地址在分配之后是固定的；但是如果用<code>new</code>定义，则这５个byte不会分配在stack上，也就是说此时实例的数据成员与实例的地址不统一，那么程序执行时就必须<strong>先找到实例的地址，再跳转到成员数组的地址</strong>，在数据较多的情况下容易造成比较大的资源浪费。</p>
<p>大部分情况下使用<code>int example[size]</code>的形式创建数组是比较好的，既有严格界限规范，又有稳定连续的地址以及安全的销毁机制、效率高等优点。</p>
<h4 id="如何知道数组的长度">如何知道数组的长度</h4>
<p>以<code>int example[5]</code>形式定义的数组获取长度的方法很简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(example) / <span class="built_in">sizeof</span>(<span class="type">int</span>) </span><br></pre></td></tr></table></figure>
<p>以<code>new</code>的方式定义的数组，如果仍然用上面的方法获取长度，那么第一个<code>sizeof(example)</code>括号中的东西就会是一个<code>int</code>类型的指针，在32位系统上一个地址码的长度为4
byte，意味着<code>len</code>就会等于<code>4/5</code>，被隐式强制转化为<code>int</code>之后就会得到一个<code>0</code>；因此以<code>new</code>的方式定义的数组，获取不了长度
:(</p>
<p>好在STL中构建了一个船新的数组类型供我们使用，在效率和安全性上都比raw
array要有保障，使用方式也非常的平易近人：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; another; <span class="comment">//定义数组</span></span><br><span class="line">another.<span class="built_in">size</span>(); <span class="comment">//获取长度</span></span><br></pre></td></tr></table></figure>
<h4 id="从函数中返回一个数组">从函数中返回一个数组</h4>
<p><strong>方法一：</strong>函数接收一个数组作为参数，在内部进行修改并返回这个数组；</p>
<p>将数组传入函数有三种形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Function</span><span class="params">(<span class="type">int</span> array[])</span></span>;  <span class="comment">// 形式一：不定长，数组形式</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Function</span><span class="params">(<span class="type">int</span> array[<span class="number">5</span>])</span></span>; <span class="comment">// 形式二：定长，数组形式</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Function</span><span class="params">(<span class="type">int</span>* array)</span></span>;   <span class="comment">// 形式三：不定长，指针形式</span></span><br></pre></td></tr></table></figure>
<p>其中形式二的形参数组大小是已知的，在函数内部可直接使用 <code>5</code>
表示数组长度；而形式一和形式三没有给出形参数组的具体大小，会造成一些麻烦，因为唯一计算长度方式是使用
<code>sizeof(array)/sizeof(*array)</code>，但是在函数内部进行这个计算会有很大的错误风险，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Check1</span><span class="params">(<span class="type">int</span> array[])</span> </span>&#123; cout &lt;&lt; <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(array[<span class="number">0</span>]) &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Check2</span><span class="params">(<span class="type">int</span> array[])</span> </span>&#123; cout &lt;&lt; <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(array[<span class="number">0</span>]) &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Check3</span><span class="params">(<span class="type">int</span>* array)</span> </span>&#123; cout &lt;&lt; <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(*array) &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">Check1</span>(a);</span><br><span class="line">	<span class="built_in">Check2</span>(a);</span><br><span class="line">	<span class="built_in">Check3</span>(a);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种方式传入的数组的长度计算结果是：<code>2  2  2</code>，显然是不对的，因此需要将数组作为函数参数时一定要把数组大小也作为参数一起传进去；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Function</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>方法二：</strong>在函数中从<strong>堆</strong>上创建一个新数组并返回；</p>
<p>在栈上定义的数组出了scope之后就会被销毁，因此只能在堆上创建数组才不会返回一个无效的指针，需要注意的一点是，在外部接收了这个数组之后一定记得用完
<code>delete</code> 掉，否则会造成内存泄漏；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法三：</strong>
返回一个局部静态变量，在函数中进行的每次改动都会覆盖上一次的结果；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) </span><br><span class="line">		a[i]++;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="定长数组在定义时的长度指定问题">定长数组在定义时的长度指定问题</h4>
<p>以<code>int example[]</code>形式定义定长数组时，可以留空<code>[]</code>，直接用大括号完成初始化工作，但当需要的容量很大时，这种形式显然非常不方便，因此希望在<code>[]</code>内指定一个size，一般我们会直接填一个常量，但为了程序的可持续发展，还是需要定义这个常量。</p>
<p>通常我们会用宏定义
<code>#define SIZE 5</code>替代常量：<code>int example[SIZE];</code></p>
<p>我在学习的时候使用过<code>const int size = 5</code>，然后
<code>int example[size]</code>，发现编译器报错了，在编译器构建<code>example</code>时<code>size</code>仍然是个未知量，就会造成<code>compile-time unknow constant</code>的错，加以
<code>static</code>静态化才能通过编译；</p>
<h4 id="多维指针与多维数组">多维指针与多维数组</h4>
<p><strong>简述：</strong>二维指针是指向储存<strong>一维指针的地址</strong>的地址的指针，同理二维数组就是储存一维数组的头指针的数组，而二维数组的头指针就是二维指针；以此类推理解多维指针/数组；</p>
<p><strong>在堆上定义一个二维指针/二维数组：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** a2d = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">50</span>];  <span class="comment">//容量为50的指针数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i)</span><br><span class="line">    a2d[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">//每个一维数组容量为 10*4 byte</span></span><br></pre></td></tr></table></figure>
<p><strong>在堆上定义一个三维指针/三维数组：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*** a3d = <span class="keyword">new</span> <span class="type">int</span>**[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    a3d[i] = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">40</span>; ++j)</span><br><span class="line">        a3d[i][j] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">30</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意点一：</strong>使用 <code>delete</code>
释放多维指针时需要特别注意内存泄露的问题，假设我释放了二维指针
<code>a2d</code> ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] a2d;</span><br></pre></td></tr></table></figure>
<p>现在我释放掉的内存只是储存50个一维指针的数组的内存，并不代表释放了500个int数据所占的空间，如果这么做，这2000个byte的空间就属于泄露的内存；由于无法使用诸如
<code>delete[][] a2d;</code>
的句法释放二级指针，只能使用循环一个个释放一维指针，直到全部释放完了之后再释放掉二级指针<code>a2d</code>；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i)</span><br><span class="line">    <span class="keyword">delete</span>[] a2d[i];</span><br><span class="line"><span class="keyword">delete</span>[] a2d;</span><br></pre></td></tr></table></figure>
<p><strong>注意点二：</strong>上述定义多维数组的方式是在堆上定义，这样会有一个问题，就是各个一维数组的分散地分布在堆上的，二维数组中只存储指向这些零散一维数组的指针，每次都需要先取得下一个一维数组的头指针，再对这个一维数组进行操作，效率是很低的；所以在非必要的情况下定义一维数组是最佳的，并且如果元素较少，也可以考虑在栈上定义二维数组，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>不过数量少的话其实也没啥必要定义二维数组不是吗，在堆上创建是因为数目太多不想浪费栈资源不得已而为之的做法。</p>
<h3 id="newdelete-关键字">new/delete 关键字</h3>
<p><strong>new：</strong>根据数据类型在<strong>堆</strong>上申请相应大小的内存空间并返回<strong>首地址</strong>。若数据类型是一个类，则还会根据参数执行对应的<strong>构造函数</strong>；</p>
<p><strong>delete：</strong>销毁<strong>对应的</strong><code>new</code>创建的数据并释放申请的内存空间。若数据类型是一个类，则还会执行<strong>析构函数</strong>；</p>
<p><code>new</code>在不指定初始化内容时会触发<strong>默认初始化机制</strong>，将所有元素初始化为0；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_A, m_B, m_C, m_D;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_A</span>(<span class="number">1</span>), <span class="built_in">m_B</span>(<span class="number">2</span>), <span class="built_in">m_C</span>(<span class="number">3</span>), <span class="built_in">m_D</span>(<span class="number">4</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d) : <span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c), <span class="built_in">m_D</span>(d) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; m_A &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_B &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_C &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_D &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// 默认初始化 0</span></span><br><span class="line">    <span class="type">int</span> *b = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];  <span class="comment">// 默认初始化 0</span></span><br><span class="line">    <span class="type">int</span> *c = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);  <span class="comment">// 初始化为2</span></span><br><span class="line">    <span class="type">int</span> *d = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// 前三个元素初始化为1,2,3，后面的元素默认初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span>* e = <span class="keyword">new</span> Entity;  <span class="comment">// 默认初始化 0</span></span><br><span class="line">    e-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">auto</span>* f = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);  <span class="comment">// 初始化为 5,6,7,8</span></span><br><span class="line">    f-&gt;<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">delete</span>[] b;  <span class="comment">// 销毁数组需要加上[]</span></span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="keyword">delete</span>[] d;</span><br><span class="line">    <span class="keyword">delete</span> e;</span><br><span class="line">    <span class="keyword">delete</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cpp中的<code>new</code>与C中的<code>malloc</code>对应，<code>delete</code>与<code>free</code>对应。</p>
<p>下面两行代码在某种程度上是一样的，唯一的区别是<code>new</code>会调用<code>Entity</code>的构造函数，而<code>malloc</code>只完成内存空间的申请，不会进行实例化的操作；不管怎样，最好<strong>不要</strong>在C++用
<code>malloc</code> 申请内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity* e = <span class="keyword">new</span> Entity;</span><br><span class="line">Entity* e = (Entity*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Entity))</span><br></pre></td></tr></table></figure>
<h3 id="函数指针">函数指针</h3>
<h4 id="创建与使用函数指针">创建与使用函数指针</h4>
<p><strong>简述：</strong>函数指针可将函数置为变量；</p>
<p><strong>创建方式：</strong>假设函数体如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br></pre></td></tr></table></figure>
<p>创建 <code>Hello</code> 函数的指针 <code>function</code> ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(*function)(<span class="type">int</span>) = Print;  <span class="comment">// 或auto function = Print;</span></span><br></pre></td></tr></table></figure>
<p>也可定义一个函数指针类型，再创建函数指针变量，注意形式上需对应，否则无法赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PrintFunction)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">PrintFunction function = Print;</span><br></pre></td></tr></table></figure>
<h4 id="函数指针作为函数参数">函数指针作为函数参数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintValue</span> <span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">void</span>(*func)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> value : values)</span><br><span class="line">        <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">ForEach</span>(values, PrintValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lambda-表达式">lambda 表达式</h4>
<blockquote>
<p>lambda返回一个函数指针，但很多时候无法直接写出返回的具体类型，没必要太纠结，用auto就好</p>
</blockquote>
<p><strong>句法：</strong><code>[capture](params) &#123;body&#125;</code></p>
<ul>
<li>capture：值捕获可使用变量名或者使用<code>=</code>，引用捕获使用<code>&amp;</code>，若有多个捕获，第一个捕获必须指定为<code>=</code>或者<code>&amp;</code>，作为隐式默认捕获方式；若想修改值捕获的变量又不想用引用捕获，可以在参数列表后加上<code>mutable</code>关键字；另外，非局部变量可以不经捕获，直接使用；</li>
<li>params：函数参数列表</li>
<li>body：函数体</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">make_function</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [&amp;]&#123; std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">auto</span> f = <span class="built_in">make_function</span>(i); <span class="comment">// the use of x in f binds directly to i</span></span><br><span class="line">  i = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">f</span>(); <span class="comment">// OK; prints 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="智能指针">智能指针</h3>
<blockquote>
<p>#include &lt;memory&gt;</p>
</blockquote>
<h4 id="智能指针-unique_ptr">智能指针 unique_ptr</h4>
<h5 id="介绍与创建">介绍与创建</h5>
<p>上面介绍了在堆上申请内存的<code>new</code>关键字，之所以需要用<code>new</code>，简单地说就是因为在<strong>栈</strong>上创建的指针的生命周期与所在的scope<code>&#123;&#125;</code>同步，即随着程序运行出<code>&#123;&#125;</code>就会自动释放，但有时我们既需要保持局部的代码块，又需要留下其中的某个变量，因此需要引入<code>new</code>在堆上申请内存空间。但<code>new</code>也有一个问题，就是每一个用它创建的指针都需要手动使用<code>delete</code>释放，在指针繁多的程序中非常容易漏掉几个没有释放，造成内存泄露的大问题，所以需要对<code>new</code>进行改造，解决这个潜在的问题。这就是智能指针。</p>
<p>定义一个智能指针<code>unique_ptr</code>的方式如下，其中第二行使用了C++14
<code>std::make_unique</code>，在安全性上更好。</p>
<p>这里假设 <code>Entity</code> 是一个类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::unique_ptr&lt;Entity&gt; entity(new Entity());</span></span><br><span class="line">std::unique_ptr&lt;Entity&gt; entity = std::<span class="built_in">make_unique</span>&lt;Entity&gt;(); </span><br></pre></td></tr></table></figure>
<p>定义完之后就跟普通的指针一样使用了，比如<code>entity-&gt;Function()</code>等等，程序运行出scope之后会自动释放在<strong>堆</strong>上申请的内存空间并销毁该指针；</p>
<h5 id="使用经验一">使用经验一</h5>
<p>以值传递的形式为 <code>unique_ptr</code>
赋值是不被编译器允许的，像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Entity&gt; entity = std::<span class="built_in">make_unique</span>&lt;Entity&gt;(); </span><br><span class="line">std::unique_ptr&lt;Entity&gt; other = entity;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>但是用 <code>other</code> 接收从函数中创建并返回的
<code>unique_ptr</code> 却是可以的，像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">GetEntity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Entity&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::unique_ptr&lt;Entity&gt; entity = <span class="built_in">GetEntity</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是为什么呢，因为 <code>unique_ptr</code>
是特异的指针，也就是控制权不可以被共享，而从函数中返回的
<code>unique_ptr</code>
并不是以值或者引用的形式返回，而是以移动语义（右值引用）
<code>std::move()</code>
的方式返回，右值引用不会产生新的控制权，因此只要把上面的值传递改成移动语义就可以通过了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Entity&gt; other = std::<span class="built_in">move</span>(entity);</span><br></pre></td></tr></table></figure>
<h4 id="共享指针-shared_ptr">共享指针 shared_ptr</h4>
<p>然而，由于<code>unique_ptr</code>
删除了拷贝构造函数以及它的重载方式，所以不能有两个<code>unique_ptr</code>共享一块内存，每一个指针都是独一无二的（unique），如果需要使用共享同一块内存的指针，需要改用
<code>shared_ptr</code>，其定义方式类似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::shared_ptr&lt;Entity&gt; sharedEntity(new Entity());  # don&#x27;t use</span></span><br><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt; ();</span><br></pre></td></tr></table></figure>
<p>由于同类的共享指针共同维持一块内存空间的存在，需要一个记录每个指针的存在情况的数据，因此一类共享指针需要另申请一块内存用于保存未被销毁的指针数，也叫“引用计数”；因为额外申请一次内存，所以不要使用<code>new</code>的方式创建共享指针。</p>
<p>只有当同一类共享指针<strong>全部</strong>被释放之后，它们共享的某块内存才被释放；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Entity&gt; e0;</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;(); </span><br><span class="line">    e0 = sharedEntity;  <span class="comment">// 引用传递</span></span><br><span class="line">&#125;  <span class="comment">// 出括号之后，在栈上定义的sharedEntity自动销毁了，但创建的实例仍然存在，被e0引用了</span></span><br></pre></td></tr></table></figure>
<h4 id="弱引用指针-weak_ptr">弱引用指针 weak_ptr</h4>
<p>共享指针<code>shared_ptr</code>会将每个指针都与一块内存相关联，并共同决定内存空间的释放与否。而弱引用指针<code>weak_ptr</code>只临时使用这块内存空间，不参与维持它的存在，也就是不会改变共享指针的“引用计数”；</p>
<p><code>weak_ptr</code>拥有一个<code>.expired()</code>的方法，返回一个表示它是否“过期”的信号，主要用于协助<code>shared_ptr</code>工作。因为机制上的问题，检测<code>shared_ptr</code>的有效性不能判定申请的内存是否被释放，而
<code>weak_ptr</code>与<code>shared_ptr</code>
有紧密的联系，它的有效与否能直接判定<code>shared_ptr</code>创建的对象是否被销毁，可以在对象被销毁之后阻止非法访问；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;Entity&gt; e0;</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">    e0 = sharedEntity;</span><br><span class="line">&#125;  <span class="comment">// 出括号之后，唯一的共享指针sharedEntity被销毁，弱引用指针e0也随之销毁</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2>
<p>字符串在内存中的储存位置是<strong>CONST SEGMENT</strong>，即
<strong>read-only Memory</strong>，要避免修改，防止资源浪费；</p>
<p>字符串以<code>\0</code>结尾，代表<code>nullptr</code>，字符指针跳转到此即被回收；</p>
<h3 id="c风格">C风格</h3>
<blockquote>
<p>#include &lt;stdio.h&gt;</p>
</blockquote>
<p>C语言实际上没有明确定义字符串这一概念，字符串在C中就是字符数组；</p>
<h4 id="创建内容确定的字符串常量">创建内容确定的字符串常量</h4>
<p>ps:
此处的“定长”与“不定长”指的是输入时是否已知字符串长度，一旦定义完毕就都是定长的；</p>
<p><strong>定长：</strong><code>const char str[7] = "Cherno";</code>
容量要比字符数多1，自动补充 <code>nullptr</code> 作为结尾；</p>
<p><strong>不定长：</strong><code>const char str[] = "Cherno"</code> 或
<code>const char* str = "Cherno"</code>，同样自动补充
<code>nullptr</code> 结尾；</p>
<h4
id="创建内容由用户输入的字符串常量">创建内容由用户输入的字符串常量</h4>
<p><strong>初始化定长空字符数组：</strong><code>char str[100] = &#123;'\0'&#125;;</code>
容量必须明确，结束标志 <code>'\0'</code> 不能少，否则输出异常；</p>
<p><strong>读取字符串的方式：</strong>
<code>scanf_s()</code>，<code>for()&#123;scanf_s()&#125;</code>
，<code>while(getchar()!='')</code>或 <code>gets_s()；</code></p>
<p>Ⅰ.
<code>scanf_s()</code>：读取一个字符串，遇到空格时<strong>停止</strong>读取，遇到回车时<strong>结束</strong>读取；第三个参数为防溢出上限，针对字符串
<code>%s</code>
而言最多读取（n-1）个字符，如果输入的字符串长度超过（n-1）则取消<strong>所有</strong>读取；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf_s(<span class="string">&quot;%s&quot;</span>, str, <span class="number">100</span>);  <span class="comment">// 最多读取99个字符，最后一个留给自动补全的nullptr</span></span><br></pre></td></tr></table></figure>
<p>也可设置将空格当作字符一并读入，仅遇到回车时停止并结束读取；（可换成任意字符）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf_s(<span class="string">&quot;%[^\n]&quot;</span>, str, <span class="number">100</span>);  <span class="comment">// 同样最多读取99个字符</span></span><br></pre></td></tr></table></figure>
<p>Ⅱ. <code>for()&#123;scanf_s()&#125;</code>：循环读取，每次读取一个字符；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">	scanf_s(<span class="string">&quot;%c&quot;</span>, &amp;str[i], <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>其中 <code>scanf_s()</code> 第三个参数仍然需要指定上限为
<code>1</code>，针对字符 <code>%c</code> 而言就是只读取一个字符；</p>
<p>但在这里情况比较特殊，因为数组分配了一段地址连续的内存，而字符指针<code>char*</code>
在读取完一个字符后会自动往后推，所以即使输入两个字符也都会被读取，同时循环次数<code>i</code>也会一次增加
<code>2</code>，但总的读取上限仍然是100，并且是一直不停地读取直至满100个字符为止；</p>
<p>还有一点需要注意的是，<code>scanf_s</code> 会把回车换行符
<code>\n</code> 当成 <code>char</code>
字符一并读取，导致实际读取的字符少于设定数目，解决这个问题的办法是在
<code>%c</code> 之前加上空格，忽略掉上一个换行符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">	scanf_s(<span class="string">&quot; %c&quot;</span>, &amp;str[i], <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>Ⅲ. <code>while(getchar() != '')</code>：读取一个字符串，以
<code>'\n'</code> 结尾（可换成任意字符）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((str[i++] = getchar()) != <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>Ⅳ.
<code>gets_s()</code>：读取一个字符串，仅遇到回车时停止并结束读取；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gets(str);</span><br></pre></td></tr></table></figure>
<p><strong>打印字符串的方式</strong>：<code>for(printf_s())</code>
逐个字符输出， <code>printf_s()</code> 格式化输出；</p>
<ul>
<li><code>for(printf_s())</code> 逐个字符输出：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">	printf_s(<span class="string">&quot;%c&quot;</span>, str[i]);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>printf_s</code> 格式化输出：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf_s(<span class="string">&quot;%s&quot;</span>, str);</span><br></pre></td></tr></table></figure>
<h3 id="cpp风格">Cpp风格</h3>
<blockquote>
<p>STL string 相关的内容“ 标准模板库STL”</p>
</blockquote>
<h4 id="创建字符串">创建字符串</h4>
<p>因为C++兼容C的所有特性，因此上述所有的方式在C++中都可以使用，但是有一点需要注意，以<strong>指针的方式</strong>定义字符串，不加<code>const</code>的话编译器会直接报错，或者因为
"undifined behavior" 抛出一个<strong>警告</strong>："ISO C++11 does not
allow conversion from string literal to
char*"。因此最好加上，也确保字符串不被修改。</p>
<p>除了上面讲到的方法之外，C++还提供了一些宽字符类型的字符串，定义方式如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* str = <span class="string">L&quot;Cherno&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char16_t</span>* str = <span class="string">u&quot;Cherno&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char32_t</span>* str = <span class="string">U&quot;Cherno&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><code>wchar_t</code>：一个字符占 8bit 或
1Byte，用前缀<code>L</code>声明编码类型；</p>
<p><code>char16_t</code>：一个字符占 16bit 或
2Byte，用前缀<code>u</code>声明编码类型；</p>
<p><code>char32_t</code>：一个字符占 32bit 或
4Byte，用前缀<code>U</code>声明编码类型；</p>
<p><img src="unicode.png" alt="不同编码方式下单个英文字母或汉字的大小" style="zoom:100%"></p>
<p>其实正常的 <code>const char* str</code>
也可用<code>u8</code>来声明编码类型，只不过这个可以省略，但上面几个都不能省；</p>
<p>另外，由于长字符串存在换行麻烦的问题：既要注意换行符<code>\n</code>，又需要给每一行都加上引号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;Hello,\n&quot;</span></span><br><span class="line"><span class="string">&quot;my name is Jack,\n&quot;</span></span><br><span class="line"><span class="string">&quot;what&#x27;s your name?&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>为此C++还提供了一个<strong>可换行</strong>的字符串编码类型，用前缀
<code>R</code>
表示，只需用引号+括号包裹起来，自动判定内容里的回车为换行符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">R&quot;(Hello,</span></span><br><span class="line"><span class="string">my name is Jack,</span></span><br><span class="line"><span class="string">what&#x27;s your name?&#x27;)&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="读取字符串">读取字符串</h4>
<p><strong>方法一：</strong><code>std::cin</code> 逐个字符读取；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	std::cin &gt;&gt; str[i];</span><br></pre></td></tr></table></figure>
<p><strong>方法二：</strong><code>std::cin.get()</code> 与
<code>std::cin.getline()</code> 读取字符串，第二个参均表示最多读取 99
个字符；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cin.<span class="built_in">get</span>(str, <span class="number">100</span>);</span><br><span class="line">std::cin.<span class="built_in">getline</span>(str, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h4 id="输出字符串">输出字符串</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="说明">说明</h3>
<p>定义字符串时<strong>强烈建议使用</strong><code>const</code>修饰符，避免字符串被修改。因为字符串在用数组（raw
array）的方式定义后可被以索引值修改，但是字符串储存在内存中的一片 "const
section"
只读区域，强行修改字符串中的字符会造成很大的资源浪费，<strong>最好不要</strong>修改；</p>
<p>假如对字符串进行了修改，比如<code>char* name = "Cherno"; name[2] = 'a';</code>，在Release模式下可编译可运行，但修改是无效的，输出仍然保持原有的字符串；而在Debug模式下会抛出一个<strong>段错误</strong>
"Exception Thrown"（VS）"interrupted by signal 11:
SIGSEGV"（CLion），非得修改只能用数组的形式定义<code>char name[] = "Cherno"; name[2] = 'a'</code>，即使可编译可运行结果正确，仍强烈不建议。</p>
<h2 id="类和结构体">类和结构体</h2>
<h3 id="类与结构体的唯一区别">类与结构体的唯一区别</h3>
<p>类中没有注明是
<code>public</code>还是<code>private</code>的成员默认为<code>private</code>，而结构体中默认是<code>public</code>；</p>
<h3 id="如何选择">如何选择</h3>
<p>变量多方法少偏向结构体，反之或者二者都多时偏向类；</p>
<p>需要使用继承时，只用类；</p>
<h3 id="构造函数">构造函数</h3>
<p>在Cpp中如果定义一个类不写构造函数，则Cpp会自动创造一个默认的构造函数，其形式上相当于
<code>Class() = default;</code> 或
<code>Class()&#123;&#125;</code>，没有内容即不会做任何事情，也就<strong>不会</strong>把所有的成员变量都初始化为0，因此初始化的内容必须手动填充。</p>
<p>大部分情况下，构造函数的功能就是对成员变量进行初始化，这里非常需要介绍一种初始化的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Number;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">m_Number</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string &amp;name, <span class="type">int</span> number) : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Number</span>(number) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在形式上，将原本似乎应该在<code>&#123;&#125;</code>内进行的赋值操作通过<code>:member(param)</code>的操作在<code>&#123;&#125;</code>之前完成，这样的形式称为"Constructor
Member Initializer List"，即<strong>成员初始化列表</strong>。</p>
<p>那么为什么需要这样一个List进行初始化呢，在<code>&#123;&#125;</code>内不是已经可以了吗？</p>
<p>在大多数情况下，构造函数进行的初始化工作是很执行很简单的赋值语句，并在需要时做一些简单的运算，目的还是给成员变量一个值。但是当变量比较多的时候，为了达到这样简单的目的，要在<code>&#123;&#125;</code>内一个一个进行赋值，确实不太愿意写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c, d, e, f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        a = value;</span><br><span class="line">        b = <span class="number">6</span>;</span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">        d = <span class="number">3</span>;</span><br><span class="line">        e = <span class="number">5</span>;</span><br><span class="line">        f = b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>像上面这样的代码这实在有些辣眼睛，我们更希望通过简洁一些的方式来做同样的事：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c, d, e, f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> value) : <span class="built_in">a</span>(value), <span class="built_in">b</span>(<span class="number">6</span>), <span class="built_in">c</span>(<span class="number">2</span>), <span class="built_in">d</span>(<span class="number">3</span>), <span class="built_in">e</span>(<span class="number">5</span>) &#123; f = b + c; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上，这样做不仅在代码风格层面上更简洁美观，还提高了代码的效率。</p>
<p>每一个类都会有一个不带参数的构造函数，不论是否定义，并且在进行无参实例化的时候就会自动调用。比如下面这段代码</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> x) &#123; std::cout &lt;&lt; <span class="string">&quot;Created Entity with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Example m_Example;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123; m_Example = <span class="built_in">Example</span>(<span class="number">8</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Entity</code>类中存在的<code>Example</code>实例会默认调用一次<code>Example</code>的无参构造函数，但在<code>Entity</code>的构造函数中重新对<code>Example</code>进行了有参实例化，这样无形中实例化了两次：</p>
<p><img src="initialize.png" alt="实例化了两次"></p>
<p>改成使用<strong>成员初始化列表</strong>，就可以避免这种浪费了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Example m_Example;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Example</span>(<span class="built_in">Example</span>(<span class="number">8</span>)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="initialize2.png" alt="只实例化一次"></p>
<p><strong>委托构造函数</strong></p>
<p>当我们想让一个类的默认构造函数对成员进行初始化，又需要定义一个通过接收参数来初始化的构造函数时，并且二者的函数体相同时，往往要写两次形式非常接近的构造函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>	</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a, b, c;</span><br><span class="line">	<span class="built_in">Entity</span>() : <span class="built_in">a</span>(<span class="number">0</span>), <span class="built_in">b</span>(<span class="number">1</span>), <span class="built_in">c</span>(<span class="number">2</span>) &#123;...&#125;</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b), <span class="built_in">c</span>(c) &#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用委托构造函数代替默认构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Entity</span>() : <span class="built_in">Entity</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>将初始化的任务委托给带参数的构造函数，省得再写一遍了，代码也更整洁；</p>
<h3 id="explicit-关键字">explicit 关键字</h3>
<p><code>explicit</code>
阻止了利用<strong>单参数</strong>构造函数进行的一切隐式转换；</p>
<p>假设我们有这样一个类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> age) : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">m_Age</span>(age) &#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Age</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一般情况下，在栈中对这个类进行实例化的方式是：<code>Entity e(22)</code>以及<code>Entity f("Cherno")</code>，但是避免不了有这样实例化的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity e = <span class="number">22</span>;  <span class="comment">// 可执行</span></span><br><span class="line">Entity f = <span class="string">&quot;Cherno&quot;</span>;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>这在c++中其实是一种编译器层面的 <strong>隐式转换</strong> "Implicit
conversion"，由于<code>Entity</code>存在只接受一个<code>int</code>或一个<code>std::string</code>的构造函数，所以<code>Entity e = 22;</code>其实是调用构造函数进行了一次从<code>(int)22</code>到<code>Entity(22)</code>的隐式转换。</p>
<p>既然如此，为什么<code>Entity f = "Cherno";</code>报错了？</p>
<p>因为字符串<code>"Cherno"</code>的默认类型是<code>const char[]</code>而非<code>std::string</code>，而在C++中一个语句只能执行<strong>一次</strong>隐式转换，而这行代码实际上既要执行从<code>const char[]</code>到<code>std::string</code>的转换，又要执行从<code>std::string</code>到<code>Entity(std::string)</code>的转换，两次是不行的，所以报错了，必须改成以下两种形式之一才可行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity f = (std::string)<span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">Entity f = <span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果在构造函数前加上<code>explicit</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">int</span> age)</span> : m_Name(<span class="string">&quot;Unknown&quot;</span>), m_Age(age) &#123;</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> : m_Name(name), m_Age(<span class="number">-1</span>) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>就不再允许使用上面的几种方式进行实例化，只能用函数的形式或强制类型转化的方式实例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Entity <span class="title">b</span><span class="params">(<span class="number">22</span>)</span></span>;  <span class="comment">// 函数形式</span></span><br><span class="line">Entity f = (Entity)<span class="string">&quot;Cherno&quot;</span>;  <span class="comment">// 强制类型转换</span></span><br></pre></td></tr></table></figure>
<h3 id="实例化的两种方式-栈or堆">实例化的两种方式 栈or堆</h3>
<p>Cpp支持自主选择在栈（stack）或堆（heap）上对类进行实例化；</p>
<p><strong>在栈上实例化</strong>：具有<strong>确定</strong>的生命周期，与所在的<code>&#123;&#125;</code>同步，在程序运行至所在<code>&#123;&#125;</code>外时<strong>栈弹出</strong>，<strong>自动销毁</strong>实例并<strong>释放</strong>所占的内存空间；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 栈</span><br><span class="line"><span class="function">Entity <span class="title">e</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">Entity e = <span class="built_in">Entity</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p><strong>在堆上实例化：</strong>生命周期由设计者决定，由<code>new</code>创建，对应的需要使用<code>delete</code>销毁实例并释放内存；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 堆</span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">delete</span> e;</span><br></pre></td></tr></table></figure>
<p><strong>如何选择</strong></p>
<p>大部分情况下，能在栈上创建就在栈上创建，省略取地址的时间，提高效率；</p>
<p>当类的内容非常多，或者需要创建非常多的实例以至于栈的容量捉急时，在堆上创建；</p>
<p>需要手动管理实例的生命周期时，在堆上创建；</p>
<h3 id="析构函数">析构函数</h3>
<p>与构造函数对应，析构函数在实例被销毁时自动调用，也可手动调用销毁一个实例。它与构造函数的组合相当于<code>new</code>和<code>delete</code>的组合，只不过析构函数可以自动调用，而<code>delete</code>需要手动执行。如果没有析构函数，则就如同没有<code>delete</code>，当程序比较复杂、运行时间较长时，容易造成内存拥堵，申请不到内存空间而使程序崩溃。</p>
<p>同样，cpp会为一个没有实现析构函数的类创建默认析构函数，内容一样为空。</p>
<p>手动调用析构函数的方式：<code>instance.~Class();</code>，一般不用手动调。</p>
<h3 id="虚析构函数">虚析构函数</h3>
<p><strong>简介</strong></p>
<p>虚析构函数的存在是为了解决销毁用 <code>new</code>
创建的指向子类的父类指针时因无法调用子类析构函数而造成的内存泄漏问题，解决的方式是在父类析构函数前加上
<code>virtual</code>
关键字使其成为虚析构函数，并且无需在子类中覆盖；</p>
<p><strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Constructor\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>() &#123; m_Array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; std::cout &lt;&lt; <span class="string">&quot;Derived Constructor\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">Derived</span>() &#123; <span class="keyword">delete</span>[] m_Array; std::cout &lt;&lt; <span class="string">&quot;Derived Destructor\n&quot;</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span>* m_Array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* poly = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">	<span class="keyword">delete</span> poly;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在main中创建了一个指向子类 <code>Derived</code> 父类
<code>Base</code> 指针 <code>poly</code> 并销毁了它，输出结果如下：</p>
<p><img src="virtual_destructor.png" alt="未调用Derived析构函数"></p>
<p>可见子类 <code>Derived</code>
的析构函数没有被调用，由于子类中存在堆数据
<code>m_Array</code>，间接导致了该数据的内存泄漏；</p>
<p>解决的办法就是使父类成为虚析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructor\n&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>子类无需覆盖析构函数，也会实现自动调用：</p>
<p><img src="virtual_destructor2.png" alt="修改后"></p>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<h4 id="深拷贝">深拷贝</h4>
<p>以值传递的形式进行的拷贝叫做深拷贝，意思就是将目标的值完整地复制到一块新的内存地址上去，成为一个独立的复制品；</p>
<p>因为复制品拥有独立的内存空间与地址，所以修改它完全不会影响原变量；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> b = a;  </span><br><span class="line">Entity e;  <span class="comment">// class Entity&#123;...&#125;</span></span><br><span class="line">Entity f = e;</span><br></pre></td></tr></table></figure>
<h4 id="浅拷贝">浅拷贝</h4>
<p>以指针或引用的形式进行的拷贝叫做浅拷贝，生成的复制品使用了目标的地址，二者穿同一条裤子；</p>
<p>使用浅拷贝要注意一个大问题，在栈上进行浅拷贝时，栈弹出后两个指针都会被销毁，但是它们指向的是同一块内存，连着释放两次属于“undefined
behavior”即编译器未定义的行为，崩不崩溃全凭运气，最好还是避免这样的情况出现；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> *b = a;  </span><br><span class="line">Entity e;</span><br><span class="line">Entity &amp;f = e;</span><br></pre></td></tr></table></figure>
<h4 id="拷贝构造函数-1">拷贝构造函数</h4>
<blockquote>
<p><strong>默认的</strong>拷贝构造函数对非指针成员变量进行深拷贝，对指针成员变量进行浅拷贝，也就是说一般在有指针成员变量时需要重写拷贝构造函数，对指针变量进行深拷贝。</p>
</blockquote>
<p>下面这段代码定义了一个String类，但没有定义其拷贝构造函数，试运行并做简单分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_Buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_Size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(str);</span><br><span class="line">        m_Buffer = <span class="keyword">new</span> <span class="type">char</span>[m_Size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer, str, m_Size);</span><br><span class="line">        m_Buffer[m_Size] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>() &#123; <span class="keyword">delete</span>[] m_Buffer; &#125;</span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[] (<span class="type">unsigned</span> <span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Buffer[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; stream, <span class="type">const</span> String&amp; str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; stream, <span class="type">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; str.m_Buffer;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">    String second = str;</span><br><span class="line">    second[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的拷贝构造函数在被调用时只进行“类型上的”浅拷贝，就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝形式 一</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="built_in">sizeof</span>(String));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 浅拷贝形式 二</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">    : <span class="built_in">m_Buffer</span>(other.m_Buffer), <span class="built_in">m_Size</span>(other.m_Size)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>回到上面完整的代码，在main函数中定义的<code>String second = str;</code>
进行了一次对<code>str</code>的拷贝，但由于<code>str</code>中的<code>m_Buffer</code>类型为指针，所以发生的拷贝是浅拷贝，即只拷贝了地址，这样就造成<code>second</code>与<code>str</code>指向了同一块内存区域，此后进行的<code>second[2] = 'a'</code>改动会同时改变<code>str</code>，并且，在析构时会进行两次<code>delete</code>操作，导致"undefined
behavior"的发生；</p>
<p>为了让拷贝的<code>second</code>的<code>m_Buffer</code>变量独立于<code>str</code>存在，就需要对<code>str</code>进行深拷贝，这就需要我们修改默认的拷贝构造函数；</p>
<p>我们针对指针成员<code>m_Buffer</code>重写拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">    : <span class="built_in">m_Size</span>(other.m_Size)</span><br><span class="line">&#123;</span><br><span class="line">    m_Buffer = <span class="keyword">new</span> <span class="type">char</span>[m_Size + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_Buffer, other.m_Buffer, m_Size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改完之后<code>second</code>的<code>m_Buffer</code>就会有独立的内存空间与地址，对它进行的修改也就不会再影响到<code>str</code>了；</p>
<p><strong>拷贝构造函数在实例进行“值传递”时会被调用</strong></p>
<ul>
<li><p>创建实例的形式：<code>String second  = str</code></p></li>
<li><p>实例作为函数实参的形式：<code>Function(str);</code></p></li>
<li><p>实例的强制类型转化形式：<code>xxx_cast&lt;&gt;()</code></p></li>
<li><p>以值的形式（非引用）从函数中返回时：<code>return str;</code>，因为出了函数的scope之后，函数所占有的栈内存会被释放，因此执行return语句时会先调用拷贝构造函数复制一个临时对象（地址也是临时的），返回这个临时对象后，再析构掉原对象。而返回的临时对象会在外部使用完毕后被析构；</p></li>
<li><p>第一点容易注意到，后两者容易忽略。针对第二点，可以在定义函数时<strong>将形参修改为引用</strong>，且在没有修改实例的必要时，加上<code>const</code>；针对第三点，可以使用引用返回，或者移动语义；</p></li>
</ul>
<h4 id="拷贝赋值运算符">拷贝赋值运算符</h4>
<p><strong>在有必要重写拷贝构造函数的情况下，同样也需要重载赋值运算符，因为二者对指针成员默认都进行浅拷贝；</strong></p>
<p>拷贝赋值运算符就是在类的内部进行重载的赋值运算符，其形参和拷贝构造函数相同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Entity&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Entity&amp; other) </span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Calling Copy operator=&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	m = <span class="keyword">new</span> <span class="built_in">int</span>(*other.m);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移动构造函数">移动构造函数</h3>
<blockquote>
<p>stdc++ &gt;= C++11</p>
</blockquote>
<p><strong>移动语义：</strong>源对象资源的控制权全部交给目标对象</p>
<ul>
<li>c++11移动方法：<code>std::move()</code></li>
<li>移动方式：右值引用</li>
<li>移动与拷贝最重要的区别：是否分配新的内存空间</li>
</ul>
<p><strong>移动构造与拷贝构造的区别：</strong>假设有一临时对象，其地址指向一块随意的堆内存，需要另存为一个稳定的对象</p>
<ul>
<li>通过拷贝构造创建新对象时，将临时对象完全复制一份（默认为指针成员浅拷贝，其余成员深拷贝，需要自行修改指针变量为深拷贝，否则容易造成内存泄漏）作为新对象，并且新对象的地址指向一块重新申请分配的等大的内存，拷贝完成后再析构掉临时对象；</li>
<li>通过移动构造创建新对象时，只将临时对象的资源直接移动给新对象，二者地址相同，指向同一块内存，省去了拷贝和析构的消耗；</li>
</ul>
<p><strong>移动构造函数</strong></p>
<ul>
<li><strong>目的：</strong>解决拷贝构造函数不得不对指针做深拷贝的资源浪费问题</li>
<li><strong>方式：</strong>以右值引用的方式传递原实例，对指针成员进行浅拷贝，同时令原对象的指针成员成为空指针<code>nullptr</code>，避免之后出现重复
<code>delete</code> 同一块的内存的情况</li>
</ul>
<p><strong>例子：</strong>将拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符整合在一个类里进行对比</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span>* m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>() : <span class="built_in">m</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">	~<span class="built_in">Entity</span>() &#123; <span class="keyword">delete</span> m; std::cout &lt;&lt; <span class="string">&quot;Destructor!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetM</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *m; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy</span></span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">const</span> Entity&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">		: <span class="built_in">m</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*other.m))</span><br><span class="line">	&#123; </span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Copy Constructor!&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">	&#125;</span><br><span class="line">	Entity&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Entity&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Copy operator=&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		m = <span class="keyword">new</span> <span class="built_in">int</span>(*other.m);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Move</span></span><br><span class="line">	<span class="built_in">Entity</span>(Entity&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">		: <span class="built_in">m</span>(other.m)</span><br><span class="line">	&#123;</span><br><span class="line">		other.m = <span class="literal">nullptr</span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Move constructor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Entity&amp; <span class="keyword">operator</span>= (Entity&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Move operator=&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		m = other.m;</span><br><span class="line">		other.m = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Entity <span class="title">GetEntity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">GetEntity</span>().<span class="built_in">GetM</span>() &lt;&lt; std::endl; <span class="comment">// 拷贝or移动构造</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;------------------------\n&quot;</span>;</span><br><span class="line">	Entity a, b;</span><br><span class="line">	a = b;  <span class="comment">// 拷贝=</span></span><br><span class="line">	a = std::<span class="built_in">move</span>(b); <span class="comment">//移动=</span></span><br><span class="line">	std::cin.<span class="built_in">ignore</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>首先对比拷贝构造和移动构造：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy</span></span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> Entity&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">	: <span class="built_in">m</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*other.m))</span><br><span class="line">&#123; </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Copy Constructor!&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move</span></span><br><span class="line"><span class="built_in">Entity</span>(Entity&amp;&amp; other) <span class="keyword">noexcept</span> </span><br><span class="line">	: <span class="built_in">m</span>(other.m)</span><br><span class="line">&#123;</span><br><span class="line">	other.m = <span class="literal">nullptr</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Move constructor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以很明显地看出二者有以下区别：</p>
<ul>
<li>拷贝构造函数对指针成员变量 <code>int* m</code>
做了深拷贝，而移动构造函数做了浅拷贝；</li>
<li>拷贝构造函数以左值引用 <code>&amp;</code>
的形式传参，移动构造函数以右值引用 <code>&amp;&amp;</code>
的形式传参；</li>
<li>拷贝构造函数不需要对参数实例做任何修改，因此以<code>const &amp;</code>
的形式传参，而移动构造函数中由于作了浅拷贝，需要将参数实例的指针成员置为
<code>nullptr</code>，手动避免不安全的指针共享，因此参数不能使用const；</li>
</ul>
<p><strong>其次对比拷贝赋值运算符和移动赋值运算符：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy</span></span><br><span class="line">Entity&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Entity&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Copy operator=&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	m = <span class="keyword">new</span> <span class="built_in">int</span>(*other.m);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move</span></span><br><span class="line">Entity&amp; <span class="keyword">operator</span>= (Entity&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Move operator=&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	m = other.m;</span><br><span class="line">	other.m = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二者的区别与他们的构造函数基本相同，但移动赋值运算符与移动构造函数还有一点区别，就是移动赋值运算符需要额外判断传入的实参是不是自己本身，避免出现“自己移动给自己”的情况，因为这种情况下会把自己的成员变量置为
<code>nullptr</code>，无异于自杀。</p>
<p><strong>分析运行结果：</strong></p>
<p>先上图：</p>
<p><img src="copy_and_move.png" alt="运行结果"></p>
<p>分析 <code>main</code> 函数与输出结果：</p>
<ul>
<li><code>GetEntity()</code> 返回了一个在函数内部创建的
<code>Entity</code> 实例，先是创建实例调用了一次构造函数，然后在执行
<code>return e;</code> 语句时调用了移动构造函数将 <code>e</code>
的资源转移给临时对象，并调用析构函数销毁
<code>e</code>，然后返回临时对象，临时对象调用 <code>GetM()</code>
方法输出结果 "1"，在 <code>std::cout</code>
执行完毕后调用析构函数销毁临时对象。整个过程对应输出结果中分隔线
<code>----------</code> 的上半部分；</li>
<li><code>Entity a,b;</code> 实例化两个<code>Entity</code>
对象，调用两次构造函数；</li>
<li><code>a = b;</code> 调用拷贝赋值运算符将 <code>b</code>
的资源整体拷贝给 <code>a</code>；</li>
<li><code>a = std::move(b);</code> 调用移动赋值运算符将 <code>b</code>
的资源转移给 <code>a</code>；</li>
</ul>
<h3 id="封装可视化-visibility">封装/可视化 Visibility</h3>
<p>顾名思义，visible就是让类的成员<strong>部分</strong>对外开放，达到目的的手段就是对各个变量与方法进行<code>public/private/protected</code>归类；</p>
<p>一般来说，封装的结果就是部分变量对外不可见，根据继承需要划分至<strong>private</strong>与<strong>protected</strong>内，<strong>public</strong>部分仅留提供给外部使用的接口，而实现接口功能的功能函数一般也归到<strong>private</strong>内；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_X, m_Y;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Cube</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a * a * a; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_X</span>(<span class="number">0</span>), <span class="built_in">m_Y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">m_X</span>(x), <span class="built_in">m_Y</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SumCube</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Cube</span>(m_X) + <span class="built_in">Cube</span>(m_Y); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>封装的好处：程序维护者易读懂，使用者一看就知道怎么用；保护数据，外界不可见也不可修改；</p>
<h3 id="虚函数与多态">虚函数与多态</h3>
<h4 id="为什么需要虚函数">为什么需要虚函数</h4>
<p>当类与类之间存在继承关系并且有性质和功能相同的函数时，容易出现调用指向混乱的问题，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Player</span><span class="params">(std::string  name)</span> : m_Name(std::move(name)) &#123;</span>&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">Print</span>(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    <span class="built_in">Print</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Print</code>函数获取了一个<code>Player</code>类的实例作为实参，仍然按照<code>Entity</code>类的<code>GetName</code>方法获取
了在<code>Entity</code>类内部定义的<code>m_Name</code>，因为<code>Player</code>继承于<code>Entity</code>，在执行类似这样的调用时非常容易造成混乱，因此需要引入虚函数来解决这样可能的问题。</p>
<h4 id="虚函数的使用方法">虚函数的使用方法</h4>
<p>简单地在基类函数的返回类型前加上<code>virtual</code>关键字即可，如：<code>virtual std::string GetName() &#123; return "Entity"; &#125;</code>，此时子类中对应的函数会自动成为覆盖类型<code>override</code>，建议加上这个标注，例如：<code>std::string GetName() override &#123; return m_Name; &#125;</code>，设置覆盖为显式覆盖，改善代码可读性；</p>
<p>覆盖<code>override</code>不等于重载<code>overload</code>，重载可以更改参数类型、返回类型、参数个数与函数内容，而覆盖必须在形式上与基类的函数保持一致，仅修改函数的内容；</p>
<p>虚函数在子类中可以不实现，但是<strong>在基类中必须实现（覆盖）</strong>。如果虚函数在基类中留空，那么即使子类实现了，并且主函数中也不构造基类的实例，仍然会报错。</p>
<p>如果子类在覆盖时仍然声明为虚函数，那么在子类的子类中就可以实现多态，并且不影响父类与子类的多态；</p>
<h4 id="纯虚函数">纯虚函数</h4>
<p>纯虚函数的形式：<code>virtual std::string GetName() = 0;</code></p>
<p>含有纯虚函数（必须是纯虚函数，普通虚函数不算）的类称为<strong>抽象类</strong>，抽象类不可被实例化，强行实例化就报错，只有对父类的纯虚函数进行复写的子类可被实例化。</p>
<p>纯虚函数<strong>必须</strong>在子类中被实现（复写），否则报错。复写后可以再继承给子类的子类进行二次复写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//基类纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> : <span class="keyword">public</span> Printable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125; <span class="comment">//一次继承、覆盖</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Player</span><span class="params">(std::string  name)</span> : m_Name(std::move(name)) &#123;</span>&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125; <span class="comment">//二次继承、覆盖</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintClassName</span><span class="params">(Printable* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;<span class="built_in">GetClassName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="keyword">auto</span>* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    <span class="built_in">PrintClassName</span>(e);</span><br><span class="line">    <span class="built_in">PrintClassName</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多态与虚函数表">多态与虚函数表</h4>
<h5 id="什么是多态">什么是多态</h5>
<p>多态，顾名思义就是多种状态，也可理解为<strong>动态绑定</strong>，在面向对象中指的是一个接口在父子类中的多种实现方式；</p>
<p>从语法的角度而言，如果将基类中的某个成员函数声明为虚函数，那么其子类中与该函数具有相同原型的成员函数就也是<strong>虚函数</strong>，并且对基类中的版本形成<strong>覆盖</strong>。这时，通过指向子类对象的基类指针，或者引用子类对象的基类引用，调用虚函数，实际被执行的将是子类中的覆盖版本，而非基类中的原始版本，这就是多态。</p>
<p>例如上面的代码，<code>auto* p = new Player("Cherno");</code>
生成了一个指向子类 <code>Player</code> 对象的指针 <code>p</code>，而
<code>PrintClassName</code>函数指定的参数是基类指针<code>Printable*</code>，于是将
<code>p</code> 作为参数调用该函数时实现了
"通过指向子类对象的基类指针调用虚函数" 的功能，实现了接口
<code>GetClassName</code> 的多态；</p>
<h5 id="虚函数表">虚函数表</h5>
<p><strong>问题：</strong>编译器是如何实现多态的？</p>
<p><strong>答案：</strong>通过虚函数表指定虚函数入口，实现动态绑定</p>
<ul>
<li>每个多态类都有一个虚表（virtual
table），虚表中包括了当前类中各个虚函数的函数指针</li>
<li>每个对象都有一个指向当前类的虚表的指针（虚指针
vptr），可以理解为一个隐含的成员变量</li>
<li>构造函数中为对象的虚指针赋值</li>
<li>通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址，再进入该地址调用虚函数</li>
</ul>
<h3 id="继承与派生">继承与派生</h3>
<h4 id="基本继承方式">基本继承方式</h4>
<h5 id="public-公有继承">public 公有继承</h5>
<ul>
<li><strong>继承的访问控制</strong>
<ul>
<li>基类的 <code>public</code> 和 <code>protected</code>
成员，在派生类中保持原属性</li>
<li>基类的 <code>private</code> 成员，在派生类中不可直接房问</li>
</ul></li>
<li><strong>访问权限</strong>
<ul>
<li>派生类中的成员函数可以直接访问基类中的 <code>public</code> 和
<code>protected</code> 成员，无法访问 <code>private</code> 成员</li>
<li>通过派生类的对象，只能访问从基类中继承的 <code>public</code>
成员</li>
</ul></li>
</ul>
<h5 id="private-私有继承">private 私有继承</h5>
<ul>
<li><strong>继承的访问控制</strong>
<ul>
<li>基类的 <code>public</code> 和 <code>protected</code>
成员，在派生类中成为 <code>private</code> 属性</li>
<li>基类的 <code>private</code> 成员，在派生类中不可直接访问</li>
</ul></li>
<li><strong>访问权限</strong>
<ul>
<li>派生类中的成员函数可以直接访问基类中的 <code>public</code> 和
<code>protected</code> 成员，无法访问 <code>private</code> 成员</li>
<li>通过派生类的对象，不能直接访问从基类中继承的任何成员</li>
</ul></li>
</ul>
<p><strong>protected 保护继承</strong></p>
<ul>
<li><strong>继承的访问控制</strong>
<ul>
<li>基类的 <code>public</code> 和 <code>protected</code>
成员，在派生类中成为 <code>protected</code> 属性</li>
<li>基类的 <code>private</code> 成员，在派生类中不可直接访问</li>
</ul></li>
<li><strong>访问权限</strong>
<ul>
<li>派生类中的成员函数可以直接访问基类中的 <code>public</code> 和
<code>protected</code> 成员，无法访问 <code>private</code> 成员</li>
<li>通过派生类的对象，不能直接访问从基类中继承的任何成员</li>
</ul></li>
<li><strong>protected 成员的特点</strong>
<ul>
<li>对于对象而言，等同于 <code>private</code> 成员，不可直接访问;</li>
<li>对于派生类而言，等同于 <code>public</code> 成员</li>
<li>既实现数据隐藏，又方便继承</li>
</ul></li>
</ul>
<h4 id="虚继承与虚基类">虚继承与虚基类</h4>
<h5 id="问题场景">问题场景</h5>
<p>当派生类从多个基类中派生，而这些基类又有共同的基类时，很可能产生成员的重复/冗余</p>
<h5 id="虚基类的声明">虚基类的声明</h5>
<p>以 <code>virtual</code> 声明基类的继承方式为虚继承</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> B</span><br></pre></td></tr></table></figure>
<h5 id="作用">作用</h5>
<ul>
<li>解决多继承时可能发生的对同一基类继承多次而产生的二义性问题；</li>
<li>为最远派生类提供唯一的基类成员，不重复产生多次复制；</li>
</ul>
<h5 id="注意点">注意点</h5>
<ul>
<li>在<strong>第一级</strong>继承时就要将共同基类设计为虚基类；</li>
<li>最远派生类指的是<strong>实例化时</strong>所指定的类；</li>
<li>虚基类的成员<strong>只由</strong>最远派生类的构造函数通过调用虚基类的构造函数进行初始化，其他会被忽略；</li>
<li>虽然第三点，但在整个继承结构中，直接或间接继承虚基类的所有派生类，都要在构造函数的成员初始化列表中为虚基类的构造函数传递参数。如果未列出，则调用虚基类的默认构造函数；</li>
</ul>
<h5 id="例子">例子</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var0;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">int</span> a) </span><br><span class="line">		: <span class="built_in">var0</span>(a) </span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; var0 &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>(<span class="type">int</span> a) </span><br><span class="line">		: <span class="built_in">Base</span>(a), <span class="built_in">var1</span>(a + <span class="number">1</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base1: &quot;</span> &lt;&lt; var1 &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var2;</span><br><span class="line">	<span class="built_in">Base2</span>(<span class="type">int</span> a) </span><br><span class="line">		: <span class="built_in">Base</span>(a), <span class="built_in">var2</span>(a + <span class="number">2</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base2: &quot;</span> &lt;&lt; var2 &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>(<span class="type">int</span> a) </span><br><span class="line">		: <span class="built_in">Base</span>(a), <span class="built_in">Base1</span>(a), <span class="built_in">Base2</span>(a), <span class="built_in">var3</span>(a + <span class="number">3</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived: &quot;</span> &lt;&lt; var3 &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; d.var0 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d.var1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d.var2 &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">		&lt;&lt; d.var3 &lt;&lt; std::endl;</span><br><span class="line">	d.<span class="built_in">Func</span>();</span><br><span class="line">	std::cin.<span class="built_in">ignore</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="derived1.png" alt="二级继承与虚基类"></p>
<h5 id="再整活整活">再整活整活</h5>
<p>我们先总结以下上面这个例子的继承结构：</p>
<ul>
<li>一级基类：<code>Base</code></li>
<li>二级基类：<code>Base1</code>、<code>Base2</code>，均 public
继承于一级基类 <code>Base</code></li>
<li>派生类：<code>Derived</code>，多继承于两个二级基类，在本例中被实例化，因此也是最远派生类</li>
</ul>
<p>因为派生类 <code>Derived</code>
继承于两个二级基类，而两个二级基类又继承于同一个一级基类，因此需要在一级继承时设计为虚基类和虚继承。</p>
<p>那么我想将派生类再设计成多重继承的方式，看看会怎么样，于是我设计了一个新的继承体结构：</p>
<ul>
<li>一级基类：<code>Base</code></li>
<li>二级基类：<code>Base1</code>、<code>Base2</code>，均 public
继承于一级基类 <code>Base</code></li>
<li>三级基类：<code>Base12</code>、<code>Base21</code>，均 public
多继承与 <code>Base1</code> 和 <code>Base2</code></li>
<li>派生类：<code>Derived</code>，多继承于两个三级基类
<code>Base12</code> 和 <code>Base21</code>，作为最远派生类</li>
</ul>
<p>现在的代码变成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var0;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">int</span> a) </span><br><span class="line">		: <span class="built_in">var0</span>(a) </span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; var0 &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>(<span class="type">int</span> a) </span><br><span class="line">		: <span class="built_in">Base</span>(a), <span class="built_in">var1</span>(a + <span class="number">1</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base1: &quot;</span> &lt;&lt; var1 &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var2;</span><br><span class="line">	<span class="built_in">Base2</span>(<span class="type">int</span> a) </span><br><span class="line">		: <span class="built_in">Base</span>(a), <span class="built_in">var2</span>(a + <span class="number">2</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base2: &quot;</span> &lt;&lt; var2 &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base12</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base1, <span class="keyword">virtual</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base12</span>(<span class="type">int</span> a) </span><br><span class="line">		: <span class="built_in">Base</span>(a), <span class="built_in">Base1</span>(a), <span class="built_in">Base2</span>(a), <span class="built_in">var3</span>(a + <span class="number">4</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base12: &quot;</span> &lt;&lt; var3 &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base21</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base1, <span class="keyword">virtual</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var4;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base21</span>(<span class="type">int</span> a)</span><br><span class="line">		: <span class="built_in">Base</span>(a), <span class="built_in">Base1</span>(a), <span class="built_in">Base2</span>(a), <span class="built_in">var4</span>(a + <span class="number">5</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base21: &quot;</span> &lt;&lt; var4 &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base12, <span class="keyword">public</span> Base21</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>(<span class="type">int</span> a)</span><br><span class="line">		: <span class="built_in">Base</span>(a), <span class="built_in">Base1</span>(a), <span class="built_in">Base2</span>(a), <span class="built_in">Base12</span>(a), <span class="built_in">Base21</span>(a), <span class="built_in">var5</span>(a + <span class="number">6</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived: &quot;</span> &lt;&lt; var5 &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; d.var0 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d.var1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d.var2 &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">		&lt;&lt; d.var3 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d.var4 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d.var5 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	d.<span class="built_in">Func</span>();</span><br><span class="line">	std::cin.<span class="built_in">ignore</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始没有给二级继承加上 <code>virtual</code>
关键字，结果编译器报错：<code>"indirect nonvirtual base class is not allowed"</code>，即间接继承非虚基类是不被允许的，在代码中的体现就是最远派生类
<code>Derived</code> 间接继承了两个二级基类 <code>Base1</code>和
<code>Base2</code>，但是他们并不是虚基类，因此不通过。</p>
<p>将二级继承改成虚继承/ 二级基类改成虚基类之后运行就正常了：</p>
<p><img src="derived2.png" alt="三级继承中的虚基类"></p>
<h4 id="不可被继承的类">不可被继承的类</h4>
<p>在类名后面加上 <code>final</code>
关键字，即声明该类为不可被继承的类，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> <span class="keyword">final</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单例类-singleton">单例类 Singleton</h3>
<h4 id="介绍">介绍</h4>
<p>顾名思义，Singleton就是有且只能有一个实例的类，而且这个实例必须在类的内部完成构造，并提供全局访问的接口；在C++中，Singleton是一种整合若干全局静态变量和操作这些变量的静态函数的手段，使用的方式与命名空间很像；</p>
<h4 id="特点">特点</h4>
<p>只需一个实例，所以不能向外界提供构造函数接口，因此需要私有化空的构造函数，同时<strong>禁止继承</strong>；</p>
<p>为了防止唯一的实例被拷贝，例如
<code>Singleton instance = Singleton::Get();</code>，需要删除拷贝构造函数，删除之后外界只能通过引用的形式创建，如<code>auto&amp; instance = Singleton::Get()</code>，然后通过<code>instance.Function()</code>的形式来调用方法；</p>
<p>为了避免 <code>Singleton::Get().Float()</code>
这样的调用形式出现，或者要省去创建一个引用的步骤，可以另写一个静态方法如<code>Float()</code>，在该方法内进行<code>Get()</code>操作并调用相应方法，在外部以<code>Singleton::Float()</code>的形式调用即可。</p>
<p>由于类的静态成员变量需要在类内部声明，并在某个翻译单元中定义，就会在类的外部多一个<code>Random Random::instance;</code>的定义语句，为了在形式上统一，可以直接把定义的语句放到静态方法<code>Get()</code>内部，并删除private内的定义，使其成为一个类内部的局部静态变量，这样一来只会在第一次调用<code>Get</code>时进行初始化，以后每一次调用都返回上一次更新后的<code>instance</code>；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Random</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Random&amp; <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Random instance; <span class="comment">//首次调用时创建</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Random</span>(<span class="type">const</span> Random&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">Float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Get</span>().<span class="built_in">IFloat</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Random</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">IFloat</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_RandomGenerator; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> m_RandomGenerator = <span class="number">0.5f</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> number = Random::<span class="built_in">Float</span>();</span><br><span class="line">    cout &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例类与命名空间">单例类与命名空间</h4>
<p>实际上，像上述那样定义一个Singleton，与使用命名空间在形式和效果上都是完全一样的，举个例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> RandomClass </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> m_RandomGenerator = <span class="number">0.5f</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">Float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_RandomGenerator; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; RandomClass::<span class="built_in">Float</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然使用命名空间可以达到一样的效果，还要单例类干什么?</p>
<p>单例类与命名空间一样都是很好的工具。但是当变量和方法比较多的时候，用命名空间的形式写起来会比较散乱，并且当函数内容比较丰富时，就不能像上面这样以内联形式定义了，必须把定义部分放到空间外的某个翻译单元中去，否则会造成资源浪费。此时单例类的集成优势就比较明显了。</p>
<h3 id="运算符重载">运算符重载</h3>
<h4 id="重载运算符的目的">重载运算符的目的</h4>
<p><strong>核心目的：使用原有的运算符操作自定义数据类型；</strong></p>
<p>比如我们从自己定义的类中实例化了两个对象，我们需要一个函数来实现两个对象之间对应数据的四则运算，或者是需要通过ostream输出流与右移运算符
<code>&lt;&lt;</code>
直接输出这个类的数据，但是原有的运算符并不能接受自定义的数据类型，所以这样的功能需要我们自己实现，可以通过重载的方式达到目的。既然是重载，那么就意味着保留原有的性质，只是增添了一个处理方案；</p>
<h4 id="运算符按目数分类">运算符按目数分类</h4>
<p><strong>单目运算符：</strong>运算所需变量为一个的运算符，也叫一元运算符，常见种类如下：</p>
<ul>
<li>自增运算符：<code>++</code></li>
<li>自减运算符：<code>--</code></li>
<li>负号运算符：<code>-</code></li>
<li>逻辑非运算符：<code>!</code></li>
<li>按位取反运算符：<code>~</code></li>
<li>指针运算符：<code>*</code></li>
<li>取址运算符：<code>&amp;</code></li>
<li>括号运算符：<code>()</code></li>
<li>强制类型转换运算符：<code>(T)</code>、<code>Cast</code></li>
<li>计算变量大小运算符：<code>sizeof</code></li>
</ul>
<p><strong>双目运算符：</strong>对两个变量进行操作的运算符，也叫二元运算符，常见种类如下：</p>
<ul>
<li><p>初等运算符</p>
<ul>
<li>下标运算符：<code>[]</code></li>
<li>分量运算符/箭头运算符：<code>-&gt;</code></li>
<li>类/结构体成员运算符：<code>.</code></li>
</ul></li>
<li><p>算数运算符</p>
<ul>
<li><p>加法运算符：<code>+</code></p></li>
<li><p>减法运算符：<code>-</code></p></li>
<li><p>乘法运算符：<code>*</code></p></li>
<li><p>除法运算符：<code>/</code></p></li>
<li><p>取余运算符：<code>%</code></p></li>
</ul></li>
<li><p>关系运算符：</p>
<ul>
<li>等于运算符：<code>==</code></li>
<li>不等于运算符：<code>!=</code></li>
<li>大于、大于等于运算符：<code>&gt;</code>，<code>&gt;=</code></li>
<li>小于、小于等于运算符：<code>&lt;</code>，<code>&lt;=</code></li>
</ul></li>
<li><p>逻辑运算符</p>
<ul>
<li>逻辑与运算符：<code>&amp;&amp;</code></li>
<li>逻辑或运算符：<code>||</code></li>
</ul></li>
<li><p>位运算符</p>
<ul>
<li>按位与运算符：<code>&amp;</code>，有0则0，无0为1</li>
<li>按位并运算符：<code>|</code>，有1则1，无1为0</li>
<li>按位异或运算符：<code>^</code>，同0异1</li>
<li>左移运算符：<code>&lt;&lt;</code>，丢弃移出去的位，移入的空位默认补0</li>
<li>右移运算符：<code>&gt;&gt;</code>，同上</li>
</ul></li>
<li><p>赋值运算符</p>
<ul>
<li>一系列赋值运算符：<code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&gt;&gt;=</code>、<code>&lt;&lt;=</code>、<code>&amp;=</code>、<code>|=</code>、<code>^=</code></li>
</ul></li>
<li><p>逗号运算符：<code>,</code></p></li>
<li><p>作用域解析运算符：<code>::</code></p></li>
</ul>
<p><strong>三目运算符：</strong>对三个变量进行操作的运算符，也叫三元运算符</p>
<ul>
<li>格式：<code>&lt;condition&gt; ? &lt;var1&gt; : &lt;var2&gt;</code>，其执行逻辑等价于：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)</span><br><span class="line">    left = var1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    left = var2;</span><br></pre></td></tr></table></figure>
<p>还可以有套娃用法：<code>left = &lt;condition1&gt; ? (&lt;condition2&gt; ? var1 : var2) : var3</code>，逻辑等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition2)</span><br><span class="line">        left = var1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left = var2;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    left = var3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运算符重载的基本规则">运算符重载的基本规则</h4>
<ul>
<li>C++几乎可以重载所有的运算符，但只能重载已有的运算符，不可以自己创建；</li>
<li>不可重载的运算符有：<code>.</code> 、<code>.*</code>
、<code>::</code> 、<code>?:</code></li>
<li>重载之后运算符的优先级和结合性都不会改变；</li>
<li>运算符通常重载为类的非静态成员函数，比如
<code>+</code>，或者重载为非成员函数，比如 <code>&lt;&lt;</code>；</li>
<li>参数个数=原操作数个数-1（后置<code>++</code>和<code>--</code>除外）</li>
<li>重载 <code>=</code>、<code>[]</code>
时应该返回一个左值，即以引用形式返回</li>
</ul>
<h4 id="重载运算符的例子">重载运算符的例子</h4>
<h5 id="重载双目运算符为成员函数">重载双目运算符为成员函数</h5>
<p>双目运算符即二元运算符，其参数个数等于操作数减一，即2-1=1</p>
<p>假设二元运算符为 <code>+</code> ，重载后，表达式
<code>entity1 + entity2</code> 等价于
<code>entity1.operator+(entity2)</code></p>
<p>结构体<code>Vector2</code>中保存了两个float成员<code>x</code>和<code>y</code>，现在需要实现用该结构体定义的变量进行对应数据的加法和乘法运算。在不进行运算符重载的情况下，只能定义<code>Add</code>和<code>Multiply</code>两个方法，通过<code>result = position.Add(speed.Multiply(powerup));</code>的方式实现<code>position + speed * powerup</code>的运算。其中
<code>&#123;x + other.x, y + other.y&#125;</code>相当于
<code>Vector2(x + other.x, y + other.y)</code>；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="type">float</span> x, <span class="type">float</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function">Vector2 <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + other.x, y + other.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Vector2 <span class="title">Multiply</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * other.x, y * other.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Vector2 <span class="title">position</span><span class="params">(<span class="number">4.0f</span>, <span class="number">4.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">speed</span><span class="params">(<span class="number">0.5f</span>, <span class="number">1.5f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">powerup</span><span class="params">(<span class="number">1.1f</span>, <span class="number">1.1f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Vector2 result = position.<span class="built_in">Add</span>(speed.<span class="built_in">Multiply</span>(powerup));</span><br><span class="line">    std::cout &lt;&lt; result.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; result.y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别将二元运算符 <code>+</code> 和 <code>*</code> 重载为结构体
<code>Vector2</code> 的非静态成员函数，并将左移运算符
<code>&lt;&lt;</code> 重载为非成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="type">float</span> x, <span class="type">float</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    Vector2 <span class="keyword">operator</span>+ (<span class="type">const</span> Vector2&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + other.x, y + other.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Vector2 <span class="keyword">operator</span>* (<span class="type">const</span> Vector2&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * other.x, y * other.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; stream, <span class="type">const</span> Vector2&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; other.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; other.y;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Vector2 <span class="title">position</span><span class="params">(<span class="number">4.0f</span>, <span class="number">4.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">speed</span><span class="params">(<span class="number">0.5f</span>, <span class="number">1.5f</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">powerup</span><span class="params">(<span class="number">1.1f</span>, <span class="number">1.1f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Vector2 result = position + speed * powerup;</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5
id="重载单目自增自减运算符为成员函数">重载单目自增自减运算符为成员函数</h5>
<p>重载为类的成员函数的单目运算符，它的操作数只能是该类的<strong>一个实例</strong></p>
<p>单目运算符的操作数为1，即理论上不需要参数，但有例外，见如下面的例子</p>
<p>重载单目运算符时需特别注意自增 <code>++</code> 和自减 <code>--</code>
两个运算符是前置还是后置：</p>
<ul>
<li>前置，即实现 <code>++ entity</code> 或
<code>-- entity</code>，需要重载为类的成员函数才可实现。经重载后，表达式
<code>++ entity</code> 相当于 <code>entity.operator++()</code></li>
<li>后置，即实现 <code>entity ++</code> 或
<code>entity --</code>，不仅需要重载为类的成员函数，而且需要一个
<code>int</code>
类型的形参，该参数只用于区分前置和后置，在函数中不可也无法使用。经重载后，表达式
<code>entity ++</code> 相当于 <code>entity.operator ++(0)</code></li>
</ul>
<p><strong>例子</strong>：钟表类，重置前置++和后置++位成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> hour, minute, second;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Clock</span>() : <span class="built_in">Clock</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">Clock</span>(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">// 前置</span></span><br><span class="line">	Clock&amp; <span class="keyword">operator</span>++ ();</span><br><span class="line">	<span class="comment">// 后置</span></span><br><span class="line">	Clock <span class="keyword">operator</span>++ (<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::<span class="built_in">Clock</span>(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (hour &gt;= <span class="number">0</span> &amp;&amp; hour &lt;= <span class="number">24</span></span><br><span class="line">		&amp;&amp; minute &gt;= <span class="number">0</span> &amp;&amp; minute &lt; <span class="number">60</span></span><br><span class="line">		&amp;&amp; second &gt;= <span class="number">0</span> &amp;&amp; second &lt; <span class="number">60</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;hour = hour;</span><br><span class="line">		<span class="keyword">this</span>-&gt;minute = minute;</span><br><span class="line">		<span class="keyword">this</span>-&gt;second = second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Time error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clock::showTime</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置</span></span><br><span class="line">Clock&amp; Clock::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">	second++;</span><br><span class="line">	<span class="keyword">if</span> (second &gt;= <span class="number">60</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		second -= <span class="number">60</span>;</span><br><span class="line">		minute++;</span><br><span class="line">		<span class="keyword">if</span> (minute &gt;= <span class="number">60</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			minute -= <span class="number">60</span>;</span><br><span class="line">			hour = (hour + <span class="number">1</span>) % <span class="number">24</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置</span></span><br><span class="line">Clock Clock::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Clock old = *<span class="keyword">this</span>;  <span class="comment">// 调用Copy</span></span><br><span class="line">	++(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> old;  <span class="comment">// 调用Destructor， 没有调用Copy，返回的是啥？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Clock <span class="title">myClock</span><span class="params">(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;First time output: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	myClock.<span class="built_in">showTime</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Show myClock++: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	(myClock++).<span class="built_in">showTime</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Show ++myClock: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	(++myClock).<span class="built_in">showTime</span>();</span><br><span class="line">	std::cin.<span class="built_in">ignore</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="clock_normal.png" alt="myClock正常运行"></p>
<p>代码中可见，重载前置运算符时对成员变量做了相应的操作，并返回经过修改的<strong>已存在的</strong>实例，而重载后置运算符时则是在函数体内部创建了一个新的
<code>Clock</code> 实例并返回，这里有一个比较容易忽视的问题：</p>
<p>我在看这段代码时，对前置返回值加引用，而后置返回值不加引用产生了疑惑，当时也没多想，以为只是为了省略资源而加的，就随手给后置的返回值也加了引用，结果后置的运行结果变得无厘头，如下：</p>
<p><img src="clock_error.png" alt="myClock异常"></p>
<p>后来仔细一想，出大问题！</p>
<p>我们知道，从一个函数中以值的形式返回一个实例，执行
<code>return old;</code>
时，编译器会首先调用拷贝构造函数或移动构造函数（二者都存在就调用移动构造）用原有的实例
<code>old</code>
的资源复制出一份临时对象，再调用析构函数销毁在栈上实例化的原对象
<code>old</code>，问题就出在这里，函数返回的对象看上去是
<code>old</code>，实际上是拷贝出来的临时对象，而在函数内创建的
<code>old</code>
在拷贝完成时就已经被析构掉了，如果我们返回的是个引用，那么相当于返回了一个指向一块已经被释放了的内存的指针，自然输出的结果是离谱的；</p>
<p>验证我们分析得是否正确的方式很简单，在拷贝构造函数和析构函数中分别输出相应的信息就行，但要格外注意，拷贝构造函数不能只写一个
<code>std::cout</code>，因为写出来的拷贝构造函数会覆盖默认的拷贝构造函数，必须把拷贝的过程写出来，可用初始化列表完成；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Clock</span>(<span class="type">const</span> Clock&amp; other)</span><br><span class="line">	: <span class="built_in">hour</span>(other.hour), <span class="built_in">minute</span>(other.minute), <span class="built_in">second</span>(other.second)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Clock</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br></pre></td></tr></table></figure>
<p>然后注释掉 <code>main</code> 函数中调用后置++之外的语句，只留下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Clock <span class="title">myClock</span><span class="params">(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Show myClock++: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	(myClock++).<span class="built_in">showTime</span>();</span><br><span class="line">    std::cin.<span class="built_in">ignore</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再运行，结果如下：</p>
<p><img src="clock_debug.png" alt="debugClock"></p>
<p>其中第一次 Copied 发生在 <code>Clock old = *this;</code>，将
<code>*this</code> 的资源拷贝给 <code>old</code>，第二次发生在
<code>return old;</code> ，将 <code>old</code>
的资源拷贝给临时对象；因为 <code>Clock</code> 成员简单，只有三个
<code>int</code>
数据，没有指针成员变量，所以没必要用移动构造函数了；</p>
<p>如果还想折腾一下，非得给后置++的重载加个返回引用有没有办法呢？答案是有的，只要在堆上实例化，<code>old</code>
就不会在程序执行出函数scope的时候被销毁，最简单的方式就是用
<code>new</code> 创建实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Clock&amp; Clock::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Clock* old = <span class="keyword">new</span> <span class="built_in">Clock</span>(*<span class="keyword">this</span>); </span><br><span class="line">	++(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> *old;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样只执行
<code>(myClock++).showTime();</code>，运行结果就正确了：</p>
<p><img src="clock_new.png" alt="newClock"></p>
<p>但是用 <code>new</code>
需要格外注意在适当的时候回收指针并释放内存，否则会造成内存泄漏。这样的运行结果显然没有释放掉创建的实例，又因为它是以引用而非指针的形式返回，我想了好一会，尝试了一些手段，也不知道怎么在保持返回引用的前提下，能让他释放掉
<code>old</code> 的内存，最后还是把返回类型改成了指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Clock* Clock::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Clock* old = <span class="keyword">new</span> <span class="built_in">Clock</span>(*<span class="keyword">this</span>); </span><br><span class="line">	++(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> old;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Clock <span class="title">myClock</span><span class="params">(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> p = myClock++;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	p = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过其实用智能指针就行了，何必用 <code>new</code> 呢：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Clock&gt; Clock::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::unique_ptr&lt;Clock&gt; old = std::<span class="built_in">make_unique</span>&lt;Clock&gt;(*<span class="keyword">this</span>);</span><br><span class="line">	++(*<span class="keyword">this</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;old: &quot;</span> &lt;&lt; old &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> old;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Clock <span class="title">myClock</span><span class="params">(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>)</span></span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> p = myClock++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上scope是为了更好地看出 <code>unique_ptr</code>
的自动回收功能，在p失效后立刻销毁 <code>old</code>，结果如下：</p>
<p><img src="clock_unique.png" alt="uniqueClock"></p>
<h5
id="重载单目括号运算符单目指针运算符单目强制类型转换运算符为成员函数">重载单目括号运算符、单目指针运算符、单目强制类型转换运算符为成员函数</h5>
<p>一定要分清这三个单目运算符以及他们的重载形式和调用形式：</p>
<ul>
<li>单目括号运算符：<code>()</code>，重载形式
<code>[Type] operator()();</code>，调用形式 <code>entity()</code></li>
<li>单目指针运算符：<code>*</code>，重载形式
<code>Type operator*();</code>，调用形式 <code>*entity</code></li>
<li>单目强制类型转换运算符：<code>(Type)</code>，重载形式
<code>operator Type();</code>，调用形式 <code>(Type)entity</code></li>
</ul>
<p>例子：三个运算符的作用分别为如下</p>
<ol type="1">
<li>单目括号运算符 <code>()</code>：当操作数为 <code>Entity</code>
对象时，返回对象成员 <code>int value</code> 的值</li>
<li>单目指针运算符 <code>*</code>：当操作数为 <code>Entity</code>
对象时，返回对象指针成员 <code>float* fvalue</code> 指向的值</li>
<li>单目强制类型转换运算符：<code>(int)</code>：当操作数为
<code>Entity</code> 对象时，允许 <code>(int)entity</code> 的强制转换
，将对象名 <code>entity</code> 强制转换为 <code>int</code>，返回对象成员
<code>int value</code> 的值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span>* fvalue;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">value</span>(<span class="number">10</span>), <span class="built_in">fvalue</span>(<span class="keyword">new</span> <span class="built_in">float</span>(<span class="number">1.2</span>)) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123; <span class="keyword">delete</span> fvalue; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载单目括号运算符 ()</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span> <span class="params">()</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载单目指针运算符 *</span></span><br><span class="line">    <span class="type">float</span> <span class="keyword">operator</span> *();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载单目强制类型转换运算符 (int)</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Entity::operator</span> <span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Calling operator () : &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Entity::<span class="keyword">operator</span> * () </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Calling operator * : &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> *fvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Entity::<span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Calling operator int : &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity entity;</span><br><span class="line">    std::cout &lt;&lt; (<span class="type">int</span>)entity &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">entity</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *entity &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="reload debug.png" alt=""></p>
<h5 id="重载运算符为非成员函数">重载运算符为非成员函数</h5>
<p>除了遵守上面的基本规则之外，重载为非成员函数还需要遵守特别的规则：</p>
<ul>
<li>函数的形参表示从左到右排列的操作数</li>
<li>至少要有一个自定义类型的参数</li>
<li>重载后置单目运算符 <code>++</code> 和 <code>--</code> 仍需要加一个
<code>int</code> 形参</li>
<li>需要操作类对象的私有成员时，声明为该类的友元函数</li>
</ul>
<p>重载为类的非成员函数后的等价形式：</p>
<ul>
<li>双目运算符：<code>oprd1 B oprd2</code> 等价于
<code>operator B(oprd1, oprd2)</code></li>
<li>前置单目运算符：<code>B oprd</code> 等价于
<code>operator B(oprd)</code></li>
<li>后置单目运算符：<code>oprd B</code> 等价于
<code>operator B(oprd, 0)</code></li>
</ul>
<p><strong>例子：</strong>重载 <code>Complex</code> 的加减法和
<code>&lt;&lt;</code> 运算符为非成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> real;  <span class="comment">// 实部</span></span><br><span class="line">	<span class="type">double</span> imag;  <span class="comment">// 虚部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">double</span> r=<span class="number">0.0</span>, <span class="type">double</span> i = <span class="number">0.0</span>)</span><br><span class="line">		: <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i)&#123;&#125;</span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+ (<span class="type">const</span> Complex&amp; c1, <span class="type">const</span> Complex&amp; c2);</span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>- (<span class="type">const</span> Complex&amp; c1, <span class="type">const</span> Complex&amp; c2);</span><br><span class="line">	<span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; out, <span class="type">const</span> Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+ (<span class="type">const</span> Complex&amp; c1, <span class="type">const</span> Complex&amp; c2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; c1.real + c2.real, c1.imag + c2.imag &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>- (<span class="type">const</span> Complex&amp; c1, <span class="type">const</span> Complex&amp; c2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; c1.real - c2.real, c1.imag - c2.imag &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; out, <span class="type">const</span> Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">5</span>, <span class="number">4</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">2</span>, <span class="number">10</span>)</span>, c3</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;c1: &quot;</span> &lt;&lt; c1 &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;c2: &quot;</span> &lt;&lt; c2 &lt;&lt; std::endl;</span><br><span class="line">	c3 = c1 - c2;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;c3: &quot;</span> &lt;&lt; c3 &lt;&lt; std::endl;</span><br><span class="line">	c3 = c1 + c2;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;c3: &quot;</span> &lt;&lt; c3 &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">ignore</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="overload.png" alt="重载为非成员函数"></p>
<h3 id="this指针与箭头操作符-">this指针与箭头操作符-&gt;</h3>
<h4 id="this指针">this指针</h4>
<p><code>this</code>
指向调用它的实例，属于<code>*const</code>类型的指针，即地址不可修改；</p>
<p><code>this</code>
指针是默认调用的，不论是否在代码中写出来，明确写出来通常是为了视觉上更直观地分辨类成员与形参；</p>
<p><code>this-&gt;var</code> 相当于 <code>(*this).var</code>；</p>
<h4 id="箭头操作符--">箭头操作符 -&gt;</h4>
<p>箭头操作符（array operator）<code>-&gt;</code>
为指向一个实例的指针提供直接调用内部成员的功能。它的机制相当于是对指针进行解引用，再使用解引用后的实例调用方法或变量，例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">	Entity* ptr = &amp;e;</span><br><span class="line">	<span class="comment">// 箭头操作符</span></span><br><span class="line">	ptr-&gt;<span class="built_in">Print</span>();</span><br><span class="line">	<span class="comment">// 箭头操作符的等价形式一</span></span><br><span class="line">	Entity&amp; entity = *ptr;</span><br><span class="line">	entity.<span class="built_in">Print</span>();</span><br><span class="line">	<span class="comment">// 箭头操作符的等价形式二</span></span><br><span class="line">	(*ptr).<span class="built_in">Print</span>();</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头操作符支持重载，一般在类内部含有其他类的实例并且需要调用其他类的方法时重载<code>-&gt;</code>，方法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Second</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Entity* m_Obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Second</span>(Entity* entity) : <span class="built_in">m_Obj</span>(entity) &#123;&#125;</span><br><span class="line">	~<span class="built_in">Second</span>() &#123; <span class="keyword">delete</span> m_Obj; &#125;</span><br><span class="line">	Entity* <span class="keyword">operator</span>-&gt; () &#123; <span class="keyword">return</span> m_Obj; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Second <span class="title">second</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line">	second-&gt;<span class="built_in">Print</span>();  <span class="comment">// 实现了直接调用所包含的Entity实例的Print方法</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：利用箭头运算符获取连续数据系列中某一个值在内存中的相对偏移量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> offset = (<span class="type">int</span>)&amp;((Vector3*)<span class="literal">nullptr</span>)-&gt;x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const-关键字">const 关键字</h2>
<h3 id="修饰普通变量">修饰普通变量</h3>
<p><code>const</code>用于设定一个值不可修改的变量，如<code>const int A = 5;</code>被修饰的变量无法进行修改，任何<code>a = 10</code>之类的修改都会报错。</p>
<p>另外，用强制类型转换的指针可以获取<code>const</code>变量的地址，比如<code>int* ptr = (int*)&amp;A</code>，但对指针的值进行修改，如<code>*ptr = 3</code>仍然不会改变A的值。</p>
<h3 id="修饰指针">修饰指针</h3>
<p>区分<code>const</code>是加在<strong>地址</strong>上还是加在<strong>地址的内容</strong>上的方法：看<code>const</code>位于指针符号<code>*</code>的左侧或右侧，<strong>左侧针对内容，右侧针对地址；</strong></p>
<p><code>const</code>在左侧时，与指针类型的没有顺序之分，下面二者完全等价，看个人风格选择：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<h3 id="修饰类的成员">修饰类的成员</h3>
<p>当<code>const</code>
用于修饰类的成员变量时，也是简单的不可被修改，通常情况下既不能在public的情况下被外部修改，也不能被内部的函数修改，但是有个例外，下文会提到。</p>
<p>当<code>const</code>用于修饰类的成员函数时，表明该函数不会对任何成员变量进行值改动：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_X; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; m_X = x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_X;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于类的方法而言，<code>const</code>不仅仅限制了其不能对成员变量进行修改，还在外部函数为了避免深拷贝而进行<code>const Entity&amp; e</code>引用调用实例时允许使用该方法。如果没有<code>const</code>修饰，则以浅拷贝的形式调用<code>e</code>无法使用<code>Get</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123; m_X = <span class="number">10</span>; &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_X; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; m_X = x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_X;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(<span class="type">const</span> Entity&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">GetX</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="built_in">Function</span>(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在外部函数调动了一个实例但是不需要修改实例中的重要数据时，为了避免资源浪费我们通常使用带<code>const</code>的浅拷贝方式对实例进行调用，意味着需要给所有需要使用的方法加上<code>const</code>限制，这样同时也产生了一些工程上的不便，例如为了Debug需要，在类内部添加了一个仅用于调式的数据，但是由于<code>const</code>的限制导致了这个数据也不能修改，为了解决这个问题，可以使用<code>mutable</code>关键字定义那些需要指定为可修改的成员变量，如下所示，带<code>const</code>限制的方法<code>Get</code>可修改带<code>mutable</code>标识的成员<code>m_x</code>；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123; m_X = <span class="number">10</span>; &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_X += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> m_X; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; m_X = x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_X;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="static-与-extern">static 与 extern</h2>
<h3 id="static-静态变量函数">static 静态变量/函数</h3>
<p><strong>全局</strong>静态变量：只会在定义所在的文件内部被链接，作用域为文件内部全局，生命周期与整个程序同步，即在整个程序结束时才被释放。</p>
<p><strong>局部</strong>静态变量：作用域为其所属函数、逻辑控制区域等代码块，生命周期与整个程序同步，即程序运行至该代码块之外时，它也不会被释放，如果程序结束之前再次执行该代码块，它就保持上一次离开该代码块时的值。同时static局部变量在外部无法访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 局部静态变量，第一次调用时被初始化</span></span><br><span class="line">	i++;  <span class="comment">// 递增并保留结果直到下一次调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类或结构体<strong>之内</strong>的静态成员变量严格上来说既不属于类或结构体，又不属于任何实例，因为它们被所有的实例共享，并且在使用这些变量<strong>之前</strong>，需要以命名空间的形式定义它们，如<code>int classTest::var = 1</code>;</p>
<p>静态的成员方法不能调用非静态的成员变量，因为类/结构体的<code>non-static</code>成员函数必须被实例所调用，而在被调用时，会隐式地将这个实例作为一个参数传递给该函数使用。</p>
<p>举个例子就很好理解，在成员变量和参数的变量名比较相似时，为了防止视觉混淆，我们常常使用<code>this</code>指针来说明是成员变量而非参数变量，其实这个<code>this</code>是可写可不写的，因为当你调用了一个与成员变量同名的变量，它默认会指向这个实例的内部，也就是说<code>this</code>本来就是存在的。而静态方法不属于任何一个实例，也不需要提前生成一个实例，自然就没有隐式参数，<code>this</code>指针也就无效了，所以静态函数无法使用<code>this</code>指针。强行调用会出现
<code>illegal reference to non-static member xxx</code>指明所调用变量是未定义或未知的错误。</p>
<h3 id="extern-全局变量函数">extern 全局变量/函数</h3>
<p>与Static正好相反，extern变量或函数可被其他文件链接，但只可被定义一次，其他文件调用之前也需要声明。</p>
<h2 id="枚举类型">枚举类型</h2>
<p>枚举类型关键字<code>enum</code>一般用于需要使用几个<strong>整数</strong>来表示一些状态量的情况，必须是<strong>整数</strong>。</p>
<p>创建枚举<strong>类型</strong>的方式很简单，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">COLOR</span> &#123;BLUE, GREEN, RED&#125;;</span><br></pre></td></tr></table></figure>
<p>在不指定对应数值的情况下，默认第一个值为0，并依次递增，也就是<code>BLUE=0, GREEN=1, RED=2</code></p>
<p>指定数值时也可以指定<strong>整数</strong>的类型（char, short, int,
long, long long 以及它们的unsigned形式）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">STATUS</span> : <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">&#123;</span><br><span class="line">    Off = <span class="number">0</span>, On,</span><br><span class="line">    Warning = <span class="number">5</span>, Error</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STATUS status = Error;</span><br><span class="line">    cout &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此例中，创建了枚举<strong>类型</strong><code>STATUS</code>，枚举<strong>变量</strong><code>status</code>，其中<code>Off=0</code>，<code>On=1</code>，<code>Warning=5</code>，<code>Error=6</code>，并指定了<code>status=Error</code>，因此程序输出的结果为：6</p>
<h2 id="模板-template">模板 template</h2>
<h3 id="函数模板">函数模板</h3>
<p><strong>简述：</strong>函数模板是创建<strong>通用</strong>函数的一种手段，某种程度上相当于函数的重载，但避免了函数体的重复设计；</p>
<p><strong>特点：</strong>函数模板在编译时是“不存在”的，它只是个用于生成函数的模板，只有在实际调用它的时候才会根据模板实参生成数据类型确定的函数，由函数模板生成的函数就叫模板函数；</p>
<p><strong>定义：</strong>函数模板的定义方式如下，其中关键字
<code>typename</code> 可以用关键字 <code>class</code>
替换，二者是等价的，但是这里的 <code>class</code>
不同于类的关键字，只表示类型形参，比较容易引起歧义，因此习惯上用
<code>typename</code> 较好理解；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用：</strong>可用 <code>&lt;&gt;</code>
指明模板实参的数据类型，也可省略直接；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Print</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">Print</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h3 id="类模板">类模板</h3>
<h4 id="基本类模板">基本类模板</h4>
<p>与函数模板基本同理，见例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T m_Array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Array&lt;std::string, <span class="number">5</span>&gt; array;</span><br><span class="line">	std::cout &lt;&lt; array.<span class="built_in">GetSize</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组类模板">数组类模板</h4>
<p>利用数组类模板写一个动态数组类Array：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* list;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Array</span>(<span class="type">int</span> sz = <span class="number">50</span>);</span><br><span class="line">	<span class="built_in">Array</span>(<span class="type">const</span> Array&lt;T&gt;&amp; a);</span><br><span class="line">	~<span class="built_in">Array</span>();</span><br><span class="line">	Array&lt;T&gt;&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Array&lt;T&gt;&amp; rhs);</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[] (<span class="type">int</span> i);</span><br><span class="line">	<span class="type">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line">	<span class="keyword">operator</span> T* ();</span><br><span class="line">	<span class="keyword">operator</span> <span class="type">const</span> T* () <span class="type">const</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> sz)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">Array&lt;T&gt;::<span class="built_in">Array</span>(<span class="type">int</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">assert</span>(sz &gt;= <span class="number">0</span>);</span><br><span class="line">	size = sz;</span><br><span class="line">	list = <span class="keyword">new</span> T[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt;::~<span class="built_in">Array</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[] list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt;::<span class="built_in">Array</span>(<span class="type">const</span> Array&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">	size = other.size;</span><br><span class="line">	list = <span class="keyword">new</span> T[size];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">		list[i] = other.list[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载拷贝赋值运算符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">Array&lt;T&gt;&amp; Array&lt;T&gt;::<span class="keyword">operator</span>= (<span class="type">const</span> Array&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (&amp;other != <span class="keyword">this</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (size != other.size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] list;</span><br><span class="line">			size = other.size;</span><br><span class="line">			list = <span class="keyword">new</span> T[size];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">			list[i] = other.list[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载下标运算符，不带const</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Array&lt;T&gt;::<span class="keyword">operator</span>[] (<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">assert</span>(n &gt;= <span class="number">0</span> &amp;&amp; n &lt; size);</span><br><span class="line">	<span class="keyword">return</span> list[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载下标运算符，带const</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T&amp; Array&lt;T&gt;::<span class="keyword">operator</span>[] (<span class="type">int</span> n) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">assert</span>(n &gt;= <span class="number">0</span> &amp;&amp; n &lt; size);</span><br><span class="line">	<span class="keyword">return</span> list[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载强制类型转换运算符，将Array对象名转化为T*</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt;::<span class="keyword">operator</span> T* ()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前数组的大小</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Array&lt;T&gt;::<span class="built_in">getSize</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置数组大小</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Array&lt;T&gt;::<span class="built_in">resize</span>(<span class="type">int</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">assert</span>(sz &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sz == size)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	T* newList = <span class="keyword">new</span> T[size];</span><br><span class="line">	<span class="type">int</span> n = (sz &lt; size) ? sz : size;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		newList[i] = list[i];</span><br><span class="line">	<span class="keyword">delete</span>[] list;</span><br><span class="line">	list = newList;</span><br><span class="line">	size = sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		std::cin &gt;&gt; p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// size == 10</span></span><br><span class="line">	<span class="built_in">read</span>(a, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">		std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	std::cin.<span class="built_in">ignore</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程">多线程</h2>
<blockquote>
<p>#include &lt;thread&gt;</p>
</blockquote>
<p><strong>创建子线程：</strong><code>std::thread a(*F)</code>，a为子线程变量名，接收的参数为一个函数指针；线程创建后即刻与父线程同步运行；</p>
<p><strong>父线程锁：</strong><code>a.join()</code>，其功能是暂停父线程，等待子线程运行完成后再继续运行父线程；</p>
<p><strong>获取线程id：</strong><code>std::this_thread::get_id()</code></p>
<p><strong>线程内延时函数：</strong>命名空间
<code>std::literals::chrono_literals</code>，函数<code>std::this_thread::sleep_for(1s);</code>
示例参数表示延时1s；</p>
<p>代码示例：</p>
<ul>
<li><strong>CMakeLists：</strong><code>set (CMAKE_CXX_FLAGS "$&#123;CMAKE_CXX_FLAGS&#125; -pthread")</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> s_Finished = <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals; </span><br><span class="line">    <span class="keyword">while</span>(!s_Finished) </span><br><span class="line">    &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working...&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">        <span class="comment">// 延时1s </span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 父线程 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子线程，创建时立刻与父线程同步运行</span></span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(DoWork)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双线程同步运行时属于父线程的两行</span></span><br><span class="line">    <span class="comment">// 等待按键是为了不让s_Finished立刻变成true导致子线程一下就执行完了，便于更加直观查看运行结果</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>(); </span><br><span class="line">    s_Finished = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行本行时锁住父线程，不再往下执行，直到子线程结束 </span></span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回到父线程 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; </span><br><span class="line">    std::cin.<span class="built_in">get</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计时器">计时器</h2>
<p><strong>ctime库</strong>：<code>clock()</code>
获取当前时刻的CLOCK数，使用区间CLOCK数除以<code>CLOCKS_PER_SEC</code>
可得持续时长。用clock封装一个计时器如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> start, end, duration;</span><br><span class="line">    <span class="built_in">Timer1</span>() <span class="comment">/*NOLINT*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        start = <span class="built_in">clock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Timer1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        end = <span class="built_in">clock</span>();</span><br><span class="line">        duration = (end - start) / CLOCKS_PER_SEC * <span class="number">1000</span>;  <span class="comment">// 默认单位：秒</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Timer1 took &quot;</span> &lt;&lt; duration &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>chrono库：</strong>利用<code>high_resolution_clock</code>
可进行<strong>精度更高</strong>的定时</p>
<p>封装两个计时器，区别在于使用
<code>std::chrono::duration&lt;&gt;</code> 与进行一个
<code>time_point_cast</code> 强制转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用std::chrono::duration</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer2</span></span><br><span class="line">&#123;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start, end;</span><br><span class="line">    std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line">    <span class="built_in">Timer2</span>() <span class="comment">/*NOLINT*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Timer2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        duration = end - start;</span><br><span class="line">        <span class="type">float</span> ms = duration.<span class="built_in">count</span>() * <span class="number">1000.0f</span>;  <span class="comment">// duration默认单位：秒</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Timer2 took &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用time_point_cast强制转换time_point类对象至long long类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Timer</span>() &#123; m_StartTimePoint = std::chrono::high_resolution_clock::<span class="built_in">now</span>(); &#125;</span><br><span class="line">	~<span class="built_in">Timer</span>() &#123; <span class="built_in">stop</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> endTimePoint = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">		<span class="comment">// transform format from (class)time_point to (long long)</span></span><br><span class="line">		<span class="keyword">auto</span> start = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(m_StartTimePoint).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">		<span class="keyword">auto</span> end = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(endTimePoint).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">auto</span> duration = end - start;</span><br><span class="line">		<span class="type">double</span> ms = duration * <span class="number">0.001</span>; <span class="comment">// 默认单位：微秒</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;duration: &quot;</span> &lt;&lt; duration &lt;&lt; <span class="string">&quot;us(&quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot;ms)\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; m_StartTimePoint;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>封装完之后，只需在函数或者scope开头处实例化一次即可计算整个函数或者scope的耗时</p>
<h2 id="类型双关-type-punning">类型双关 type punning</h2>
<blockquote>
<p>Cpp中的“类型”实际上是个壳，本质上是内存空间的不同分配量，比如一个byte定义为char，两个byte定义为short等等。</p>
</blockquote>
<h3 id="情景">情景</h3>
<p>如果定义一个整型数据 <code>int a = 5;</code>，再定义一个浮点型数据
<code>double b;</code>，将a作为右值赋给b的操作 <code>b=a</code>
是可通过编译并且能正常运行的，通过debug模式访问a与b实际地址的数据可发现，<code>b=a</code>
的操作实际上进行了一个 "implicit conversion"
隐式类型转换，效果上等同于显式转换 <code>b = double(a);</code></p>
<h3 id="问题">问题</h3>
<p>如果以指针的形式进行强制转换，解引用之后会出现一个莫名其妙的值：<code>2.86087e-66</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> b = *(<span class="type">double</span>*)&amp;a;</span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出现这个问题的根本原因是int类型只占4个byte的内存空间，而double占了8个byte，对a取址并强制转化成了一个double类型指针意味着硬是将a与a之后的4个byte的空间合并成了一个double类型，也就导致了变量b的值变得无法预估；</p>
<h3 id="说明-1">说明</h3>
<p>C++的强大之处在于它可以利用指针直接对内存单元进行操作，因此对于“类型”进行内存层面上的转换处理是被允许的，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e = &#123;<span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="type">int</span> y1 = e.y;</span><br><span class="line">    <span class="type">int</span> y2 = *(<span class="type">int</span>*)((<span class="type">char</span>*)&amp;e + <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; y1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>y1直接取结构体成员变量y的值，y2则进行了多次的所谓“类型转换”，二者的运行结果是一样的；</p>
<p>再比如，在Entity内部加上成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;x; &#125;</span><br></pre></td></tr></table></figure>
<p>以左值引用的形式返回了一个指向x的指针，相当于将Entity的成员变量x,
y从内存层面上转换成了一个数组，因此可以在main中以数组的形式对实例e的成员变量x和y直接进行改动，并且不会造成任何拷贝行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* position = e.<span class="built_in">Get</span>();</span><br><span class="line">position[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">position[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">std::cout &lt;&lt; e.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; e.y &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h2 id="联合体-union">联合体 union</h2>
<p><strong>简述</strong></p>
<p>联合体（union）是一种与结构体（struct）相似的数据格式，可包含多种数据类型的变量；</p>
<p>二者的简要区别为：</p>
<ul>
<li><p>结构体中的变量各自独立且同时存在，变量之间地址连续，可初始化所有变量；</p></li>
<li><p>联合体中各个变量在内存中是"重叠"的，即联合体中所有变量都存在于<strong>同一个首地址</strong>的内存中。当我们给其中任意一个变量赋值之后，其他所有的变量的值都会依据这个地址中的数据变化而发生相应的变化；这种"重叠"的性质意味着不能同时初始化或者使用联合体中1个以上的变量，否则会造成歧义和内存泄漏；</p></li>
</ul>
<p><strong>举例说明</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="type">float</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A t&#123;&#125;;</span><br><span class="line">	U u&#123;&#125;;</span><br><span class="line">	u.b = <span class="number">97</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;u.a: &quot;</span> &lt;&lt; u.a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="string">&quot;u.b: &quot;</span> &lt;&lt; u.b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中创建了一个结构体U与联合体A，在VS2019中使用Debug模式运行，查看结构体变量t的内存数据：</p>
<p><img src="struct.png" alt="结构体t的内存数据"></p>
<p>可见结构体中的三个数据类型
<code>int</code>，<code>float</code>，<code>char</code>
在内存中以地址连续的方式分布，互不影响</p>
<p>再看看联合体变量u的内存数据：</p>
<p><img src="union.png" alt="联合体u的内存数据"></p>
<p>在代码中我们只对联合体的变量<code>int b</code>作了初始化，从内存上看，一个<code>int</code>占四个字节，没问题，再看输出：</p>
<p><img src="union_output.png" alt="联合体u的数据输出"></p>
<p>发现 <code>u.a</code>
变成了字母a，但代码中并没有对a作初始化，这就是联合体的"数据重叠"特性，因为a和b使用的是同一个首地址的内存，在我们给b赋值为97之后，a就会以字符变量<code>char</code>的数据类型对97作一个强制类型转换，而97作为ASCII码时对应的字符就是"a"；</p>
<h2 id="强制类型转换">强制类型转换</h2>
<blockquote>
<p>任何类型的强制转换都应该被避免</p>
</blockquote>
<h3 id="隐式强制类型转换">隐式强制类型转换</h3>
<p>隐式转换（implicit conversion）就是隐式地声明类型，例如
<code>int a = 5.2f</code>; 将<code>float</code>
5.2强制转化为<code>int</code>5，</p>
<p>或者传递实参给函数时会自动进行合法的隐式强制转换；以下讨论皆为显式强制转换，即明确类型的强制转换；</p>
<h3 id="显式强制类型转换-c风格">显式强制类型转换 C风格</h3>
<p>C风格的强制类型转换就是直接在变量或常量前加上<code>(T)</code>声明强制类型，例如
<code>int a = int(5.2f);</code></p>
<p>强制转换的基本规则如下：</p>
<ul>
<li>浮点型 -&gt; 整型：直接取整数部分；</li>
<li>字符型 -&gt; 整型：以ASCII码的形式转化</li>
<li>大整型 -&gt; 小整型：只取大整型中小整型所占位数的数据</li>
<li>符号型 -&gt; 同类无符号型：将符号位视为合法数据一并转化</li>
</ul>
<h3 id="显式强制类型转换-cpp风格">显式强制类型转换 CPP风格</h3>
<blockquote>
<p>"上行" or "下行"的判断方式：基类-&gt;派生类为下行，反之上行</p>
</blockquote>
<p>c++为显式强制类型转换提供了四个关键字，分别是
<code>static_cast</code>，<code>dynamic_cast</code>，<code>const_cast</code>
和
<code>reinterpret_cast</code>，使用它们能让开发者更容易知道工程中什么地方使用了强制转换;</p>
<h4 id="static_cast">static_cast</h4>
<p><strong>处理：</strong>编译时检查转换是否可行，一旦编译通过，运行时暴力转换</p>
<p><strong>核心：</strong>暴力转换，但只在类型相同或相关时可通过编译</p>
<p><strong>格式：</strong><code>static_cast&lt;T&gt; variable;</code></p>
<p><strong>说明：</strong>static_cast的用途及特点如下：</p>
<ul>
<li><p>基本数据类型之间的转换</p></li>
<li><p>用于类层次结构中基类和派生类之间指针或引用的转换</p>
<ul>
<li>上行转换（派生类指针/引用 -&gt; 基类）是安全的</li>
<li>下行转换（基类指针/引用 -&gt;
派生类）由于没有动态类型检查，所以是不安全的</li>
<li>同级转换（派生类指针/引用 -&gt; 同级派生类）编译器报错 "invalid type
conversion"</li>
<li>转换后调用多态接口时以转换前<strong>实际</strong>指向的类对象作为解释物</li>
<li>转换后编译器允许调用的类方法是转换后的类的方法，而非待转换的类的方法</li>
</ul></li>
<li><p>把空指针转换成目标类型的空指针</p></li>
<li><p>把任何类型的表达式转换为void类型</p></li>
</ul>
<p><strong>例子一：基本数据类型转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">5.2f</span>);</span><br></pre></td></tr></table></figure>
<p><strong>例子二：类实例指针转换</strong></p>
<p>下面的代码创建了基类 <code>Entity</code> 以及它的派生类
<code>Player</code> 和 <code>Enemy</code>，其中接口 <code>Print()</code>
以多态的形式存在，派生类各有一个自己的 <code>ClassOutput()</code>
方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>() : <span class="built_in">m_Value</span>(<span class="number">1</span>) &#123; std::cout &lt;&lt; <span class="string">&quot;Entity Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Entity Print: &quot;</span> &lt;&lt; m_Value &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Player</span>() : <span class="built_in">m_Value</span>(<span class="number">2</span>) &#123; std::cout &lt;&lt; <span class="string">&quot;Player Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Player Print: &quot;</span> &lt;&lt; m_Value &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PlayerOutput</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Belong to only Player&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Enemy</span>() : <span class="built_in">m_Value</span>(<span class="number">3</span>) &#123; std::cout &lt;&lt; <span class="string">&quot;Enemy Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Enemy Print: &quot;</span> &lt;&lt; m_Value &lt;&lt; std::endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">EnemyOutput</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Belong to only Enemy&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 隐式上行转换</span></span><br><span class="line">	Entity* entity = <span class="keyword">new</span> <span class="built_in">Enemy</span>();</span><br><span class="line">	entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 隐式下行转换，编译器报错</span></span><br><span class="line">	Enemy* enemy = <span class="keyword">new</span> <span class="built_in">Entity</span>();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上行转换，待转换派生类指针指向派生类对象</span></span><br><span class="line">	Entity* entity = <span class="built_in">static_cast</span>&lt;Entity*&gt;(<span class="keyword">new</span> <span class="built_in">Enemy</span>());  </span><br><span class="line">	entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 下行转换，待转换基类指针指向基类对象</span></span><br><span class="line">	Enemy* enemy2 = <span class="built_in">static_cast</span>&lt;Enemy*&gt;(<span class="keyword">new</span> <span class="built_in">Entity</span>()); </span><br><span class="line">	enemy2-&gt;<span class="built_in">Print</span>();</span><br><span class="line">	enemy2-&gt;<span class="built_in">EnemyOutput</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按顺序依次解释：</p>
<ul>
<li><strong>隐式上行转换</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity* entity = <span class="keyword">new</span> <span class="built_in">Enemy</span>();</span><br><span class="line">entity-&gt;<span class="built_in">Print</span>();</span><br></pre></td></tr></table></figure>
<p>编译通过且运行正常，指针为指向基类 <code>Entity</code>
的指针，因此只能调用 <code>Print()</code> 方法。基类 <code>Entity</code>
的构造函数中初始化成员变量<code>m_Value</code>的值为1，原本调用
<code>Print()</code>
输出的结果应该是1，但是这里隐式强制转化成了指向派生类 <code>Enemy</code>
的指针，因此输出的结果为3；</p>
<p><img src="static_cast_2.png" alt="隐式上行转换"></p>
<ul>
<li><strong>隐式下行转换</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enemy* enemy = <span class="keyword">new</span> <span class="built_in">Entity</span>();  </span><br></pre></td></tr></table></figure>
<p>类型不匹配，编译器报错："a value of 'Entity*' cannot be used to
initialize an entity of type 'Enemy*'' "</p>
<p><img src="static_cast_1.png" alt="隐式下行转换"></p>
<ul>
<li><strong>上行转换，待转换派生类指针指向派生类对象</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity* entity2 = <span class="built_in">static_cast</span>&lt;Entity*&gt;(<span class="keyword">new</span> <span class="built_in">Enemy</span>());  </span><br><span class="line">entity2-&gt;<span class="built_in">Print</span>();</span><br></pre></td></tr></table></figure>
<p>上行转换，即自下而上，将派生类指针强制转化为基类指针，使<strong>基类指针指向派生类对象</strong>，转化后只能调用基类存在的方法，因为指向了派生类对象，所以<code>Print()</code>
输出的结果是3</p>
<p><img src="static_cast_4.png" alt="上行转换"></p>
<ul>
<li><strong>下行转换，待转换基类指针指向基类对象</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enemy* enemy2 = <span class="built_in">static_cast</span>&lt;Enemy*&gt;(<span class="keyword">new</span> <span class="built_in">Entity</span>()); </span><br><span class="line">enemy2-&gt;<span class="built_in">Print</span>();</span><br><span class="line">enemy2-&gt;<span class="built_in">EnemyOutput</span>();</span><br></pre></td></tr></table></figure>
<p>下行转换，意味着由上而下，将基类指针强制转换为派生类指针，使<strong>派生类指针指向基类对象</strong>，转化后只能调用派生类
<code>Enemy</code>
中存在的方法，由于指向了基类对象，<code>Print()</code>
输出的结果是1，而调用属于派生类的 <code>EnemyOutput()</code>
理论上是在调用一个不存在的函数，使用static_cast转换时编译器会强行把基类对象当成派生类对象解释，但这是个不安全的操作，若使用dynamic_cast则不会通过这个转换；</p>
<p><img src="static_cast_3.png" alt="下行转换"></p>
<h4 id="dynamic_cast">dynamic_cast</h4>
<blockquote>
<p>RTTI：Run-Time Type
Identification，通过检测运行时的类型信息，程序能够使用基类的指针或引用来检查这些指针或引用<strong>所指的</strong>对象的实际派生类型，dynamic_cast
为RTTI的两个操作符之一，另一个是typeid</p>
</blockquote>
<p><strong>处理：</strong>编译时检查转换是否可行，运行时检查转换是否成功，<strong>不成功时返回null指针</strong>，效率较低</p>
<p><strong>核心：</strong>纠正不安全的下行转换</p>
<p><strong>格式：</strong><code>dynamic_cast&lt;T&gt; variable;</code></p>
<p><strong>说明：</strong>dynamic_cast的用途及特点如下：</p>
<ul>
<li><strong>不可</strong>用于基本数据类型转换，只可用于父子类之间的实例指针或引用转换</li>
<li>主要用于<strong>纠正</strong>基类指针不恰当地指向子类对象的隐患，以更安全的方式做下行转换</li>
<li>上行转换等价于static_cast，同级转换返回null</li>
<li>下行转换必须满足条件才可通过转换：待转换基类指针指向派生类对象</li>
<li>使用时基类<strong>必须</strong>有虚函数（要求有虚函数表），否则编译过不了</li>
<li>转换后调用多态接口时以转换前<strong>实际</strong>指向的类对象作为解释物</li>
<li>转换后编译器允许调用的类方法是转换后的类的方法，而非待转换的类的方法</li>
</ul>
<p><strong>例子一：上行转换，待转换派生类指针指向派生类对象</strong></p>
<p>将派生类指针强制转化为基类指针，等价于static_cast</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity* entity = <span class="built_in">dynamic_cast</span>&lt;Entity*&gt;(<span class="keyword">new</span> <span class="built_in">Enemy</span>());  </span><br><span class="line">entity-&gt;<span class="built_in">Print</span>();</span><br></pre></td></tr></table></figure>
<p><strong>例子二：下行转换，待转换基类指针指向基类对象</strong></p>
<p>最主要的使用场景：需要用基类指针指向一个派生类的对象，而隐式转换
<code>Enemy* enemy = new Entity()</code> 报错不可行，诸如
<code>Enemy* enemy = (Enemy*)(new Entity());</code>
这样的直接显式转换又过于暴力，安全性不好，因此使用
dynamic_cast，达到强制显式转换目的的同时，做运行时的转换检查，如果转换失败就返回null，确保程序安全；</p>
<p>下面这段代码的转换是不被 dynamic_cast 允许的，会返回null。因为
<code>new Entity()</code> 返回的类型是
<code>Entity*</code>，指向的是基类对象，而基类对象中没有
<code>EnemyOutput</code> 这个方法，强制转换成 <code>Enemy* enemy</code>
可能造成 <code>enemy-&gt;EnemyOutput()</code>
这样调用不存在函数的不安全操作，因此只会返回null，表示转换有隐患，取消转换；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回null的案例</span></span><br><span class="line">Enemy* enemy = <span class="built_in">dynamic_cast</span>&lt;Enemy*&gt;(<span class="keyword">new</span> <span class="built_in">Entity</span>()); <span class="comment">// 如果用隐式下行转换会报错</span></span><br><span class="line"><span class="keyword">if</span> (!enemy)</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;invalid dynamic_cast from Entity* to Enemy*&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	enemy-&gt;<span class="built_in">Print</span>();</span><br></pre></td></tr></table></figure>
<p><strong>例子三：下行转换，待转换基类指针指向派生类对象</strong></p>
<p>正确使用dynamic_cast纠正下行转换的代码如下，基类指针
<code>entity</code> 正确指向派生类对象
<code>Enemy</code>，可执行纠正</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确转换</span></span><br><span class="line">Entity* entity = <span class="keyword">new</span> <span class="built_in">Enemy</span>();</span><br><span class="line">entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">Enemy* enemy = <span class="built_in">dynamic_cast</span>&lt;Enemy*&gt;(entity); </span><br><span class="line"><span class="keyword">if</span> (!enemy)</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;invalid dynamic_cast from Entity* to Enemy*&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	enemy-&gt;<span class="built_in">Print</span>();</span><br></pre></td></tr></table></figure>
<h4 id="reinterpret_cast">reinterpret_cast</h4>
<p><strong>处理：</strong>除了const之外，可执行任意指针类型的暴力转换，产生一个新值，与原始参数有完全相同的比特位</p>
<p><strong>核心：</strong>const之外的任何指针类型，暴力转换，不检测不报错</p>
<p><strong>格式：</strong><code>reinterpret_cast&lt;T&gt; variable;</code></p>
<p><strong>说明：</strong>由于 reinterpret_cast
过于暴力，使用时需要开发者注意转换是否合适，以下是推荐使用的场景：</p>
<ul>
<li>指针 -&gt; 大整型（32位系统至少是int，64位系统至少是long）</li>
<li>整型/枚举 -&gt; 指针</li>
<li>函数Ⅰ指针 -&gt; 函数Ⅱ指针</li>
<li>类Ⅰ对象指针 -&gt; 类Ⅱ对象指针</li>
<li>类Ⅰ函数成员Ⅰ指针 -&gt; 类Ⅰ函数成员Ⅱ指针</li>
<li>类Ⅰ数据成员Ⅰ指针 -&gt; 类Ⅰ数据成员Ⅱ指针</li>
</ul>
<p><strong>注意点：</strong></p>
<ul>
<li>无法进行基本数据类型的转换，必须满足至少有一方是指针类型的条件</li>
<li>主要用于处理无关类型之间的强制转换</li>
<li>类型差异大时往往只能返回一个指向一块空内存的指针，内存块大小取决于转换后的类型</li>
</ul>
<p><strong>例子一：下行转换，待转换基类指针指向基类对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enemy* enemy = <span class="built_in">reinterpret_cast</span>&lt;Enemy*&gt;(<span class="keyword">new</span> <span class="built_in">Entity</span>());</span><br></pre></td></tr></table></figure>
<p>从一个指向基类 <code>Entity</code> 对象的 <code>Entity</code>
指针转化为派生类 <code>Enemy</code>
指针，隐式转换编译器直接报错，dynamic_cast返回null因为
<code>new Entity();</code> 创建的基类指针指向的是基类
<code>Entity</code> 对象而不是派生类 <code>Enemy</code>
对象，不被dynamic_cast允许转换。只有C风格的显示转换、static_cast与reinterpret_cast可暴力执行，当然都不安全；可能会造成调用不存在的方法或属性的情况；</p>
<p><strong>例子二：同级转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enemy* enemy = <span class="built_in">reinterpret_cast</span>&lt;Enemy*&gt;(<span class="keyword">new</span> <span class="built_in">Player</span>());</span><br><span class="line">enemy-&gt;<span class="built_in">Print</span>();</span><br></pre></td></tr></table></figure>
<p>同级转换不论是C风格的隐式/显式抓换，还是static_cast都不能通过编译，使用dynamic_cast也会返回null，只有reinterpret_cast可暴力强转，并且
<code>Print()</code> 输出的结果是 Player 类的数据 2；</p>
<p><strong>例子三：合理的跨类型转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"><span class="type">long</span> b = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span>&gt;(a);</span><br><span class="line">std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>指针转化为整型，64位系统选取长整型 <code>long</code></p>
<p><strong>例子二：不合理的跨类型转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">float</span>* b = <span class="keyword">new</span> <span class="type">float</span>;</span><br><span class="line">b = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>*&gt;(a);</span><br><span class="line">std::cout &lt;&lt; *b &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>第4行报错，因为上述转换相当于把整型变量 <code>a</code> 的值1强制当作
<code>float*</code> 类型的地址，而地址 <code>0x00000000000001E1</code>
处的值是未知的，即使换成 <code>int*</code>
也是一样的结果，虽然转换的过程本身不会报错，但是这种转换是没有意义的，使用时要格外注意；</p>
<h4 id="const_cast">const_cast</h4>
<p><strong>处理：</strong>去除变量的const限制，达到修改const变量的目的，或者给变量加上const属性，使其不可被修改</p>
<p><strong>核心：</strong>const化 or 去const化</p>
<p><strong>格式：</strong><code>const_cast&lt;T&gt; variable;</code></p>
<p><strong>例子+说明一：普通变量去const化</strong></p>
<p>通常情况下，加了const修饰符的变量是不可被修改的，但是由于C++对指针类型的强制转换几乎没有限制，因此可以通过指针强制转换让编译器通过对const变量的修改语句，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> constant = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span>* modifier = (<span class="type">int</span>*)(&amp;constant);</span><br><span class="line">*modifier = <span class="number">10</span>;</span><br><span class="line">std::cout &lt;&lt; constant &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>上述代码中的转换步骤
<code>int* modifier = (int*)(&amp;constant);</code> 的效果就等同于使用
const_cast：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;constant);</span><br></pre></td></tr></table></figure>
<p>然而，<code>*modifier = 10;</code> 对编译器来说是 "undefined
behavior"，即<strong>未定义的行为</strong>，虽然表面上
<code>*modifier</code> 与 <code>constant</code>
指向的是同一个地址，但是上面的修改并不会影响到 <code>constant</code>
的值，也就是说输出 <code>*modifier</code>
的结果是我们修改后的值10，但是输出 <code>constant</code>
的结果还是21，我们还是无法修改掉 <code>constant</code>
的本值；但是可以使用 <code>modifier</code> 来代替 <code>constant</code>
作为修改后的值使用。另外，二者指向的同一个地址中的数据，是
<code>modifier</code> 修改后的数据：10;</p>
<p><strong>例子+说明二：函数参数去const化与const化</strong></p>
<p>const_cast的另一个用途就是在函数中修改已设定为const的实参，如下面的代码，一目了然</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>&amp; b = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(a);</span><br><span class="line">	b += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个结合参数const化和去const化的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">Shorter</span><span class="params">(<span class="type">const</span> std::string&amp; r1, <span class="type">const</span> std::string&amp; r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> r1.<span class="built_in">size</span>() &lt; r2.<span class="built_in">size</span>() ? r1 : r2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">Shorter</span><span class="params">(std::string&amp; r1, std::string&amp; r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// const化</span></span><br><span class="line">	<span class="keyword">auto</span>&amp; r = <span class="built_in">Shorter</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> std::string&amp;&gt;(r1), <span class="built_in">const_cast</span>&lt;std::string&amp;&gt;(r2));</span><br><span class="line">    <span class="comment">// 去const化</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;std::string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string s1 = <span class="string">&quot;Light&quot;</span>;</span><br><span class="line">	std::string s2 = <span class="string">&quot;Shaker&quot;</span>;</span><br><span class="line">	std::string r = <span class="built_in">Shorter</span>(s1, s2);</span><br><span class="line">	std::cout &lt;&lt; r &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构绑定">结构绑定</h2>
<blockquote>
<p>结构绑定（structured
binding）是C++17的新特性，用于实现多个不同类型数据的快速捆绑</p>
</blockquote>
<h3 id="c17之前的做法">C++17之前的做法</h3>
<p>在C++17之前，要绑定多个不同类型的变量，除了使用结构体/类之外，有两种方式可以实现；</p>
<p><strong>方式一：</strong>使用 <code>std::tuple</code>，例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">CreatePerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="string">&quot;Lightshaker&quot;</span>, <span class="number">21</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 <strong>tuple</strong>
有一个缺点，就是无法简洁直接地获取其中的变量，只能使用
<code>std::get()</code> 方法获取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::tuple&lt;std::string, <span class="type">int</span>&gt; person = <span class="built_in">CreatePerson</span>();</span><br><span class="line">	std::string&amp; name = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(person);</span><br><span class="line">	<span class="type">int</span> age = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样虽然可行，但是很不方便，并且加大了代码量，因此C++17</p>
<p><strong>方式二：</strong>使用 <code>std::tie()</code>，例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">std::<span class="built_in">tie</span>(name, age) = <span class="built_in">CreatePerson</span>();</span><br></pre></td></tr></table></figure>
<p>使用 API <code>std::tie()</code> 绑定 <code>name</code> 与
<code>age</code>，显然要比上面使用 <code>std::tuple</code>
要简洁一些，但是显然需要在捆绑之前创建所有的变量，当内容较多时，代码也会显得臃肿；</p>
<h3 id="c17-结构绑定">C++17 结构绑定</h3>
<p>C++17的结构绑定方式非常简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>[name, age] = <span class="built_in">CreatePerson</span>();</span><br></pre></td></tr></table></figure>
<p>一行就能完成上面多行的功能，创建变量和捆绑变量在一行之内进行，并且之后可直接访问
<code>name</code> 和 <code>age</code></p>
<p>结构绑定可以一定程度上代替纯数据结构体，非常好用；</p>
<h2 id="编译器-compiler">编译器 Compiler</h2>
<h3 id="翻译单元">翻译单元</h3>
<p>我们知道进行编译时每一个cpp都会编译成一个<code>.o</code>或<code>.obj</code>文件然后链接器再去进行链接生成可执行文件，一个翻译单元（translation
unit）指的是编译生成的<code>.o</code>文件对应的cpp文件。注意一个cpp并不等同于一个翻译单元，当工程中每个cpp都是独立的文件，且不互相调用时，每个cpp都会被编译生成一个<code>.o</code>文件，这时每个cpp都是一个翻译单元。但是如果一个cpp内包含了其他所有cpp的内容，编译时只编译这个大的cpp文件时，只会生成一个<code>.o</code>文件，此时只有被编译的这个cpp称为翻译单元，其他不行。</p>
<h2 id="链接器-linker">链接器 Linker</h2>
<h3 id="链接器错误常见类型">链接器错误常见类型</h3>
<p>函数只有声明没有定义，并且在主函数或者其他函数里被调用过，链接报错：<code>Unresolved external symbol</code></p>
<p>函数声明与函数定义在函数名、参数类型、参数个数、返回值类型等处不同时，链接报错：<code>Unresolved external symbol</code></p>
<p>同一个工程中出现重复定义的函数时，链接报错：<code>xxx already defined in XXX</code>
深一层原因有两种，一是同一个文件中重复定义一个函数，二是将函数定义写在头文件里，并且多个不同的文件所包含。解决方法有三种：</p>
<ul>
<li>加上static关键字，使其成为静态函数。该函数只在被调用的文件内部被链接，对其他文件不可见
。</li>
<li>加上inline关键字，使其称为内联函数，该函数的body部分会直接被粘贴到被调用的地方。</li>
<li>不在头文件中写函数定义</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/archives/1b0d/" rel="prev" title="最小二乘回归策略">
      <i class="fa fa-chevron-left"></i> 最小二乘回归策略
    </a></div>
      <div class="post-nav-item">
    <a href="/archives/2334/" rel="next" title="Ubuntu C++/Python混合编程">
      Ubuntu C++/Python混合编程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.</span> <span class="nav-text">从函数中创建并返回多个数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%90%8C"><span class="nav-number">2.1.1.</span> <span class="nav-text">数据类型相同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C"><span class="nav-number">2.1.2.</span> <span class="nav-text">数据类型不同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8E%A5%E6%94%B6%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE"><span class="nav-number">2.2.</span> <span class="nav-text">函数接收并返回多个数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">3.</span> <span class="nav-text">头文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E7%AE%80%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">功能简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%8F%B7%E4%B8%8E%E5%B0%96%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.</span> <span class="nav-text">引号与尖括号的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%93%E9%94%99%E7%82%B9"><span class="nav-number">3.3.</span> <span class="nav-text">易错点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">4.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">4.3.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="nav-number">4.4.</span> <span class="nav-text">指针与数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%80%85%E7%9A%84%E7%AE%80%E5%8D%95%E5%85%B3%E7%B3%BB"><span class="nav-number">4.4.1.</span> <span class="nav-text">二者的简单关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="nav-number">4.4.2.</span> <span class="nav-text">利用指针创建数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">4.4.3.</span> <span class="nav-text">如何知道数组的长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="nav-number">4.4.4.</span> <span class="nav-text">从函数中返回一个数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E7%9A%84%E9%95%BF%E5%BA%A6%E6%8C%87%E5%AE%9A%E9%97%AE%E9%A2%98"><span class="nav-number">4.4.5.</span> <span class="nav-text">定长数组在定义时的长度指定问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%8C%87%E9%92%88%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">4.4.6.</span> <span class="nav-text">多维指针与多维数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newdelete-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.5.</span> <span class="nav-text">new&#x2F;delete 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">4.6.</span> <span class="nav-text">函数指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">4.6.1.</span> <span class="nav-text">创建与使用函数指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">4.6.2.</span> <span class="nav-text">函数指针作为函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.6.3.</span> <span class="nav-text">lambda 表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">4.7.</span> <span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-unique_ptr"><span class="nav-number">4.7.1.</span> <span class="nav-text">智能指针 unique_ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%88%9B%E5%BB%BA"><span class="nav-number">4.7.1.1.</span> <span class="nav-text">介绍与创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E4%B8%80"><span class="nav-number">4.7.1.2.</span> <span class="nav-text">使用经验一</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88-shared_ptr"><span class="nav-number">4.7.2.</span> <span class="nav-text">共享指针 shared_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E6%8C%87%E9%92%88-weak_ptr"><span class="nav-number">4.7.3.</span> <span class="nav-text">弱引用指针 weak_ptr</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E9%A3%8E%E6%A0%BC"><span class="nav-number">5.1.</span> <span class="nav-text">C风格</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E5%AE%B9%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="nav-number">5.1.1.</span> <span class="nav-text">创建内容确定的字符串常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E5%AE%B9%E7%94%B1%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="nav-number">5.1.2.</span> <span class="nav-text">创建内容由用户输入的字符串常量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpp%E9%A3%8E%E6%A0%BC"><span class="nav-number">5.2.</span> <span class="nav-text">Cpp风格</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.2.1.</span> <span class="nav-text">创建字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.2.2.</span> <span class="nav-text">读取字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.2.3.</span> <span class="nav-text">输出字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">5.3.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">6.</span> <span class="nav-text">类和结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%94%AF%E4%B8%80%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.</span> <span class="nav-text">类与结构体的唯一区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="nav-number">6.2.</span> <span class="nav-text">如何选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explicit-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.4.</span> <span class="nav-text">explicit 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-%E6%A0%88or%E5%A0%86"><span class="nav-number">6.5.</span> <span class="nav-text">实例化的两种方式 栈or堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">6.6.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">6.7.</span> <span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">6.8.</span> <span class="nav-text">拷贝构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">6.8.1.</span> <span class="nav-text">深拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">6.8.2.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="nav-number">6.8.3.</span> <span class="nav-text">拷贝构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">6.8.4.</span> <span class="nav-text">拷贝赋值运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">6.9.</span> <span class="nav-text">移动构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E5%8F%AF%E8%A7%86%E5%8C%96-visibility"><span class="nav-number">6.10.</span> <span class="nav-text">封装&#x2F;可视化 Visibility</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="nav-number">6.11.</span> <span class="nav-text">虚函数与多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">6.11.1.</span> <span class="nav-text">为什么需要虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">6.11.2.</span> <span class="nav-text">虚函数的使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">6.11.3.</span> <span class="nav-text">纯虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">6.11.4.</span> <span class="nav-text">多态与虚函数表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81"><span class="nav-number">6.11.4.1.</span> <span class="nav-text">什么是多态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">6.11.4.2.</span> <span class="nav-text">虚函数表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F"><span class="nav-number">6.12.</span> <span class="nav-text">继承与派生</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-number">6.12.1.</span> <span class="nav-text">基本继承方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#public-%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="nav-number">6.12.1.1.</span> <span class="nav-text">public 公有继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#private-%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="nav-number">6.12.1.2.</span> <span class="nav-text">private 私有继承</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="nav-number">6.12.2.</span> <span class="nav-text">虚继承与虚基类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF"><span class="nav-number">6.12.2.1.</span> <span class="nav-text">问题场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">6.12.2.2.</span> <span class="nav-text">虚基类的声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">6.12.2.3.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">6.12.2.4.</span> <span class="nav-text">注意点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">6.12.2.5.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%8D%E6%95%B4%E6%B4%BB%E6%95%B4%E6%B4%BB"><span class="nav-number">6.12.2.6.</span> <span class="nav-text">再整活整活</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB"><span class="nav-number">6.12.3.</span> <span class="nav-text">不可被继承的类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E7%B1%BB-singleton"><span class="nav-number">6.13.</span> <span class="nav-text">单例类 Singleton</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">6.13.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">6.13.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E7%B1%BB%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">6.13.3.</span> <span class="nav-text">单例类与命名空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">6.14.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">6.14.1.</span> <span class="nav-text">重载运算符的目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E6%8C%89%E7%9B%AE%E6%95%B0%E5%88%86%E7%B1%BB"><span class="nav-number">6.14.2.</span> <span class="nav-text">运算符按目数分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="nav-number">6.14.3.</span> <span class="nav-text">运算符重载的基本规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">6.14.4.</span> <span class="nav-text">重载运算符的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%8F%8C%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">6.14.4.1.</span> <span class="nav-text">重载双目运算符为成员函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%8D%95%E7%9B%AE%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">6.14.4.2.</span> <span class="nav-text">重载单目自增自减运算符为成员函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%8D%95%E7%9B%AE%E6%8B%AC%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8D%95%E7%9B%AE%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8D%95%E7%9B%AE%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">6.14.4.3.</span> <span class="nav-text">重载单目括号运算符、单目指针运算符、单目强制类型转换运算符为成员函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BA%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">6.14.4.4.</span> <span class="nav-text">重载运算符为非成员函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E4%B8%8E%E7%AE%AD%E5%A4%B4%E6%93%8D%E4%BD%9C%E7%AC%A6-"><span class="nav-number">6.15.</span> <span class="nav-text">this指针与箭头操作符-&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-number">6.15.1.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E6%93%8D%E4%BD%9C%E7%AC%A6--"><span class="nav-number">6.15.2.</span> <span class="nav-text">箭头操作符 -&gt;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">7.</span> <span class="nav-text">const 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F"><span class="nav-number">7.1.</span> <span class="nav-text">修饰普通变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88"><span class="nav-number">7.2.</span> <span class="nav-text">修饰指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-number">7.3.</span> <span class="nav-text">修饰类的成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-%E4%B8%8E-extern"><span class="nav-number">8.</span> <span class="nav-text">static 与 extern</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.</span> <span class="nav-text">static 静态变量&#x2F;函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extern-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.</span> <span class="nav-text">extern 全局变量&#x2F;函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.</span> <span class="nav-text">枚举类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-template"><span class="nav-number">10.</span> <span class="nav-text">模板 template</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">10.1.</span> <span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">10.2.</span> <span class="nav-text">类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">10.2.1.</span> <span class="nav-text">基本类模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">10.2.2.</span> <span class="nav-text">数组类模板</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">11.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="nav-number">12.</span> <span class="nav-text">计时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%8C%E5%85%B3-type-punning"><span class="nav-number">13.</span> <span class="nav-text">类型双关 type punning</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E6%99%AF"><span class="nav-number">13.1.</span> <span class="nav-text">情景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">13.2.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-1"><span class="nav-number">13.3.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E5%90%88%E4%BD%93-union"><span class="nav-number">14.</span> <span class="nav-text">联合体 union</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">15.</span> <span class="nav-text">强制类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">15.1.</span> <span class="nav-text">隐式强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-c%E9%A3%8E%E6%A0%BC"><span class="nav-number">15.2.</span> <span class="nav-text">显式强制类型转换 C风格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-cpp%E9%A3%8E%E6%A0%BC"><span class="nav-number">15.3.</span> <span class="nav-text">显式强制类型转换 CPP风格</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static_cast"><span class="nav-number">15.3.1.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamic_cast"><span class="nav-number">15.3.2.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reinterpret_cast"><span class="nav-number">15.3.3.</span> <span class="nav-text">reinterpret_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const_cast"><span class="nav-number">15.3.4.</span> <span class="nav-text">const_cast</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E7%BB%91%E5%AE%9A"><span class="nav-number">16.</span> <span class="nav-text">结构绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c17%E4%B9%8B%E5%89%8D%E7%9A%84%E5%81%9A%E6%B3%95"><span class="nav-number">16.1.</span> <span class="nav-text">C++17之前的做法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c17-%E7%BB%93%E6%9E%84%E7%BB%91%E5%AE%9A"><span class="nav-number">16.2.</span> <span class="nav-text">C++17 结构绑定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8-compiler"><span class="nav-number">17.</span> <span class="nav-text">编译器 Compiler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E5%8D%95%E5%85%83"><span class="nav-number">17.1.</span> <span class="nav-text">翻译单元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8-linker"><span class="nav-number">18.</span> <span class="nav-text">链接器 Linker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E9%94%99%E8%AF%AF%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">18.1.</span> <span class="nav-text">链接器错误常见类型</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lightshaker</p>
  <div class="site-description" itemprop="description">It is our choices that show what we truly are, far more than our abilities.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lightshaker</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'j3EqSOqSYjPS414YtmiadN5W-gzGzoHsz',
      appKey     : '429Gb8wTQv1P09Fjbeyd9k5w',
      placeholder: "Hello",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
