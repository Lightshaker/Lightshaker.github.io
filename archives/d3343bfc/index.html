<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lightshaker.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="王道DSA笔记  内容来源：王道2021数据结构  Chapter1 绪论 数据结构 四个概念：  数据元素：数据的基本单位，通常作为一个整体进行考虑和处理。 数据项：构成数据元素的不可分割的最小单位。 数据结构：相互之间存在一种或多种特定关系的数据元素的集合。 数据对象：具有相同性质的数据元素的集合，是数据的一个子集。  数据结构三要素：  数据的逻辑结构：集合、线性结构、树形结构、图结构 数据">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构基础">
<meta property="og:url" content="https://lightshaker.cn/archives/d3343bfc/index.html">
<meta property="og:site_name" content="Journey">
<meta property="og:description" content="王道DSA笔记  内容来源：王道2021数据结构  Chapter1 绪论 数据结构 四个概念：  数据元素：数据的基本单位，通常作为一个整体进行考虑和处理。 数据项：构成数据元素的不可分割的最小单位。 数据结构：相互之间存在一种或多种特定关系的数据元素的集合。 数据对象：具有相同性质的数据元素的集合，是数据的一个子集。  数据结构三要素：  数据的逻辑结构：集合、线性结构、树形结构、图结构 数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/2.1.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/2.2.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/2.3.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/2.4.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/5.1.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/5.2.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/5.3.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/5.4.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/5.5.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/7.1.jpg">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/7.2.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/7.3.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/7.4.png">
<meta property="og:image" content="https://lightshaker.cn/archives/d3343bfc/7.5.png">
<meta property="article:published_time" content="2020-12-25T14:30:19.000Z">
<meta property="article:modified_time" content="2023-06-12T07:15:17.131Z">
<meta property="article:author" content="Lightshaker">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lightshaker.cn/archives/d3343bfc/2.1.png">

<link rel="canonical" href="https://lightshaker.cn/archives/d3343bfc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构基础 | Journey</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Journey</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lightshaker.cn/archives/d3343bfc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lightshaker">
      <meta itemprop="description" content="It is our choices that show what we truly are, far more than our abilities.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Journey">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-25 22:30:19" itemprop="dateCreated datePublished" datetime="2020-12-25T22:30:19+08:00">2020-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-12 15:15:17" itemprop="dateModified" datetime="2023-06-12T15:15:17+08:00">2023-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数学|算法</span></a>
                </span>
            </span>

          
            <span id="/archives/d3343bfc/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构基础" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/archives/d3343bfc/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/archives/d3343bfc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="王道dsa笔记">王道DSA笔记</h1>
<blockquote>
<p>内容来源：王道2021数据结构</p>
</blockquote>
<h2 id="chapter1-绪论">Chapter1 绪论</h2>
<h3 id="数据结构">数据结构</h3>
<p><strong>四个概念：</strong></p>
<ul>
<li>数据元素：数据的基本单位，通常作为一个整体进行考虑和处理。</li>
<li>数据项：构成数据元素的不可分割的最小单位。</li>
<li>数据结构：相互之间存在一种或多种特定关系的数据元素的集合。</li>
<li>数据对象：具有相同性质的数据元素的集合，是数据的一个子集。</li>
</ul>
<p><strong>数据结构三要素：</strong></p>
<ul>
<li>数据的<strong>逻辑结构</strong>：集合、线性结构、树形结构、图结构</li>
<li>数据的<strong>物理结构（存储结构）</strong>：顺序存储、链式存储，索引存储、散列存储（哈希）</li>
<li>数据的<strong>运算</strong>：包括运算的定义和实现；运算的定义针对逻辑结构指出运算的功能，运算的实现针对存储结构指出运算具体操作步骤。</li>
</ul>
<p><strong>绪论部分要点：</strong></p>
<ul>
<li>若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储，则各个数据元素在物理上可以是离散的。</li>
<li>数据的存储结构会影响存储空间分配的方便程度，以及对数据运算的速度。</li>
</ul>
<p><strong>数据类型：</strong>一个值的集合和定义在此集合上的一组操作的总称</p>
<ul>
<li>原子类型：值不可再分的数据类型，如<code>bool</code>，<code>int</code>等。</li>
<li>结构类型：值可再分解为若干成分的数据类型，如<code>struct</code>，<code>class</code>等。</li>
</ul>
<p><strong>抽象数据类型：</strong>（Abstract Data
Type，ADT）抽象数据组织及与之相关的操作，用数学化的余元定义数据的逻辑结构以及定义运算，与具体的实现无关（不涉及物理结构）。</p>
<span id="more"></span>
<h3 id="算法">算法</h3>
<p><strong>程序=数据结构+算法</strong></p>
<p><strong>算法的特性：</strong>有穷性、确定性、可行性、正确性，以及输入（0或多个）+输出（1或多个）；</p>
<p><strong>好算法的特质：</strong>正确性、可读性、健壮性、高效率与低储存量需求。</p>
<p><strong>时间复杂度：</strong><span class="math inline">\(T(n) =
O(f(n))\)</span></p>
<ul>
<li><p>事前预估算法时间开销<span
class="math inline">\(T(n)\)</span>与问题规模<span
class="math inline">\(n\)</span>的关系，<span
class="math inline">\(T\)</span>表示”time“。</p></li>
<li><p><strong>规则：</strong>忽略常系数并等价于1，忽略低阶项只保留高阶项，当表达式中包含乘法项时，需要借助以下阶数顺序判断。</p>
<ul>
<li><span
class="math inline">\(O(1)&lt;O(\log_2n)&lt;O(n)&lt;O(n\log_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)\)</span></li>
<li><strong>口诀：</strong>常对幂指阶</li>
</ul></li>
<li><p>使用<span
class="math inline">\(O\)</span>表示”同阶“，即同等数量级，意味着当<span
class="math inline">\(n-&gt;\infty\)</span>时，<span
class="math inline">\(T(n)\)</span>与<span
class="math inline">\(f(n)\)</span>的比值为常数。</p></li>
<li><p><strong>基本结论：</strong></p>
<ul>
<li>忽略顺序执行的代码，循环中只取一个基本操作判断与输入规模<span
class="math inline">\(n\)</span>的关系。
<ul>
<li>顺序执行的代码影响<span
class="math inline">\(f(n)\)</span>中的常数项，循环中顺序执行的代码影响<span
class="math inline">\(f(n)\)</span>中多项式的常系数，二者都可忽略。</li>
</ul></li>
<li>循环中的代码只会影响<span
class="math inline">\(f(n)\)</span>中多项式的常系数，因此只需挑循环中的一个基本操作分析它的执行次数与<span
class="math inline">\(n\)</span>的关系。</li>
<li>如果有多层嵌套循环，只需关注最深层循环。</li>
<li>当循环次数受输入数据影响时，只考虑最坏时间复杂度和平均时间复杂度。</li>
</ul></li>
</ul>
<p><strong>空间复杂度：</strong><span class="math inline">\(S(n) =
O(f(n))\)</span></p>
<ul>
<li>只关注与存储空间大小与问题规模<span
class="math inline">\(n\)</span>相关的变量<strong>个数</strong>即可（且可忽略数据类型），其他影响的都是<span
class="math inline">\(f(n)\)</span>中多项式的常系数或常数项。
<ul>
<li>与问题规模<span
class="math inline">\(n\)</span>无关的变量，只影响<span
class="math inline">\(f(n)\)</span>中的常数项，如<code>int i;</code>对应<span
class="math inline">\(O(4)\)</span>，作为低阶时可忽略。</li>
<li>与问题规模<span
class="math inline">\(n\)</span>相关的变量，其数据类型只影响<span
class="math inline">\(f(n)\)</span>多项式系数，如<code>int a[n];</code>对应<span
class="math inline">\(O(4n)\)</span>，其中的4可忽略。</li>
</ul></li>
<li>递归函数的空间复杂度：
<ul>
<li>递归过程中需要的存储空间与当前规模无关时：<span
class="math inline">\(S(n) = O(n)\)</span>，<span
class="math inline">\(n\)</span>表示递归调用的深度。</li>
<li>有关时：<span class="math inline">\(S(n)\)</span> = 与<span
class="math inline">\(n\)</span>相关变量在整个递归过程的总个数</li>
</ul></li>
</ul>
<h2 id="chapter2-线性表">Chapter2 线性表</h2>
<h3 id="基本概念">基本概念</h3>
<p><strong>定义：</strong>线性表是具有<strong>相同数据类型</strong>的<span
class="math inline">\(n(n\ge0)\)</span>个数据元素的<strong>有限序列</strong>，其中<span
class="math inline">\(n\)</span>为表长，当<span
class="math inline">\(n=0\)</span>时线性表是一个空表。若用<span
class="math inline">\(L\)</span>命名线性表，则一般表示为： <span
class="math display">\[
L=(a_1,a_2,\dots,a_i,a_{i+1}, \dots,a_n)
\]</span></p>
<ul>
<li><span class="math inline">\(a_i\)</span>是线性表中的“第<span
class="math inline">\(i\)</span>个”元素，<span
class="math inline">\(i\)</span>为该元素在线性表中的<strong>位序</strong>，注意位序从1开始，而数组下标从0开始；</li>
<li><span class="math inline">\(a_1\)</span>是表头元素，<span
class="math inline">\(a_n\)</span>是表尾元素；</li>
<li>除了表头元素外，每个元素有且仅有一个<strong>直接前驱结点</strong>，除最后一个元素外，每个元素有且仅有一个<strong>直接后继结点</strong>；</li>
</ul>
<p><strong>线性表的基本操作包括：</strong>创、销、增、删、查、改；</p>
<h3 id="顺序表">顺序表</h3>
<p><strong>定义：</strong>顺序表，指的是用顺序存储的方式实现的线性表；将逻辑上相邻的元素储存在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系体现。</p>
<p><strong>顺序表的特点：</strong></p>
<ul>
<li>随机访问，即可以在<span
class="math inline">\(O(1)\)</span>时间内找到第<span
class="math inline">\(i\)</span>个元素；</li>
<li>存储密度高，每个结点只存储数据元素；</li>
<li>拓展容量不方面，即使采用动态分配的方式实现，拓展长度的时间复杂度也比较高。</li>
<li>插入、删除操作不方便，需要移动大量元素；</li>
</ul>
<p>注意在初始化时将表长置零，防止线性表被脏数据覆盖。</p>
<p><strong>静态分配</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 实际长度</span></span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line">SqList <span class="title function_">initiate</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    size = (size &lt; <span class="number">0</span>) ? <span class="number">0</span> : (size &gt; MAXSIZE ? MAXSIZE : size);</span><br><span class="line">    SqList L;</span><br><span class="line">    L.size = size;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.size; i++)</span><br><span class="line">        L.data[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>动态分配</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">// 包含malloc和free</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span>  <span class="comment">// 包含bool变量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line">SqList <span class="title function_">initiate</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size &lt; <span class="number">0</span>)</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    SqList L;</span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*size);</span><br><span class="line">    L.size = size;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.size; i++)</span><br><span class="line">        L.data[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expand</span><span class="params">(SqList* L, <span class="type">int</span> extra)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = L-&gt;data;  </span><br><span class="line">    L-&gt;data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(L-&gt;size+extra));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;size; i++)</span><br><span class="line">        L-&gt;data[i] = p[i];</span><br><span class="line">    L-&gt;size += extra;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入元素 </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert</span><span class="params">(SqList* L, <span class="type">int</span> i, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        expand(L, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = L-&gt;size - <span class="number">1</span>; j &gt;= i; j--)</span><br><span class="line">            L-&gt;data[j] = L-&gt;data[j<span class="number">-1</span>];</span><br><span class="line">        L-&gt;data[i] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">erase</span><span class="params">(SqList* L, <span class="type">int</span> i, <span class="type">int</span>* ret)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *ret = L-&gt;data[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; L-&gt;size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; L-&gt;size; j++)</span><br><span class="line">                L-&gt;data[j] = L-&gt;data[j+<span class="number">1</span>];</span><br><span class="line">        L-&gt;size --;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按位查找值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">element</span><span class="params">(SqList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; L.size - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> L.data[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按位修改</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">modify</span><span class="params">(SqList* L, <span class="type">int</span> i, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; L-&gt;size - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        L-&gt;data[i] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按值查找位</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(SqList L, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.size; i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == value)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(SqList* L)</span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L-&gt;data);</span><br><span class="line">    L-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#123; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.size - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, L.data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &#125;\n&quot;</span>, L.data[L.size<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表">单链表</h3>
<blockquote>
<p>单向链表，只能指向下一个，无法逆向访问；</p>
<p>不带头结点的链表只能使用后插交换数据实现前插的原因：前插需要获取前驱结点，而不带头结点的链表首结点没有前驱结点；</p>
<p>带头结点的代码对每个带数据的结点具有一致性，不带头结点的代码需要将第一个带数据的结点从循环中剥离出来（因为第一个结点无需也无法执行头插尾插之类的操作）；</p>
</blockquote>
<p>带头结点，p指向不应被修改</p>
<p><img src="2.1.png"></p>
<p>不带头结点，p指向可被修改</p>
<p><img src="2.2.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<h4 id="创建">创建</h4>
<h5 id="头插法">头插法</h5>
<p>带头结点：创建头结点后，可以在循环内完成后面所有带数据结点的<strong>创建、初始化和头插</strong>操作；</p>
<p>不带头结点：必须手动先创建一个带数据的结点，再进入循环（<strong>创建、初始化、后插、数据交换</strong>）；</p>
<p>头插法在创建头结点后必须把头结点先指向NULL，否则第一次插入时会把新结点指向未知区域；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点</span></span><br><span class="line">LinkList <span class="title function_">HeadInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 头结点</span></span><br><span class="line">    LNode* s; <span class="type">int</span> x;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">-1</span>)&#123;</span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带头结点</span></span><br><span class="line">LinkList <span class="title function_">HeadInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList <span class="built_in">list</span> = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">list</span>-&gt;data);</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>:</span><br><span class="line">    LNode* s; <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">-1</span>)&#123;</span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">        <span class="built_in">list</span>-&gt;next = s; </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">list</span>-&gt;data;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data = s-&gt;data;</span><br><span class="line">        s-&gt;data = temp;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="尾插法">尾插法</h5>
<p>使用一个指针指向尾结点，向尾结点后面插入一个新结点，再将指针指向新的尾结点；</p>
<p>带与不带头结点使用尾插法的共同点：都需要一个临时指针指向每一次迭代的末结点，且循环体遵循“<strong>创建、初始化、尾插</strong>”的顺序，最后都需要把末结点指向NULL；</p>
<p>不同点：带头结点时循环体完整地实现了每一个结点的创建、初始化和尾插过程，而不带头结点的循环体无法对第一个结点做初始化工作，因为循环体内一定是先创建再初始化再尾插，如果把第一个结点的创建过程都扔进去，那还是会因为第一个结点没有地方执行“尾插”操作而与循环体矛盾。因此不带头结点的需要在外面初始化第一个结点；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点</span></span><br><span class="line">LinkList <span class="title function_">TailInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 头结点</span></span><br><span class="line">    LNode *s, *e=L; <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">-1</span>)&#123;</span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        e-&gt;next = s;</span><br><span class="line">        e = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带头结点</span></span><br><span class="line">LinkList <span class="title function_">TailInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkList <span class="built_in">list</span> = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">list</span>-&gt;data); <span class="comment">// 不同点</span></span><br><span class="line">    LNode* s, * e = <span class="built_in">list</span>; <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">-1</span>)&#123;</span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        e-&gt;next = s;</span><br><span class="line">        e = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找">查找</h4>
<h5 id="按位查找">按位查找</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点</span></span><br><span class="line">LNode* <span class="title function_">GetElement</span><span class="params">(LinkList <span class="built_in">list</span>, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* p; <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不带头结点 将j初值改成1即可</span></span><br></pre></td></tr></table></figure>
<h5 id="按值查找">按值查找</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点</span></span><br><span class="line">LNode* <span class="title function_">GetElement</span><span class="params">(LinkList <span class="built_in">list</span>, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    LNode* p = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != val)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不带头结点 将p的初始指向改成list即可</span></span><br></pre></td></tr></table></figure>
<h4 id="插入和删除">插入和删除</h4>
<h5 id="指定位序插入">指定位序插入</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IndexInsert</span><span class="params">(LinkList <span class="built_in">list</span>, <span class="type">int</span> index, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* p = <span class="built_in">list</span>; <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; i &lt; index - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = val;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带头结点 将i的初值设为1即可</span></span><br></pre></td></tr></table></figure>
<h5 id="指定结点插入">指定结点插入</h5>
<p>指定结点的前插和后插操作在创建部分已经体现了</p>
<h5 id="指定位序删除">指定位序删除</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IndexDelete</span><span class="params">(LinkList <span class="built_in">list</span>, <span class="type">int</span> index, <span class="type">int</span>* data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode* p = <span class="built_in">list</span>; <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; i &lt; index - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    *data = q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">// 释放被删除的结点的内存空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带头结点 将i的初值设为1即可</span></span><br></pre></td></tr></table></figure>
<h5 id="指定结点删除">指定结点删除</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p结点可以是任意结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SpecificDelete</span><span class="params">(LinkList <span class="built_in">list</span>, LNode* p, <span class="type">int</span>* data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(LNode* j = <span class="built_in">list</span>; j != <span class="literal">NULL</span>; j = j-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j-&gt;next == p)&#123;</span><br><span class="line">            j-&gt;next = p-&gt;next;</span><br><span class="line">            *data = p-&gt;data;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p结点不能是最后一个结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SpecificDelete</span><span class="params">(LNode* p, <span class="type">int</span>* data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;data = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    *data = q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双链表">双链表</h3>
<p>带头结点</p>
<p><img src="2.3.png"></p>
<p>不带头结点</p>
<p><img src="2.4.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode, *DLinkList;</span><br></pre></td></tr></table></figure>
<h4 id="创建-1">创建</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点 空链表</span></span><br><span class="line">DLinkList <span class="title function_">Initiate</span><span class="params">()</span>&#123;</span><br><span class="line">    DLinkList dList = (DLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(dList == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    dList-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    dList-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> dList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带头结点 非空链表</span></span><br><span class="line">DLinkList <span class="title function_">HeadInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    DLinkList dList = (DLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(dList == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    dList-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    dList-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    DNode* s; <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">-1</span>)&#123;</span><br><span class="line">        s = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = dList-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(dList-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            dList-&gt;next-&gt;prior = s;</span><br><span class="line">        dList-&gt;next = s;</span><br><span class="line">        s-&gt;prior = dList;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入">插入</h4>
<p>由于双链表可直接查询前驱结点，因此所有前插操作都可以转换为后插操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后插（带不带头结点都需要注意尾结点之后的NULL没有prior指针）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BackInsert</span><span class="params">(DNode* p, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode* s = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    s-&gt;data = val;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前插（不带头结点时注意首结点之前的NULL没有next指针）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">FrontInsert</span><span class="params">(DNode* p, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode* s = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    s-&gt;data = val;</span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;prior != <span class="literal">NULL</span>)</span><br><span class="line">        p-&gt;prior-&gt;next = s;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    p-&gt;prior = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除">删除</h4>
<h5 id="指定位序删除-1">指定位序删除</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IndexDelete</span><span class="params">(DLinkList dList, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode* p = dList; <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//带头结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; i &lt; index - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        q-&gt;next-&gt;prior = q;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="指定结点删除-1">指定结点删除</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除结点p</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SpecificDelete</span><span class="params">(DNode* p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode* q = p-&gt;prior;</span><br><span class="line">    q-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        p-&gt;next-&gt;prior = q;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除结点p的下一个结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SpecificDeleteNext</span><span class="params">(DNode* p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode*q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环链表">循环链表</h3>
<p>将单/双链表尾结点的next指针（原本指向NULL）指向头结点（空表时即指向自己），将双链表头结点prior指针指向自己；</p>
<p>循环单链表可以从任意结点出发，找到其他任意一个结点；</p>
<p>循环双链表在执行插入删除操作时，不需要考虑头尾是否为NULL（即是否有prior/next指针）的情况；</p>
<p>在需要频繁操作表头/表尾元素时，可以将链表头指针初始化指向表尾元素；</p>
<h3 id="静态链表">静态链表</h3>
<p>静态链表是用结构体数组的方式模拟的链表，数组将申请一块总量固定的连续内存空间，每一个元素表示一个结点，结点中存放一个int值表示下一个结点在数组中的下标位置。</p>
<p>数组第一个元素充当“头结点”的角色</p>
<p>尾结点的next值应设置为-1，初始化空静态链表时应该将所有结点的next值设置为同一个特殊值表示该结点为空，例如-2；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125; SLinklist[<span class="number">10</span>]; <span class="comment">// 表示元素个数为10的结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种定义方式等价于</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinklist</span>[10];</span></span><br></pre></td></tr></table></figure>
<p>静态链表执行插入操作时，需要从头开始找到一个标记为空的结点；但只能在已有的空间内操作，无法额外申请空间。</p>
<p>删除操作需要从头出发找到前驱结点，修改前驱结点游标并将被删除结点标记为空结点。</p>
<h3 id="顺序表与链表的优缺点">顺序表与链表的优缺点</h3>
<p>顺序表的插入/删除操作时间复杂度为<span
class="math inline">\(O(n)\)</span>，时间开销主要源于移动元素；链表同样为<span
class="math inline">\(O(n)\)</span>，但开销主要来源于查找元素；在元素较复杂时，搬运的开销要高得多；</p>
<p>顺序表按位查找<span
class="math inline">\(O(1)\)</span>，按值查找<span
class="math inline">\(O(n)\)</span>或<span
class="math inline">\(O(\log_2n)\)</span>（元素有序时），链表按位查找和按值查找都是<span
class="math inline">\(O(n)\)</span>；</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 44%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>顺序表</td>
<td>支持随机存取、存取密度高，空间自动回收</td>
<td>大片连续空间分配不方便、改变容量不方便</td>
</tr>
<tr class="even">
<td>链表</td>
<td>离散的小空间分配方便，改变容量方便</td>
<td>无法随机存取、存储密度低、需要手动回收空间</td>
</tr>
</tbody>
</table>
<h2 id="chapter3-栈和队列">Chapter3 栈和队列</h2>
<h3 id="栈的概念">栈的概念</h3>
<p>栈（Stack）是只允许在一端（栈顶）进行插入或删除操作的线性表，具有先进后出（FILO）或后进先出（LIFO）的特点。</p>
<p>n个不同的元素进栈，出栈元素不同排列的个数为<span
class="math inline">\(\cfrac{1}{n+1}C_{2n}^n\)</span>，称为卡特兰（Catalan）数，可采用数学归纳法证明。</p>
<h3 id="顺序栈">顺序栈</h3>
<p>类似于顺序表的定义方式，定义一个结构体，包含一个静态数组与一个栈顶索引值（代替栈顶指针），在栈为空时将栈顶索引值设为-1（意味着索引从0开始）；</p>
<p>注意，top初值设为-1意味着top+1是可存放数据的位置，如果设为0则本身就是可存放数据的位置，之后判定是否栈空栈满以及栈顶的序号都会不同；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line">SqStack <span class="title function_">initiate</span><span class="params">()</span> &#123;</span><br><span class="line">    SqStack s;</span><br><span class="line">    s.top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(SqStack* s, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == MAX - <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data[++s-&gt;top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(SqStack* s, <span class="type">int</span>* data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *data = s-&gt;data[s-&gt;top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">(SqStack* s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(SqStack* s)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == MAX - <span class="number">1</span> <span class="comment">//top初值为-1时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺序共享栈">顺序共享栈</h3>
<p>在同一块连续的内存空间中创建两个反向的顺序栈，栈顶指针（索引）分别指向空间的头部和尾部（或者头部和尾部的第一个溢出位）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX];</span><br><span class="line">    <span class="type">int</span> top1;</span><br><span class="line">    <span class="type">int</span> top2;</span><br><span class="line">&#125; SharedSqStack;</span><br></pre></td></tr></table></figure>
<p>两个栈的总空间不变，但各自的空间却可以随着对方的增删动态变化，利用栈顶指针（索引）是否相邻判断是否栈满</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top1 == <span class="number">-1</span> &amp;&amp; top2 == MAX <span class="comment">// 栈空</span></span><br><span class="line">top1 + <span class="number">1</span> == top2 <span class="comment">// 栈满</span></span><br></pre></td></tr></table></figure>
<h3 id="链栈">链栈</h3>
<p>链栈：基于链式存储实现的栈</p>
<p>本质上是单链表，只是将头结点（或首结点）视为栈顶，增删操作都只能在头结点（首结点）位置进行。</p>
<h4 id="带头结点">带头结点</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *LinkStack;</span><br><span class="line"></span><br><span class="line">LinkStack <span class="title function_">initiate</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkStack ls = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    ls-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(LinkStack ls, <span class="type">int</span>* data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Node* q = ls-&gt;next;</span><br><span class="line">    *data = q-&gt;data;</span><br><span class="line">    ls-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(LinkStack ls, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    Node* s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data = val;</span><br><span class="line">    s-&gt;next = ls-&gt;next;</span><br><span class="line">    ls-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">(LinkStack ls, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ls-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(LinkStack ls)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ls-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不带头结点">不带头结点</h4>
<p>无法创建空表，只能在创建时接受一个值作为首个结点的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *LinkStack;</span><br><span class="line"></span><br><span class="line">LinkStack <span class="title function_">initiate</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">    LinkStack ls = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    ls-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ls-&gt;data = val;</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(LinkStack ls, <span class="type">int</span>* data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *data = ls-&gt;data;</span><br><span class="line">        <span class="built_in">free</span>(ls);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* p = ls-&gt;next;</span><br><span class="line">    *data = ls-&gt;data;</span><br><span class="line">    ls-&gt;data = p-&gt;data;</span><br><span class="line">    ls-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(LinkStack ls, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    Node* s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;next = ls-&gt;next;</span><br><span class="line">    ls-&gt;next = s;</span><br><span class="line">    s-&gt;data = ls-&gt;data;</span><br><span class="line">    ls-&gt;data = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">top</span><span class="params">(LinkStack ls)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ls-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(LinkStack ls)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ls == <span class="literal">NULL</span>;</span><br><span class="line">&#125;o</span><br></pre></td></tr></table></figure>
<h3 id="队列的概念">队列的概念</h3>
<p>队列是只允许在一端（队尾）进行插入（入队），在另一端（队头）删除（出队）的线性表，特点为FIFO</p>
<p>队列具有的操作：初始化、销毁、入队、出队、读队头元素、判空</p>
<h3 id="顺序队列">顺序队列</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">//判空条件</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line">SqQueue <span class="title function_">initiate</span><span class="params">()</span>&#123;</span><br><span class="line">    SqQueue sq;</span><br><span class="line">    sq.front = sq.rear = sq.size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push_back</span><span class="params">(SqQueue* sq, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq-&gt;size == MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq-&gt;data[sq-&gt;rear] = x;</span><br><span class="line">    sq-&gt;rear = (sq-&gt;rear + <span class="number">1</span>) % MAX; <span class="comment">// 循环队列</span></span><br><span class="line">    sq-&gt;size ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop_front</span><span class="params">(SqQueue* sq, <span class="type">int</span>* x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *x = sq-&gt;data[sq-&gt;front];</span><br><span class="line">    sq-&gt;front = (sq-&gt;front + <span class="number">1</span>) % MAX;</span><br><span class="line">    sq-&gt;size --;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">front</span><span class="params">(SqQueue* sq, <span class="type">int</span>* x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *x = sq-&gt;data[sq-&gt;front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(SqQueue* sq)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Attention</strong></p>
<p>如果<code>rear</code>初值意义为队尾元素的后一个位置（0），那么每次<code>push()</code>操作的顺序是先设值，再执行<code>rear = (rear + 1) % MAX</code>；</p>
<p>如果<code>rear</code>初值意义为队尾元素（MAX-1或-1），那么<code>push()</code>操作的顺序就是上述调换；</p>
<p>保持上述结构体不变时，上述两种方式区别在于：</p>
<ul>
<li>判空方式：前者使用<code>rear == front</code>，后者使用<code>(rear + 1) % MAX == front</code></li>
<li>判满方式：前者使用<code>(rear + 1) % MAX == front</code>，后者使用<code>(rear + 2) % MAX == front</code></li>
</ul>
<p>相同点在于：都要牺牲<code>front</code>前面的一个存储单元</p>
<ul>
<li>前者：当<code>rear</code>在<code>front</code>的前一个位置时，如果再使用<code>push()</code>，将使<code>rear == front</code>，与判空条件矛盾；</li>
<li>后者：当<code>rear</code>在<code>front</code>的前两个位置时，如果再使用<code>push()</code>，将使<code>(rear + 1) % MAX == front</code>，与判空条件矛盾；</li>
</ul>
<p>计算队列长度的方式：<code>(rear - front + MAX) % MAX</code></p>
<p>不牺牲存储单元也可以判空判满的方式：在结构体中添加<code>int size</code>或<code>bool tag</code>作为辅助条件</p>
<ul>
<li><code>size</code>表示当前队列已使用的单元数，可直接通过<code>size == 0</code>或<code>size == MAX</code>判断空满；</li>
<li><code>tag</code>表示上一次操作是插入还是删除，这样可在判空条件矛盾时通过上一次操作的性质判断空满；</li>
</ul>
<h3 id="链队列">链队列</h3>
<p>队列结点内存储队头指针（表头指针）以及队尾指针（表尾指针）</p>
<p>入队：尾结点后插</p>
<p>出队：删除头结点的下一个结点（或首结点）</p>
<p>链队列由于需要头尾指针作为结构体成员，但将头尾指针作为每一个结点的成员比较浪费空间，因此将队列结构体与结点结构体拆开</p>
<p>链队列不存在两种初始化<code>rear</code>的方式，原因在于每个数据的空间都是通过<code>malloc</code>动态分配的，一定是先分配内存，再修改指针，无法按照“先修改rear指向，后设值”的顺序执行<code>push()</code>操作，因此链队列可理解为顺序队列中的第一种初始化方式，即<code>rear</code>指向队尾元素的后一个位置（初值为NULL）；</p>
<p>链队列由于空间动态分配，一般情况下不存在“满”的情况，无需考虑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Node* front, *rear;</span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure>
<h4 id="带头结点-1">带头结点</h4>
<p>初始化：创建头结点并将<code>rear</code>和<code>front</code>都指向头结点，且将二者内部的<code>next</code>均指向<code>NULL</code>；</p>
<p>判空：<code>rear == front</code>，即二者都等于头指针；</p>
<p>增：创建结点，设值，头结点后插，修改<code>rear</code>；</p>
<p>删：判空，取头结点后继结点，取值，修改<code>front</code>，最后一个出队时将链表置空，<code>free</code>；</p>
<p>判断最后一个出队的方式：<code>lq-&gt;rear == lq-&gt;front-&gt;next</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">LinkQueue <span class="title function_">initiate</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkQueue lq;</span><br><span class="line">    lq.front = lq.rear = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 二者同时指向头结点</span></span><br><span class="line">    lq.front-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 同时设置二者的next为NULL</span></span><br><span class="line">    <span class="keyword">return</span> lq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(LinkQueue* lq)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lq-&gt;front == lq-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(LinkQueue* lq, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Node* s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    lq-&gt;rear-&gt;next = s; <span class="comment">// 修改原本的队尾指针的next</span></span><br><span class="line">    lq-&gt;rear = s; <span class="comment">// 更新队尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop_front</span><span class="params">(LinkQueue* lq, <span class="type">int</span>* x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lq-&gt;front == lq-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Node* p = lq-&gt;front-&gt;next;</span><br><span class="line">    *x = p-&gt;data;</span><br><span class="line">    lq-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(lq-&gt;rear == p) <span class="comment">//最后一个出队的结点</span></span><br><span class="line">        lq-&gt;rear = lq-&gt;front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不带头结点-1">不带头结点</h4>
<p>初始化：将<code>rear</code>和<code>front</code>都指向<code>NULL</code>；</p>
<p>判空：<code>front == NULL</code>；</p>
<p>增：创建结点，设值，后插，修改<code>rear</code>，如果是第一个结点则将<code>front</code>和<code>rear</code>都指向它；</p>
<p>删：判空，取首结点，取值，修改<code>front</code>，最后一个出队时将链表置空，<code>free</code>；</p>
<p>判断最后一个出队的方式：<code>lq-&gt;rear == lq-&gt;front</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">LinkQueue <span class="title function_">initiate</span><span class="params">()</span>&#123;</span><br><span class="line">    LinkQueue lq;;</span><br><span class="line">    lq.rear = <span class="literal">NULL</span>;</span><br><span class="line">    lq.front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> lq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(LinkQueue* lq)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lq-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_back</span><span class="params">(LinkQueue* lq, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Node* s = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(lq-&gt;front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        lq-&gt;front = s;</span><br><span class="line">        lq-&gt;rear = s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lq-&gt;rear-&gt;next = s;</span><br><span class="line">        lq-&gt;rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop_front</span><span class="params">(LinkQueue* lq, <span class="type">int</span>* x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lq-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Node* p = lq-&gt;front;</span><br><span class="line">    *x = p-&gt;data;</span><br><span class="line">    lq-&gt;front = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(lq-&gt;rear == p)&#123;  <span class="comment">// 最后一个出队</span></span><br><span class="line">        lq-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">        lq-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双端队列">双端队列</h3>
<p>只允许从两端插入或删除的线性表</p>
<p>特殊情况：输入受限和输出受限</p>
<p>考察在指定输入序列时，输出序列的合法性</p>
<h3 id="栈的应用">栈的应用</h3>
<h4 id="括号匹配">括号匹配</h4>
<p>最后出现的左括号最先被匹配（LIFO），每出现一右括号就消耗一个左括号</p>
<p>对应栈操作：出现左括号时压入栈中，出现右括号时弹出栈顶并检查括号类型是否匹配</p>
<p>停止扫描，并给出括号不匹配结论的情况：</p>
<ul>
<li>括号类型不匹配</li>
<li>扫描到右括号时栈已空，说明多出了一个右括号</li>
<li>扫描完所有括号时栈不为空，说明多出了一个左括号</li>
</ul>
<p>代码实现：顺序栈，数据类型为char</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    SqStack s = initiate();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            push(&amp;s, str[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(empty(&amp;s))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            pop(&amp;s, &amp;topElem);</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> empty(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表达式求值">表达式求值</h4>
<p>中缀表达式：运算符在两个操作数中间，例如<code>a+b-c</code>;</p>
<p>后缀表达式（逆波兰表达式）：运算符在两个操作数后面，例如<code>ab+c-</code>;</p>
<p>前缀表达式（波兰表达式）：运算符在两个操作数前面，例如<code>- +ab c</code>;</p>
<p>中缀表达式向后缀/前缀表达式转换步骤：</p>
<ul>
<li>按照左优先原则（后缀）或右优先原则（前缀）确定中缀表达式中运算符的顺序</li>
<li>按照运算符顺序依次转换表达式</li>
</ul>
<p>栈的应用：</p>
<ul>
<li>中缀表达式转后缀/前缀表达式</li>
<li>计算后缀/前缀表达式</li>
</ul>
<p><strong>后缀表达式</strong></p>
<p>中缀表达式按照<strong>左优先原则</strong>转换为后缀表达式之后，运算符在计算机中的实际执行顺序就是其在后缀表达式中<strong>从左到右</strong>出现的顺序;</p>
<p>计算方式：<strong>从左往右</strong>扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，并合并为一个操作数；</p>
<p>栈实现方式：<strong>从左往右</strong>扫描，遇到操作数压入栈，遇到运算符，弹出<strong>两个</strong>栈顶元素，执行相应运算，并将运算结果压回栈顶，继续扫描，如果表达式合法，则最后栈中只会留下一个元素，就是最终的结果；</p>
<p>注意：先出栈的是<strong>右操作数</strong>；</p>
<p><strong>前缀表达式</strong></p>
<p>中缀表达式按照<strong>右优先原则</strong>转成前缀表达式后，运算符在计算机中的实际执行顺序就是其在前缀表达式中<strong>从右到左</strong>出现的顺序；</p>
<p>计算方式：<strong>从右往左</strong>扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，并合并为一个操作数；</p>
<p>栈实现方式：<strong>从右往左</strong>扫描，遇到操作数压入栈，遇到运算符，弹出<strong>两个</strong>栈顶元素，执行相应运算，并将运算结果压回栈顶，继续扫描，如果表达式合法，则最后栈中只会留下一个元素，就是最终的结果；</p>
<p>注意：先出栈的是<strong>左操作数</strong>；</p>
<h5 id="中缀表达式转后缀表达式的实现">中缀表达式转后缀表达式的实现</h5>
<p>中缀表达式转后缀表达式后，操作数出现的顺序是不变的，变化的只有运算符的顺序，因此需要初始化<strong>一个栈</strong>，用于<strong>存储暂时还不能确定运算顺序的运算符</strong>。</p>
<p>从左到右处理各个元素，直到末尾，每个元素有三种情况：</p>
<ul>
<li>操作数，直接加入后缀表达式；</li>
<li>界限符，遇到<code>(</code>直接入栈，遇到<code>)</code>则依次弹出栈内运算符并加入后缀表达式，直到弹出<code>(</code>为止。注意：<code>(</code>不加入后缀表达式；</li>
<li>运算符，弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若无满足条件的运算符，或栈顶符号为<code>(</code>或栈空，则停止弹出，把当前扫描的运算符入栈；扫描完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式；</li>
</ul>
<p>代码实现：顺序栈，数据类型为<code>char</code></p>
<p>代码缺点：只能处理操作数为<code>0~9</code>的数字字符，以及四则运算操作符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">convert</span><span class="params">(<span class="type">char</span> *str, <span class="type">char</span> *res, <span class="type">int</span> strLength, <span class="type">int</span>* resLength)</span>&#123;</span><br><span class="line">    SqStack s = initiate();</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="type">char</span> topElem;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strLength; i++)&#123;</span><br><span class="line">        <span class="comment">// 数字或字母直接加入后缀表达式</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isalnum</span>(str[i]) )&#123;</span><br><span class="line">            res[cnt] = str[i];</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 碰到左括号直接入栈</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                push(&amp;s, str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 碰到右括号，弹出左括号及之后的所有元素并将非括号运算符添加到后缀表达式</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pop(&amp;s, &amp;topElem) &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    res[cnt] = topElem;</span><br><span class="line">                    cnt ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 优先级低的+和-</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!empty(&amp;s) &amp;&amp; top(&amp;s) != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    pop(&amp;s, &amp;res[cnt]);</span><br><span class="line">                    cnt ++;</span><br><span class="line">                &#125;</span><br><span class="line">                push(&amp;s, str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 优先级高的×和÷</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!empty(&amp;s) &amp;&amp; top(&amp;s) != <span class="string">&#x27;(&#x27;</span> &amp;&amp; top(&amp;s) != <span class="string">&#x27;+&#x27;</span> &amp;&amp; top(&amp;s) != <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                    pop(&amp;s, &amp;res[cnt]);</span><br><span class="line">                    cnt ++;</span><br><span class="line">                &#125;</span><br><span class="line">                push(&amp;s, str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = s.top; j &gt; <span class="number">-1</span>; j--)&#123;</span><br><span class="line">        pop(&amp;s, &amp;res[cnt]);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    *resLength = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计算后缀表达式的实现">计算后缀表达式的实现</h5>
<p>计算过程的实现实际上是在上述“中缀转后缀”的基础上，加上下面的逻辑实现的：</p>
<ul>
<li>每弹出一个运算符，要一并弹出两个操作数进行相应运算；</li>
</ul>
<p>具体代码实现的不同之处在于：</p>
<ul>
<li>“转换”的过程只创建了一个运算符栈，用于存放未知优先顺序的运算符；</li>
<li>"计算"的过程需要创建两个栈，除了运算符栈之外，还需要一个操作数栈，以便可以在弹出运算符时一并弹出对应的两个操作数进行运算；</li>
<li>在执行完一次运算后，需要将运算结果压回操作数栈，作为一个新的<strong>左操作数</strong>；</li>
</ul>
<p>两种情况：</p>
<ul>
<li>扫描到操作数，直接压入操作数栈；</li>
<li>扫描到运算符，按转换的规则进行运算符的压入栈和弹出栈操作，执行弹出运算符时一并弹出对应的两个操作数进行运算，并将运算结果压回操作数栈；</li>
</ul>
<p>代码实现：顺序栈，数据类型为<code>int</code>，需要将操作数字符通过减去字符<code>0</code>转为<code>int</code>类型，运算符通过ASCII码转为<code>int</code>类型，统一操作数与运算符的类型，以免定义两种类型的栈。</p>
<p>代码缺点：只能处理操作数为<code>0~9</code>的数字字符，以及四则运算操作符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cvtAndCalc</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> strLength)</span>&#123;</span><br><span class="line">    <span class="comment">//  +:43  -:45  *:42  /:47  (:40  ):41</span></span><br><span class="line">    SqStack operators = initiate();</span><br><span class="line">    SqStack oprands = initiate();</span><br><span class="line">    <span class="type">int</span> topOperator; <span class="type">int</span> left; <span class="type">int</span> right;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strLength &amp;&amp; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        <span class="comment">// 操作数直接压入栈</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isalnum</span>(str[i]) )&#123;</span><br><span class="line">            push(&amp;oprands, (<span class="type">int</span>)str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 碰到左括号直接入栈</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                push(&amp;operators, (<span class="type">int</span>)str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 碰到右括号，弹出左括号及之后的所有运算符并做相应运算与压栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pop(&amp;operators, &amp;topOperator) &amp;&amp; topOperator != <span class="number">40</span>)&#123;</span><br><span class="line">                    pop(&amp;oprands, &amp;right); <span class="comment">// 先出栈的是右操作数</span></span><br><span class="line">                    pop(&amp;oprands, &amp;left);</span><br><span class="line">                    push(&amp;oprands, calc(left, right, topOperator)); <span class="comment">// 计算结果压回操作数栈</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 优先级低的+和-</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!empty(&amp;operators) &amp;&amp; top(&amp;operators) != <span class="number">40</span>)&#123;</span><br><span class="line">                    pop(&amp;operators, &amp;topOperator);</span><br><span class="line">                    pop(&amp;oprands, &amp;right);</span><br><span class="line">                    pop(&amp;oprands, &amp;left);</span><br><span class="line">                    push(&amp;oprands, calc(left, right, topOperator));</span><br><span class="line">                &#125;</span><br><span class="line">                push(&amp;operators, (<span class="type">int</span>)str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 优先级高的×和÷</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!empty(&amp;operators) &amp;&amp; top(&amp;operators) != <span class="number">40</span> &amp;&amp; top(&amp;operators) != <span class="number">43</span> &amp;&amp; top(&amp;operators) != <span class="number">45</span>)&#123;</span><br><span class="line">                    pop(&amp;operators, &amp;topOperator);</span><br><span class="line">                    pop(&amp;oprands, &amp;right);</span><br><span class="line">                    pop(&amp;oprands, &amp;left);</span><br><span class="line">                    push(&amp;oprands, calc(left, right, topOperator));</span><br><span class="line">                &#125;</span><br><span class="line">                push(&amp;operators, (<span class="type">int</span>)str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pop(&amp;operators, &amp;topOperator);</span><br><span class="line">    pop(&amp;oprands, &amp;right);</span><br><span class="line">    pop(&amp;oprands, &amp;left);</span><br><span class="line">    <span class="keyword">return</span> calc(left, right, topOperator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> operator)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;left = %d, right = %d, operator = %d，&quot;</span>, left, right, operator);</span><br><span class="line">    <span class="keyword">switch</span> (operator)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">43</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, left+right);</span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">45</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, left-right);</span><br><span class="line">            <span class="keyword">return</span> left - right;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">42</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, left*right);</span><br><span class="line">            <span class="keyword">return</span> left * right;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">47</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, left/right);</span><br><span class="line">            <span class="keyword">return</span> left / right;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;result = default\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">input</span><span class="params">(<span class="type">char</span> str[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="type">char</span> x;</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt; <span class="number">99</span> &amp;&amp; <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;x) == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( (<span class="type">int</span>)x &lt; <span class="number">40</span> || (<span class="type">int</span>)x &gt; <span class="number">57</span> || (<span class="type">int</span>)x == <span class="number">44</span> || (<span class="type">int</span>)x == <span class="number">46</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str[cnt] = x;</span><br><span class="line">        cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归">递归</h4>
<p>递归函数调用的特点：最后被调用的（即最深层的）函数最先执行（LIFO）；</p>
<p>函数调用时，需要用一个栈（称为递归工作栈）存储：</p>
<ul>
<li>每层递归执行结束后下一个语句的地址；</li>
<li>传递给函数的实参以及在函数内部定义的局部变量等信息；</li>
</ul>
<p>栈工作过程：</p>
<ul>
<li>每进入一层递归，就将该层递归所需信息压入栈顶（包括上面的两点）；</li>
<li>每退出一层递归，就从栈定弹出相应层的信息；</li>
</ul>
<p>递归算法的缺点：递归层数过多会导致栈溢出，且空间复杂度会越来越高,另外多重递归容易包含很多重复的计算;</p>
<h3 id="队列的应用">队列的应用</h3>
<ul>
<li><p>树的层次遍历：将根结点入队,每次都将队头结点的左右孩子入队,并将队头结点出队，依次类推；</p></li>
<li><p>图的广度优先搜索：将出发点入队，每次都将队头结点的未遍历邻接结点入队，并将队头结点出队,以此类推；</p></li>
<li><p>操作系统处理多进程并发的资源分配问题：<strong>FCFS</strong>(First
Come First
Service，先到先得)，将所有进程依次入队(就绪进程队列)，CPU每次执行队头进程一小段时间，然后将队头进程出队并重新在队尾入队，依次往复；</p></li>
<li><p>打印数据缓冲区：多台电脑使用同一台打印机时，使用队列按照先来后到的顺序存储提交的打印数据，只打印队头数据即可。缓解了主机与打印机处理速度不匹配的问题；</p></li>
</ul>
<h3 id="矩阵的压缩存储">矩阵的压缩存储</h3>
<blockquote>
<p>矩阵中，<span class="math inline">\(i-j\)</span> 的意义是元素 <span
class="math inline">\(a_{i,j}\)</span>
在列方向上与主对角线元素的距离，同理 <span
class="math inline">\(j-i\)</span>
表示行方向上与主对角线元素的距离；</p>
</blockquote>
<h4 id="一维数组">一维数组</h4>
<p>各个元素大小相同，且物理上连续存放，只需要知道数组起始地址，就可以知道任意数组下标对应元素的物理地址，计算方式为<code>&amp;a[i] = LOC + i * sizeof(ElemType)</code>，其中<code>LOC</code>代表起始地址，即数组第一个元素的地址，注意由于下标从0开始，<code>i</code>的范围限制在<code>[0, size)</code>，其中<code>size</code>表示数组元素总个数；</p>
<h4 id="二维数组">二维数组</h4>
<p>计算机的存储空间是线性连续的，因此需要将非线性的二维数组转化成线性的存储结构</p>
<p>两种存储方式：</p>
<ul>
<li>行优先：将矩阵一行一行地存入线性连续的内存空间中，第<code>i</code>行行末元素与第<code>i+1</code>行行首元素物理地址相邻；</li>
<li>列优先：将矩阵一列一列地存入线性连续的内存空间中，第<code>i</code>列列尾元素与第<code>i+1</code>列列首元素物理地址相邻；</li>
</ul>
<p>优点：支持随机访问，只要给出元素的行列索引，就可以基于第一行第一列的元素地址算出指定元素的地址，假定数组规格为
<code>M × N</code>，计算方式为：</p>
<ul>
<li>行优先：<code>&amp;b[i][j] = LOC + (i * N + j) * sizeof(ElemType)</code></li>
<li>列优先：<code>&amp;b[i][j] = LOC + (j * M + i) * sizeof(ElemType)</code></li>
</ul>
<h4 id="普通矩阵">普通矩阵</h4>
<p>使用二维数组的方式存储；</p>
<p>注意在数学上描述矩阵元素时，行、列号通常从1开始，而使用数组描述时通常下标从0开始；</p>
<h4 id="对称矩阵">对称矩阵</h4>
<p>概念：若 <span class="math inline">\(n\)</span> 阶方阵中任意一个元素
<span class="math inline">\(a_{i,j}\)</span> 都有 <span
class="math inline">\(a_{i,j} =
a_{j,i}\)</span>，则该矩阵称为对称矩阵；</p>
<p>特点：关于主对角线对称，上三角区 <span
class="math inline">\(i&lt;j\)</span>，下三角区 <span
class="math inline">\(i &gt; j\)</span>；</p>
<p>压缩存储策略：只存储主对角线与下三角区的数据；</p>
<p>行优先压缩存储方式：</p>
<ul>
<li><p>按行优先原则将各元素存入一维数组中，总共需要存储 <span
class="math inline">\(\sum_{i=1}^ni\)</span> 个数据，最后一个数据 <span
class="math inline">\(a_{n,n}\)</span>；</p></li>
<li><p>将矩阵行列号映射到一维数组索引的方式：<span
class="math inline">\(a_{i,j}\)</span> 对应下标 <span
class="math inline">\(k =
\sum_{n=1}^{i-1}n+j-1\)</span>，减去1是因为数组元素从0开始；</p></li>
<li><p>访问上半区元素时，只需求对称元素索引即可；</p></li>
</ul>
<p>列优先压缩存储方式：</p>
<ul>
<li>第一点和第三点除了列优先外，其他不变；</li>
<li><span class="math inline">\(a_{i,j}\)</span> 对应下标 <span
class="math inline">\(k = \sum_{n =
M}^{M-(j-1)+1}n+(i-j)+1-1\)</span>，求和求的是前 <span
class="math inline">\(j-1\)</span> 列的元素个数，<span
class="math inline">\((i-j)\)</span> 求的是从第 <span
class="math inline">\(i\)</span> 行的主对角线元素开始（不包括）到第
<span class="math inline">\(j\)</span>
列元素的步数，加1是为了补上主对角线元素，减1是因为数组元素从0开始；</li>
</ul>
<h4 id="三角矩阵">三角矩阵</h4>
<p><strong>下三角矩阵</strong></p>
<p>除了主对角线和下三角区，其余元素都相同的矩阵；</p>
<p>压缩存储策略：按行优先原则将橙色区元素存入一维数组中，并在最后一个位置存储上三角区常量；</p>
<p>矩阵行列号对应数组索引（从0开始）：下三角区 <span
class="math inline">\(k = \sum_{n=1}^{i-1}n+j-1\)</span> 上三角区 <span
class="math inline">\(\sum_{n=1}^{i-1}n\)</span>（即数组末尾存储的常量）；</p>
<p><strong>上三角矩阵</strong></p>
<p>行优先：上三角区 <span class="math inline">\(k =
\sum_{n=N}^{N-(i-1)+1}n+(j-i)+1-1\)</span> 上三角区 <span
class="math inline">\(\sum_{n=1}^{i-1}n\)</span>（即数组末尾存储的常量）；</p>
<h4 id="三对角矩阵">三对角矩阵</h4>
<p>概念：当 <span class="math inline">\(|i-j| &gt; 1\)</span> 时，满足
<span class="math inline">\(a_{i,j}=0\)</span>
的矩阵；<strong>又称带状矩阵</strong>；</p>
<p>特点：只有主对角线以及与主对角线相邻的两侧对角线上的元素可以非0；</p>
<p>压缩存储策略：</p>
<ul>
<li>只存储带状部分，按照行优先原则，除了第一行和最后一行只有两个元素之外，其余每行都是三个元素；</li>
<li>总共需要存储 <span class="math inline">\(3n-2\)</span> 个数据；</li>
<li>前 <span class="math inline">\(i-1\)</span> 行共 <span
class="math inline">\(3(i-1)-1\)</span> 个元素，而整体矩阵中的 <span
class="math inline">\(a_{i,j}\)</span> 在只看带状部分时是第 <span
class="math inline">\(i\)</span> 行第 <span
class="math inline">\(j-i+2\)</span> 个元素，相加可得索引 <span
class="math inline">\(k=2i+j-2-1\)</span> 减一由于索引从0开始；</li>
<li>如果知道索引 <span class="math inline">\(k\)</span>
要反推行列号，可知 <span class="math inline">\(k+1\)</span>
（加一抵消索引0）一定大于前 <span class="math inline">\(i-1\)</span>
行元素的总个数，且不大于前 <span class="math inline">\(i\)</span>
行元素总个数，通过 <span class="math inline">\(3(i-1)-1&lt;k+1\le
3i-1\)</span> 可解出一个 <span class="math inline">\(i\)</span> 关于
<span class="math inline">\(k\)</span> 的不等式，向上取整即可得到 <span
class="math inline">\(i\)</span> 的值，最后通过索引转换公式求出 <span
class="math inline">\(j\)</span> 的值；</li>
</ul>
<h4 id="稀疏矩阵">稀疏矩阵</h4>
<p>概念：非零元素远远少于矩阵元素总个数的矩阵；</p>
<p>压缩存储策略</p>
<ul>
<li>普通策略：使用结构体模拟三元组，按照“行-列-值”的形式存储非零元素，最后存储在顺序里即可；
<ul>
<li>缺点：无法随机访问或随机存取</li>
</ul></li>
<li>十字链表法：对于 <span class="math inline">\(M×N\)</span>
的矩阵，定义向下域指针和向右域指针
<ul>
<li>向下域指针代表列，第 <span class="math inline">\(j\)</span>
个向下域指针指向第 <span class="math inline">\(j\)</span>
列第一个元素；</li>
<li>向右域指针代表行，第 <span class="math inline">\(i\)</span>
个向右域指针指向第 <span class="math inline">\(i\)</span>
行第一个元素；</li>
<li>每个元素是一个结构体，存储内容包含“行-列-值”三个数据项与两个指针项，其中一个指针指向同列的下一个元素，另一个指针指向同行的下一个元素；</li>
</ul></li>
</ul>
<h2 id="chapter4-串">Chapter4 串</h2>
<h3 id="串的概念">串的概念</h3>
<h4 id="基本概念-1">基本概念</h4>
<p>串：即字符串，是由零个或多个字符组成的有限序列，一般记为 <span
class="math inline">\(S=`a_1a_2a_3\dots a_n&#39;\)</span>（<span
class="math inline">\(n\ge 0\)</span>），其中 <span
class="math inline">\(S\)</span>
是串名，单引号（双引号）括起来的字符序列是串的值；<span
class="math inline">\(a_i\)</span>
可以是字母、数字或其他字符；串中字符的个数 <span
class="math inline">\(n\)</span> 称为串的长度。<span
class="math inline">\(n=0\)</span> 时的串称为空串（用 <span
class="math inline">\(\phi\)</span> 表示）；</p>
<p>子串：串中任意个<strong>连续的</strong>字符组成的子序列；</p>
<p>主串：包含子串的串；</p>
<p>字符在主串中的位置：字符在串中的序号（<strong>从1开始数</strong>）；</p>
<p>子串在主串中的位置：子串的第一个字符在主串中的位置；</p>
<p>任何数据存到计算机中一定是二进制数，需要有一些编码以及相应的编码规则，使一个字符对应一组二进制数；</p>
<p>常见的字符集与对应编码规则有：</p>
<ul>
<li>英文字符集：ASCII</li>
<li>中英文字符集：Unicode，对应编码规则：UTF-8，UTF-16等</li>
</ul>
<p>同一个字符集可以有多种编码规则，例如，使用 <span
class="math inline">\(x\)</span> 的定义域表示一个字符集，<span
class="math inline">\(f\)</span> 表示编码规则，<span
class="math inline">\(y\)</span> 表示一部分二进制数，映射 <span
class="math inline">\(y=f(x)\)</span>
就可以表示字符编码的过程与结果，编码规则不同，值域 <span
class="math inline">\(y\)</span>
（即对应的一部分二进制数）也不一样；</p>
<h4 id="串与线性表的关系">串与线性表的关系</h4>
<p>串是一种特殊的线性表，数据元素之间呈线性关系；</p>
<p>串的数据对象限定为字符集，如中文字符、英文字符、数字字符、标点字符等；</p>
<p>串的基本操作通常以子串为操作对象；</p>
<p>串的基本操作：赋值、复制、判空、求串长、清空、销毁、串联接、求子串、定位操作、比较操作；</p>
<h3 id="串的存储结构">串的存储结构</h3>
<p><strong>顺序存储</strong></p>
<p>有些顺序存储的方式会将第一个元素设置为<code>length</code>，这样串在数组中的起始位置就从1开始，但该方式缺点在于将<code>length</code>的范围限制在了255以内；</p>
<p>还有一种方案是在数组末尾存储一个字符<code>\0</code>表示<code>null</code>，用户回收<code>char*</code>，但这种方式不利于统计串长；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 255</span></span><br><span class="line"><span class="comment">// 静态顺序表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAX];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; StaticString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态顺序表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; DynamicString;</span><br></pre></td></tr></table></figure>
<p><strong>链式存储</strong></p>
<p>可通过将每一个节点内存储的数据由一个字符改为多个字符，增加存储密度；</p>
<p>使用第二种方式时，若最后一个结点填充不满，可以手动填充几个特殊字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span>；</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; StringNode, * String;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; StringNode, * String;</span><br></pre></td></tr></table></figure>
<h3 id="基本操作">基本操作</h3>
<blockquote>
<p>以下代码中顺序串首个元素均置空，以达到从“1”开始计算字符序号的一致性</p>
</blockquote>
<p>深拷贝</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态顺序串</span></span><br><span class="line">DynamicString* dstString = (DynamicString*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*srcString));</span><br><span class="line">dstString.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; srcString-&gt;length+<span class="number">1</span>; i++)&#123;</span><br><span class="line">    dstString-&gt;ch[i] = srcString-&gt;ch[i];</span><br><span class="line">    dstString-&gt;length ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链串（带头结点）</span></span><br><span class="line">StringNode* dstString = (StringNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StringNode)); <span class="comment">//头结点</span></span><br><span class="line">dstString-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">StringNode* endNode = dstString;</span><br><span class="line"><span class="keyword">for</span>(StringNode* p = srcString-&gt;next; p != <span class="literal">NULL</span>; p=p-&gt;next)&#123;</span><br><span class="line">    StringNode* s = (StringNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StringNode));</span><br><span class="line">    s-&gt;ch = p-&gt;ch;</span><br><span class="line">    s-&gt;next = endNode-&gt;next;</span><br><span class="line">    endNode-&gt;next = s;</span><br><span class="line">    endNode = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判空、求串长、清空与销毁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>.length == <span class="number">0</span>; <span class="comment">// 顺序串</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>-&gt;next == <span class="literal">NULL</span>; <span class="comment">// 链串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求串长</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>.length; <span class="comment">//顺序串</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 链串</span></span><br><span class="line"><span class="keyword">for</span>(StringNode* p = <span class="built_in">string</span>-&gt;next; p != <span class="literal">NULL</span>; p=p-&gt;next) cnt++;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序串清空</span></span><br><span class="line"><span class="built_in">string</span>.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链串销毁</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">string</span>-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    StringNode* p = <span class="built_in">string</span>-&gt;next;</span><br><span class="line">    <span class="built_in">string</span>-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求子串：返回从主串第pos个字符起长度为len的子串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">subString</span><span class="params">(StaticString* src, StaticString* dst, <span class="type">int</span> pos, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos+(len<span class="number">-1</span>) &gt; src-&gt;length) <span class="comment">//减一因为pos位置也包含在len里面</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = pos; i &lt; pos+len; i++)</span><br><span class="line">        dst-&gt;ch[i-pos+<span class="number">1</span>] = src-&gt;ch[i];</span><br><span class="line">    dst-&gt;length = len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较大小：返回值大于0说明前者大，小于0说明后者大，等于0说明相等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(StaticString* first, StaticString* second)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; first-&gt;length+<span class="number">1</span> &amp;&amp; i &lt; second-&gt;length+<span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;ch[i] != second-&gt;ch[i])</span><br><span class="line">            <span class="keyword">return</span> first-&gt;ch[i] - second-&gt;ch[i];</span><br><span class="line">    <span class="keyword">return</span> first-&gt;length - second-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子串定位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">locate</span><span class="params">(StaticString* mainStr, StaticString* subStr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = mainStr-&gt;length;</span><br><span class="line">    <span class="type">int</span> m = subStr-&gt;length;</span><br><span class="line">    StaticString tempSub; tempSub.length = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; (n-m+<span class="number">1</span>)+<span class="number">1</span>)&#123;</span><br><span class="line">        subString(mainStr, &amp;tempSub, i, m);</span><br><span class="line">        <span class="keyword">if</span>(compare(&amp;tempSub, subStr) != <span class="number">0</span>)</span><br><span class="line">            i ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 置空位，表示无对应子串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="串的朴素模式匹配算法">串的朴素模式匹配算法</h3>
<blockquote>
<p>长度为n的主串有(n-m+1)个长度为m的子串，可以理解为长度为m的串的第一个元素可在主串中平移几格（初始为1）</p>
</blockquote>
<p>串的模式匹配：在主串中找到与模式串相同的子串，并返回其定位；</p>
<p>通过直接操作串的数组数据实现子串定位，而不使用上面的函数；</p>
<p>多数情况下，模式串的长度要远远小于主串的长度；</p>
<p>若模式串长度为m，主串长度为n，则</p>
<ul>
<li><p>匹配成功的最好时间复杂度：<span
class="math inline">\(O(m)\)</span>，对应的情况是第一个子串就与模式串匹配，只需要执行m次判断相等的操作；</p></li>
<li><p>匹配失败的最好时间复杂度：<span class="math inline">\(O(n-m+1) =
O(n-m) \approx
O(n)\)</span>，对应的情况是每个子串的第一个字符就与模式串匹配；</p></li>
<li><p>匹配成功或失败的最坏时间复杂度：<span
class="math inline">\(O((n-m+1)*m) \approx
O(nm)\)</span>，对应的情况是每个子串都直到最后一个字符才不匹配；</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">match</span><span class="params">(StaticString* mainStr, StaticString* subStr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mainStr-&gt;length &amp;&amp; j &lt; subStr-&gt;length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mainStr-&gt;ch[i] == subStr-&gt;ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            k++;</span><br><span class="line">            i = k;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; subStr-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kmp算法">KMP算法</h3>
<blockquote>
<p>串指针的回溯相当于把串整体右移若干个单位；</p>
<p>串的前缀：包含第一个字符且不包含最后一个字符的子串；（后缀相反）</p>
</blockquote>
<p>KMP算法是朴素模式匹配算法的优化，由 <span
class="math inline">\(\mathrm {D.E.Knuth}\)</span>，<span
class="math inline">\(\mathrm {J.H.Morris}\)</span> 和 <span
class="math inline">\(\mathrm {V.R.Pratt}\)</span>
提出，也是算法名称的由来；</p>
<p>朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针经常回溯，导致时间开销增加；</p>
<p>KMP对朴素的改进思路：主串指针不回溯，只回溯模式串指针，关键点在于模式串指针应该回溯到什么位置；</p>
<p>kmp算法的平均时间复杂度为：<span
class="math inline">\(O(n+m)\)</span>，其中 <span
class="math inline">\(O(n)\)</span> 来自于kmp本身（主串长度），<span
class="math inline">\(O(m)\)</span>
来自于求<code>next</code>数组的函数（模式串长度）；</p>
<p>模式串指针回溯位置数组的计算方式：</p>
<ul>
<li>当模式串第 <span class="math inline">\(j\)</span>
个字符匹配失败时，将模式串前 <span class="math inline">\(1～j-1\)</span>
个字符组成的串记为 <span class="math inline">\(S\)</span>，则
<code>next[j]</code> 等于 <span class="math inline">\(S\)</span>
的最长相等前后缀长度+1；</li>
<li>特殊：<code>next[1] = 0;</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求模式串的回溯位数组next</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(StaticString modeStr, <span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; modeStr.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || modeStr.ch[i] == modeStr.ch[j])&#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kmp</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kmp</span><span class="params">(StaticString mainStr, StaticString modeStr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> next[mainStr.length + <span class="number">1</span>];</span><br><span class="line">    getNext(modeStr, next);</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mainStr.length + <span class="number">1</span> &amp;&amp; j &lt; modeStr.length + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || mainStr.ch[i] == modeStr.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; modeStr.length)</span><br><span class="line">        <span class="keyword">return</span> i - modeStr.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>KMP算法的进一步优化</strong></p>
<p>上述kmp的缺点：<code>next[j]</code>指向的字符与<code>j</code>处字符是一致的，再进行结果已知的重复对比造成了浪费；</p>
<p>优化方案：针对<code>next</code>数组，使<code>j</code>从2开始递增，当<code>modeStr[j] == modeStr[next[j]]</code>时，设置<code>next[j] = next[next[j]]</code>，省略重复的对比；</p>
<p>在<code>getNext</code>函数末尾加上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt; modeStr.length + <span class="number">1</span>; k++)</span><br><span class="line">    <span class="keyword">if</span>(modeStr.ch[k] == modeStr.ch[next[k]])</span><br><span class="line">        next[k] = next[next[k]];</span><br></pre></td></tr></table></figure>
<h2 id="chapter5-树">Chapter5 树</h2>
<h3 id="树的基本概念">树的基本概念</h3>
<p>树是一种逻辑结构；</p>
<p>树是 <span class="math inline">\(n(n&gt;0)\)</span>
个结点的有限集合，当 <span class="math inline">\(n=0\)</span>
时，称为空树；</p>
<p>任意非空树都应该满足：</p>
<ul>
<li>有且仅有一个特定的称为根的结点；</li>
<li>当 <span class="math inline">\(n&gt;1\)</span> 时，其余结点可分为
<span class="math inline">\(m(m&gt;0)\)</span>
个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根结点的子树；</li>
</ul>
<p><span class="math inline">\(n\)</span> 个结点的树中只有 <span
class="math inline">\(n-1\)</span>
条边，因为除了根结点外，每个结点都有且仅有一个前驱结点；</p>
<p><strong>基本术语</strong></p>
<p>祖先结点与子孙结点：从根节点出发到达某一结点形成路径，路径的终点为其他所有结点的子孙结点，其他所有结点都是路径终点的祖先结点；</p>
<p>双亲结点与孩子结点：离某结点最近的祖先结点（即前驱结点）称为该结点的双亲结点，反之是孩子结点；</p>
<p>兄弟结点：有同一个双亲结点的结点；</p>
<p>度：树中一个结点的子结点的个数；</p>
<p>树的度：树中的最大度数；</p>
<p>分支结点：度大于0的结点（即有孩子结点）；</p>
<p>叶子结点：度等于0的结点（无孩子结点）；</p>
<p>结点的层次：字面意思，第一层也可能称为第0层；</p>
<p>结点的高度：从最底层开始往上累加至该结点的层数和；</p>
<p>结点的深度：从最顶层开始往下累加至该结点的层数和；</p>
<p>树的高度/深度：树中结点的最大层数；</p>
<p>有序树：从左到右每一个子树都是有次序的，调换顺序后树改变；</p>
<p>无序数：子树没有先后次序，调换顺序后树不变；</p>
<p>路径：从一结点到另一个结点所经过的所有结点组成的序列；</p>
<ul>
<li>由于树的分支是有向的（双亲结点-&gt;孩子结点），因此路径只能是自上而下；</li>
<li>路径长度：路径上所经过的边的个数；</li>
</ul>
<p>森林：<span class="math inline">\(m(m\ge0)\)</span>
棵互不相交的树的集合；</p>
<p><strong>树的性质</strong></p>
<p>树中的结点个数等于所有结点的度数加1（加上根结点）；</p>
<p>度为 <span class="math inline">\(m\)</span> 的树中第 <span
class="math inline">\(i\)</span> 层上至多有 <span
class="math inline">\(m^{i-1}\)</span> 个结点（<span
class="math inline">\(i\ge1\)</span>）；</p>
<p>高度为 <span class="math inline">\(h\)</span> 的 <span
class="math inline">\(m\)</span> 叉树至多有 <span
class="math inline">\(\cfrac{m^h-1}{m-1}\)</span>
个结点（上一个结论等比数列求和）；</p>
<p>具有 <span class="math inline">\(n\)</span> 个结点的 <span
class="math inline">\(m\)</span> 叉树的最小高度为 <span
class="math inline">\(h_{min} = \lceil \log_m(n(m-1)+1)
\rceil\)</span>；</p>
<ul>
<li>该结论的情况是“除了最后一层外，每一层的结点数都要达到最大值”；</li>
<li>上一条结论的情况是“每一层的结点数都要达到最大值”；</li>
<li>通过令 <span class="math inline">\(\cfrac{m^h-1}{m-1} = n\)</span>
解出的 <span class="math inline">\(h_{min}\)</span>
很可能是小数，需要向上取整以全部包含，但最后一层结点个数就不是最大值了；</li>
</ul>
<h3 id="二叉树的概念">二叉树的概念</h3>
<p>二叉树是 <span class="math inline">\(n(n&gt;0)\)</span>
个结点的有限集合</p>
<ul>
<li>当 <span class="math inline">\(n=0\)</span> 时，二叉树为空；</li>
<li>当 <span class="math inline">\(n&gt;0\)</span>
时，由根节点和两个互不相交的被称为根的左子树和右子树组成，它们也分别是一棵二叉树；</li>
</ul>
<p>二叉树的五种基本形态：空树、根节点、根节点+左子数、根节点+右子树、根节点+左右子树；</p>
<p>二叉树结点编号方式：从上到下，从左到右；</p>
<p>二叉树的五条性质:</p>
<ul>
<li><p>非空二叉树的叶子结点数等于度为2的结点数+1，即 <span
class="math inline">\(n_0 = n_2+1\)</span>；</p>
<ul>
<li>推导方式：总结点数的计算方式 <span
class="math inline">\(n=n_0+n_1+n_2\)</span> 或 <span
class="math inline">\(n = n_1+2n_2+1\)</span>，联立可得上式；</li>
</ul></li>
<li><p>非空二叉树上第 <span class="math inline">\(k\)</span> 层上至多有
$2^{k-1} $ 个结点（<span class="math inline">\(k\ge1\)</span>）</p></li>
<li><p>高度为 <span class="math inline">\(h\)</span> 的二叉树至多有
<span class="math inline">\(2^h-1\)</span> 个结点（<span
class="math inline">\(h\ge1\)</span>）</p></li>
<li><p>结点 <span class="math inline">\(i\)</span> 所在的层次为 <span
class="math inline">\(\lfloor\log_2i\rfloor+1\)</span>；</p></li>
<li><p>完全二叉树的性质；</p></li>
</ul>
<p><strong>二叉树 VS 度为2的有序树</strong></p>
<ul>
<li>二叉树可以为空，而度为2的有序数至少有三个结点；</li>
<li>二叉树的孩子结点始终有左右之分，度为2的有序树的孩子结点次序是相对的，意味着当结点只有一个孩子结点时，前者也区分是左孩子还是右孩子，而后者不区分；</li>
</ul>
<p><strong>满二叉树（完美二叉树）</strong></p>
<p>一棵高度为 <span class="math inline">\(h\)</span>，且含有 <span
class="math inline">\(2^h-1\)</span> 个结点的二叉树称为满二叉树；</p>
<ul>
<li>“满”表示左孩子一定在右孩子之前生成；</li>
</ul>
<p>对于编号为 <span class="math inline">\(i\)</span>
的结点，若存在，其双亲结点的编号为 <span class="math inline">\(\lfloor
i/2 \rfloor\)</span>，左孩子为 <span
class="math inline">\(2i\)</span>，右孩子为 <span
class="math inline">\(2i+1\)</span>；</p>
<p><strong>完全二叉树</strong></p>
<p>以满二叉树的顺序生成的二叉树称为完全二叉树（只有最后一层可以不满）；</p>
<ul>
<li>若 <span class="math inline">\(i \le \lfloor n/2
\rfloor\)</span>，则结点 <span class="math inline">\(i\)</span>
为分支结点（取等号的结点为该树的最后一个分支结点），否则为叶子结点；</li>
<li>当 <span class="math inline">\(i &gt; 1\)</span> 时，结点 <span
class="math inline">\(i\)</span> 的双亲结点标号为 <span
class="math inline">\(\lfloor i/2\rfloor\)</span>
<ul>
<li><span class="math inline">\(i\)</span> 为偶数时，双亲结点编号为
<span class="math inline">\(i/2\)</span>，是左孩子；</li>
<li><span class="math inline">\(i\)</span> 为奇数时，双亲结点编号为
<span class="math inline">\((i-1)/2\)</span>，是右孩子；</li>
</ul></li>
<li>当 <span class="math inline">\(2i\le n\)</span> 时，结点 <span
class="math inline">\(i\)</span> 的左孩子编号为 <span
class="math inline">\(2i\)</span>，否则无左孩子（即为叶子结点）；</li>
<li>当 <span class="math inline">\(2i+1\le n\)</span> 时，结点 <span
class="math inline">\(i\)</span> 的右孩子编号为 <span
class="math inline">\(2i+1\)</span>，否则无右孩子；</li>
<li>具有 <span class="math inline">\(n(n&gt;0)\)</span>
个结点的完全二叉树的高度为 <span
class="math inline">\(\lfloor\log_2i\rfloor+1\)</span> 或 <span
class="math inline">\(\lceil \log_2(n+1)\rceil\)</span>；</li>
<li>叶子结点只可能在最深的两层中出现，最深层全是叶子结点，且从左到右顺序排列；</li>
<li>度为1的结点如果存在，则只可能是编号是最大的分支结点，并且孩子结点一定是左结点；</li>
</ul>
<p><strong>二叉排序树</strong></p>
<p>若二叉树非空，且满足以下条件，称为二叉排序树：</p>
<ul>
<li>对任意结点，若存在左子树或右子树，则其左子树上所有结点的关键字均小于该结点，右子树上所有结点的关键字均大于该结点；</li>
</ul>
<p><strong>平衡二叉树</strong></p>
<p>树上任意结点的左子树和右子树的深度差都不超过1的二叉树；</p>
<h3 id="二叉树的存储结构">二叉树的存储结构</h3>
<p>顺序存储：用一个数组依次从上到下、从左到右存储完全二叉树上的结点元素；</p>
<ul>
<li>存储完全二叉树时，只需将之前的 <span
class="math inline">\(i\)</span>
替换成下标，即可计算双亲结点与孩子结点的索引值；</li>
<li>存储非完全二叉树时，需要补全成完全二叉树，并将补充的空结点元素置0，在最坏情况下（从上往下只有右孩子），会浪费很多空间；</li>
<li>数组索引从1开始存储，索引0的位置存储结点的个数；</li>
</ul>
<p>链式存储：用一个数据域<code>data</code>和两个指针域<code>lchild</code>与<code>rchild</code>构建结点创建二叉树即可，缺少孩子结点时将指针域置空；</p>
<ul>
<li>含有 <span class="math inline">\(n\)</span> 个结点的二叉链表中，有
<span class="math inline">\(n+1\)</span> 个空链域；
<ul>
<li>推导方式：空链域个数 = 总指针域的个数(<span
class="math inline">\(2n\)</span>) - 非空链域个数(<span
class="math inline">\((n-1)\)</span>)，除了根结点外，每个结点都有一个双亲结点，即一个非空链域；</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree; </span><br></pre></td></tr></table></figure>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<h4 id="先序中序后序遍历">先序/中序/后序遍历</h4>
<p>遍历逻辑：按某条搜索路径访问树中的每个结点，树的每个结点均被访问一次，而且只被访问一次；</p>
<p>按照根的访问次序，分为三种遍历方式</p>
<ul>
<li>先序遍历：根-&gt;左子树-&gt;右子树</li>
<li>中序遍历：左子树-&gt;根-&gt;右子树</li>
<li>后序遍历：左子树-&gt;右子树-&gt;根</li>
</ul>
<p><img src="5.1.png" style="zoom:80%"></p>
<p><strong>递归实现</strong></p>
<p>时间复杂度均为 <span class="math inline">\(O(n)\)</span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历：124536 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历：425163 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历：452631</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非递归实现</strong></p>
<p>借助栈的思想（LIFO）与功能实现<strong>中序遍历</strong>：</p>
<ul>
<li>初始依次扫描根结点的所有左侧结点并将它们一一进栈；</li>
<li>出栈一个结点，访问它；</li>
<li>扫描该结点右孩子结点并将其进栈；</li>
<li>依次扫描右孩子结点的所有左侧结点并一一进栈，之后回到第二步；</li>
<li>反复该过程直到栈空为止；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    LinkStack s = InitStack();</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> || !isEmpty(&amp;s))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            push(&amp;s, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            pop(&amp;s, p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="层次遍历">层次遍历</h4>
<p>借助队列实现层次遍历：</p>
<ul>
<li>初始将根结点入队并访问根结点；</li>
<li>若有左子树，则将左子树的根入队；</li>
<li>若有右子树，则将右子数的根入队；</li>
<li>出队，访问该结点，并按二三步扫描该结点；</li>
<li>反复该过程直到队列空为止；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">levelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    LinkQueue lq = initiate();</span><br><span class="line">    BiTree p;</span><br><span class="line">    push_back(&amp;lq, T);</span><br><span class="line">    <span class="keyword">while</span>(!empty(lq));&#123;</span><br><span class="line">        pop_front(&amp;lq, p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            push_back(&amp;lq, p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            push_back(&amp;lq, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从遍历序列构造二叉树">从遍历序列构造二叉树</h3>
<p>已知后序或先序遍历序列+中序遍历序列，可确定唯一二叉树；如果只知道后序或先序遍历序列，无法确定唯一二叉树；</p>
<p><strong>例子</strong>：已知中序+先序遍历序列，构造二叉树</p>
<ul>
<li>在先序遍历序列中，第一个结点是根结点；</li>
<li>在中序遍历序列中找到根结点，两侧分别为左子树的和右子树的中序遍历序列；</li>
<li>将中序序列的两部分在先序序列中划分开来，得到左右子树的先序遍历序列，并以各自的第一个结点作为根结点，再回到第二步重复；</li>
</ul>
<p>以此类推，将先序换成后序，除了根节点位置变成最后一个之外，其他一样；</p>
<h3 id="线索二叉树">线索二叉树</h3>
<blockquote>
<p>本节内容中的“前驱”和“后继”指的是在先序/中序/后序遍历序列中相邻结点位置的前后关系</p>
</blockquote>
<p>按照先序/中序/后序遍历序列，依次将每个结点线索化，得到线索二叉树；</p>
<p>线索化（前驱和后继指的是在序列中的前后关系）：</p>
<ul>
<li>若无左子树，将左指针指向其前驱结点；</li>
<li>若无右子树，将右指针指向其后继结点；</li>
</ul>
<p>在结点结构中，添加左标志位<code>ltag</code>和右标志位<code>rtag</code>，标记<code>lchild</code>和<code>rchild</code>指向的是孩子结点（0）还是前驱/后继结点（1）；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure>
<p>由这样的结点结构组成的二叉链表作为二叉树的存储结构时，称为<strong>线索链表</strong>，其中指向前驱或后继结点的指针称为<strong>线索</strong>；</p>
<p>由三种遍历序列构造的线索二叉树分别称为先序线索二叉树、中序线索二叉树（最常用）和后序线索二叉树；</p>
<ul>
<li>中序线索二叉树寻找前驱/后继结点最容易，后序则最繁琐；</li>
</ul>
<p><strong>中序线索二叉树寻找前驱/后继结点的方法</strong></p>
<p>中序遍历序列中第一个结点是树最左侧的结点，最后一个结点是树最右侧的结点；</p>
<p>找前驱结点的方式：</p>
<ul>
<li>若左指针为线索（<code>ltag=1</code>），则其指向的结点为前驱结点；</li>
<li>若左指针为左孩子，则其左子树的最右侧结点为前驱结点；</li>
</ul>
<p>找后继结点的方式：</p>
<ul>
<li>若右指针为线索（<code>rtag=1</code>），则其指向的结点为后继结点；</li>
<li>若右指针为右孩子，则其右子树最左侧结点为后继结点；</li>
</ul>
<p><strong>中序线索二叉树的线索化</strong></p>
<ul>
<li>按中序遍历的顺序递归，思路就是优先线索化左孩子；</li>
<li>若无左子树，将左指针指向前驱结点<code>*pre</code>，并设置当前结点<code>*p-&gt;ltag=1</code>；</li>
<li>当前驱结点非空且没有右孩子时，将前驱结点的右指针指向当前结点（即设置后继结点），并设置<code>*pre-&gt;rtag=1</code>；</li>
<li>修改前驱结点指针指向当前结点，接下去处理当前结点的右子树（此时处于递归层中）；</li>
</ul>
<p>注意，中序遍历序列线索化后，会留下两个空指针，分别是序列中第一个结点的<code>lchild</code>以及最后一个结点的<code>rchild</code>，但是它们的<code>tag</code>都是1；</p>
<p>为了利用这两个空指针，还需另外创建一个头结点，将头结点的<code>lchild</code>指向树的根节点，第一个遍历的结点的<code>lchild</code>指向头结点，头结点的<code>rchild</code>指向最后一个遍历的结点，最后一个遍历的结点的<code>rchild</code>指向头结点；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p为根节点，pre为前驱结点（初始化为NULL）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree* p, ThreadTree* pre)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(&amp;(*p-&gt;lchild), pre);</span><br><span class="line">        <span class="keyword">if</span>(*p-&gt;lchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            *p-&gt;lchild = *pre;</span><br><span class="line">            *p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*pre != <span class="literal">NULL</span>; &amp;&amp; *pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            *pre-&gt;rchild = *p;</span><br><span class="line">            *pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *pre = *p;</span><br><span class="line">        InThread(&amp;(*p-&gt;rchild), pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 调用者</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>:</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(&amp;T, &amp;pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>带头结点的中序线索二叉树的操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找第一个遍历的结点（也是寻找树最左侧的结点）</span></span><br><span class="line">ThreadNode* <span class="title function_">FirstNode</span><span class="params">(ThreadNode* p)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找后继结点（后继必然遵循左-&gt;根-&gt;右的顺序）</span></span><br><span class="line">ThreadNode* <span class="title function_">NextNode</span><span class="params">(ThreadNode* p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> FirstNode(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(ThreadTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode* p = FirstNode(T); p != <span class="literal">NULL</span>; p = NextNode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树的存储结构">树的存储结构</h3>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 56%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>双亲表示法</td>
<td>寻找双亲结点效率高</td>
<td>寻找孩子结点效率低</td>
</tr>
<tr class="even">
<td>孩子表示法</td>
<td>寻找孩子结点效率高</td>
<td>寻找双亲结点效率低</td>
</tr>
<tr class="odd">
<td>孩子兄弟表示法</td>
<td>寻找孩子结点效率高，方便实现树转换为二叉树</td>
<td>寻找双亲结点效率低</td>
</tr>
</tbody>
</table>
<p><strong>双亲表示法</strong></p>
<p>采用一组连续的存储空间来存储每个结点，同时在每个结点中增设伪指针，指示双亲结点在数组中的位置；</p>
<p>根节点下标为0，其伪指针域为-1；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> parent; <span class="comment">// 伪指针</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TreeNode nodes[MAX];</span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// 结点个数</span></span><br><span class="line">&#125; Tree;</span><br></pre></td></tr></table></figure>
<p><strong>孩子表示法</strong></p>
<p>将<strong>每个</strong>结点的孩子结点都用单链表连接起来形成一个线性结构，<span
class="math inline">\(n\)</span> 个结点具有 <span
class="math inline">\(n\)</span> 个孩子链表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">// 孩子结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span>* <span class="title">next</span>;</span> <span class="comment">// 右孩子</span></span><br><span class="line">&#125; CNode;</span><br><span class="line"><span class="comment">// 双亲结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span>* <span class="title">child</span>;</span></span><br><span class="line">&#125; PNode;</span><br><span class="line"><span class="comment">// 树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTree</span>&#123;</span></span><br><span class="line">    PNode nodes[MAX];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure>
<p><strong>孩子兄弟表示法</strong></p>
<p>左指针指向第一个孩子结点，右指针指向兄弟结点；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstChild</span>, *<span class="title">nextSibling</span>;</span></span><br><span class="line">&#125; CSNode, CSTree;</span><br></pre></td></tr></table></figure>
<h3 id="森林和二叉树的相互转换">森林和二叉树的相互转换</h3>
<p>森林是 <span class="math inline">\(m(m&gt;0)\)</span>
棵互不相交的树的集合，当 <span class="math inline">\(m=1\)</span>
时就是将一棵普通的树转化成二叉树；</p>
<p>森林转二叉树：将森林的各个根节点视为兄弟结点，使用孩子兄弟表示法，用<code>nextsibling</code>连接各根结点；</p>
<p>二叉树转森林（本质是用孩子兄弟表示法存储森林为二叉链表）：按照“左孩子右兄弟”的方式从根节点开始转换；</p>
<h3 id="树和森林的遍历">树和森林的遍历</h3>
<p><strong>树的先/后序遍历方式</strong>：与二叉树遍历过程类似，区别在于其子树不一定为2，需要判断是否还有子树；</p>
<p>一棵树的<strong>后序</strong>遍历序列与其转换为二叉树后的<strong>中序</strong>遍历序列相同；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode* R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(R);</span><br><span class="line">        <span class="keyword">while</span>(R仍有未访问子树T)</span><br><span class="line">            PreOrder(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode* R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(R仍有未访问子树T)</span><br><span class="line">            PostOrder(T);</span><br><span class="line">        visit(R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>树的层次遍历</strong>：也可称为树的<strong>广度优先遍历</strong>，用队列实现</p>
<ul>
<li>若树非空，将根结点入队；</li>
<li>若队列非空，将队头元素出队并访问，同时将该结点的孩子结点依次入队；</li>
<li>重复第二步直到队列为空；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode* R)</span>&#123;</span><br><span class="line">    LinkQueue lq = initiate();</span><br><span class="line">    TreeNode* p;</span><br><span class="line">    push_back(&amp;lq, R);</span><br><span class="line">    <span class="keyword">while</span>(!empty(lq));&#123;</span><br><span class="line">        pop_front(&amp;lq, p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">while</span>(p还有未入队的孩子结点)</span><br><span class="line">            push_back(&amp;lq, 未入队孩子结点);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>森林的先序遍历</strong>：与森林转换为<strong>二叉树</strong>后的<strong>先序遍历</strong>序列相同</p>
<ul>
<li>访问第一棵树的根结点；</li>
<li>先序遍历第一棵树中根节点的子树森林（一棵树除去根节点后剩余的部分组成的森林）；
<ul>
<li>递归直到子树森林只有一个结点时进入第三步，开始新一轮递归；</li>
</ul></li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林；</li>
</ul>
<p><strong>森林的中序遍历：</strong>效果等同于<strong>依次</strong>对各个树进行<strong>后序遍历</strong>，或转换为<strong>二叉树</strong>后的<strong>中序遍历</strong>序列</p>
<ul>
<li>中序遍历森林中第一棵树的根结点的子树森林；</li>
<li>访问第一棵树的根节点</li>
<li>中序遍历除去第一棵树只有剩余的树构成的森林；</li>
</ul>
<p>总结，<strong>横向</strong>效果等价</p>
<table>
<thead>
<tr class="header">
<th>树</th>
<th>森林</th>
<th>二叉树</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>先序遍历</td>
<td>先序遍历</td>
<td>先序遍历</td>
</tr>
<tr class="even">
<td>后序遍历</td>
<td>中序遍历</td>
<td>中序遍历</td>
</tr>
</tbody>
</table>
<h3 id="二叉排序树二叉查找树">二叉排序树（二叉查找树）</h3>
<p><strong>概念</strong></p>
<p>二叉排序树，又称<strong>二叉查找树</strong>（<strong>BST</strong>,
Binary Search Tree）；</p>
<p>对任意结点都满足：左子树的结点值 &lt; 根结点值 &lt;
右子树结点值；</p>
<p>基于上述特点，进行中序遍历，可以得到一个递增的有序序列；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br></pre></td></tr></table></figure>
<p><strong>按值查找</strong></p>
<p>普通方式最坏空间复杂度 <span
class="math inline">\(O(1)\)</span>，递归方式最坏空间复杂度 <span
class="math inline">\(O(h)\)</span>，<span
class="math inline">\(h\)</span>为二叉排序树的深度；</p>
<p>查找效率分析：平均查找长度（ASL，Average Search Length）</p>
<p>平均查找长度计算方式：</p>
<ul>
<li>查找成功：<span class="math inline">\(ASL\)</span> =
所有结点查找成功的总平均对比次数</li>
<li>查找失败：<span class="math inline">\(ASL\)</span> =
所有查找失败的最后落点的总平均对比次数（落点只会在叶子结点的下一层上）</li>
</ul>
<p>查找的时间复杂度分析（查找成功和失败的复杂度分析是一样的）</p>
<ul>
<li>最好情况：具有 <span class="math inline">\(n\)</span>
个结点的二叉树最小高度为 <span
class="math inline">\(\lfloor\log_2n\rfloor+1\)</span>，<span
class="math inline">\(ASL=\mathcal(\log_2n)\)</span>；</li>
<li>最坏情况：斜二叉树，树高 <span class="math inline">\(h\)</span>
等于结点总数 <span class="math inline">\(n\)</span>，<span
class="math inline">\(ASL=O(n)\)</span>；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通方式：与根节点比较，较小就找左子树，较大就找右子树</span></span><br><span class="line">BSTNode* <span class="title function_">search</span><span class="params">(BSTree T, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; val != T-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; T-&gt;val)</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归方式</span></span><br><span class="line">BSTNode* <span class="title function_">search</span><span class="params">(BSTree T, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(val &lt; T-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> search(T-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; T-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> search(T-&gt;rchild, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>插入</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通方式</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert</span><span class="params">(BSTree* T, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*T != <span class="literal">NULL</span> &amp;&amp; val != *T-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; *T-&gt;val)</span><br><span class="line">            *T = *T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *T = *T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *T = (BSTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        *T-&gt;val = val;</span><br><span class="line">        *T-&gt;lchild = *T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方式</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert</span><span class="params">(BSTree *T, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *T = (BSTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        *T-&gt;val = val;</span><br><span class="line">        *T-&gt;lchild = *T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val == *T-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(val &lt; *T-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> insert(*T-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> insert(*T-&gt;rchild, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>按照给定序列构造二叉排序树</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BSTree <span class="title function_">create</span><span class="params">(<span class="type">int</span> seq[], <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    BSTree T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; size)&#123;</span><br><span class="line">        insert(&amp;T, seq[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>按值删除</strong></p>
<p>三种情况：</p>
<ul>
<li>叶子结点可以直接删；</li>
<li>只有单个子树的结点需要替代父节点的位置；</li>
<li>既有左子树又有右子树，可令待删除结点在二叉排序树序列中的直接前驱结点（或直接后继结点）替代该结点，并删除这个前驱（后继）结点；
<ul>
<li>二叉排序树中，某个结点的直接前驱和直接后继指的是，在按结点值的大小进行递增排序的序列中，恰好在前或在后一个位置的结点；
<ul>
<li>直接前驱结点是左子树最右下角的结点（左子树最大值），直接后继结点是右子树最左下角的结点（右子树最小值）</li>
</ul></li>
<li>二者只可能是叶子结点或只有单个子树的结点，可以按前面两种情况处理。</li>
</ul></li>
</ul>
<h3 id="平衡二叉树">平衡二叉树</h3>
<p>平衡二叉树（Balanced Binary
Tree），简称平衡树（AVL树），树上任一结点的左子树和右子树的高度差不超过1；</p>
<p>结点的平衡因子 = 左子数高 - 右子树高；</p>
<p>当插入一个新结点导致不平衡之后，只要将最小不平衡子树调整平衡，就可以使整体平衡；</p>
<p>调整目标：①恢复平衡 ②保持二叉排序树的特性</p>
<p>调整最小不平衡子树的四种情况：</p>
<ul>
<li><strong>LL：</strong>在A结点的左孩子的左子树中插入新结点导致不平衡；
<ul>
<li>策略：让A的左孩子<strong>右旋</strong>到A的位置，并依据二叉排序树的大小关系，转移左孩子的右子树成为根结点的左子树；</li>
</ul></li>
</ul>
<p><img src="5.2.png" style="zoom:80%"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设原本指向A的结点名为N</span></span><br><span class="line">A-&gt;lchild = B-&gt;rchild; <span class="comment">// 转移</span></span><br><span class="line">B-&gt;rchild = A; <span class="comment">// 右旋</span></span><br><span class="line">N-&gt;lchild/rchild = B; <span class="comment">// 连接</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>RR：</strong>在A结点的右孩子的右子树中插入新结点导致不平衡；
<ul>
<li>策略：让A的右孩子<strong>左旋</strong>到A的位置，并依据二叉排序树的大小关系，转移右孩子的左子树成为根结点的右子树；</li>
</ul></li>
</ul>
<p><img src="5.3.png" style="zoom:80%"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B-&gt;rchild = A-&gt;lchild; <span class="comment">// 转移</span></span><br><span class="line">A-&gt;lchild = B; <span class="comment">// 左旋</span></span><br><span class="line">N-&gt;lchild/rchild = B; <span class="comment">// 连接</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>LR：</strong>在A结点的左孩子的右子树中插入新结点导致不平衡；
<ul>
<li>策略：让A的左孩子的右孩子<strong>先左旋</strong>到B<strong>再右旋</strong>到A，期间转移两次，方式与上面相同；</li>
</ul></li>
</ul>
<p><img src="5.4.png" style="zoom:80%"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左旋</span></span><br><span class="line">B-&gt;rchild = C-&gt;lchild;</span><br><span class="line">C-&gt;lchild = B;</span><br><span class="line">A-&gt;lchild = C;</span><br><span class="line"><span class="comment">// 右旋</span></span><br><span class="line">A-&gt;lchild = C-&gt;rchild;</span><br><span class="line">C-&gt;rchild = A;</span><br><span class="line">N-&gt;lchild/rchild = C;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>RL：</strong>在A节点的右孩子的左子树中插入新结点导致不平衡；
<ul>
<li>策略：让A的右孩子的左孩子<strong>先右旋</strong>到B<strong>再左旋</strong>到A，期间转移两次，方式与上面相同；</li>
</ul></li>
</ul>
<p><img src="5.5.png" style="zoom:80%">`</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右旋</span></span><br><span class="line">B-&gt;lchild = C-&gt;rchild;</span><br><span class="line">C-&gt;rchild = B;</span><br><span class="line">A-&gt;rchild = C;</span><br><span class="line"><span class="comment">// 左旋</span></span><br><span class="line">A-&gt;rchild = C-&gt;lchild;</span><br><span class="line">C-&gt;lchild = A;</span><br><span class="line">N-&gt;lchild/rchild = C;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>插入操作导致“最小不平衡子树”高度+1，而调整过后高度恢复为原来的值，进而其祖先结点也都恢复平衡；</p>
<p>平衡二叉树的查找效率分析</p>
<ul>
<li>若高度为 <span
class="math inline">\(h\)</span>，则最坏情况下，查找一个关键字最多需要对比
<span class="math inline">\(h\)</span>
次，即查找操作的时间复杂度不可能超过 <span
class="math inline">\(O(h)\)</span>；</li>
<li>假设 <span class="math inline">\(n_h\)</span> 表示深度为 <span
class="math inline">\(h\)</span> 的平衡二叉树中含有的最少结点个数，易知
<span class="math inline">\(n_0=0,n_1=1,n_2=2\)</span>，且 <span
class="math inline">\(n_h=n_{h-1}+n_{h-2}+1\)</span>；
<ul>
<li><span
class="math inline">\(n_3=4,n_4=7,n_5=12,n_6=20\dots\)</span></li>
</ul></li>
<li>含有 <span class="math inline">\(n\)</span>
个结点的平衡二叉树的最大深度为 <span
class="math inline">\(O(\log_2n)\)</span>，即平衡二叉树的平均查找长度为
<span class="math inline">\(O(\log_2n)\)</span></li>
</ul>
<h3 id="哈夫曼树">哈夫曼树</h3>
<p>结点的权：表示的重要性，通常有某种现实含义；</p>
<p>结点的带权路径长度：从树的根到该结点的<strong>路径长度</strong>（经过的边数）与<strong>该结点权值</strong>的<strong>乘积</strong>；</p>
<p>树的<strong>带权路径长度</strong>：（<span
class="math inline">\(WPL\)</span>，Weighted Path
Length）树中所有叶结点的带权路径长度<strong>之和</strong>，<span
class="math inline">\(WPL=\sum_{i=1}^nw_il_i\)</span></p>
<p>在含有 <span class="math inline">\(n\)</span>
个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为<strong>哈夫曼树</strong>，也称<strong>最优二叉树</strong>；</p>
<p>哈夫曼树的构造：给定 <span class="math inline">\(n\)</span>
个权值分别为 <span class="math inline">\(w_1,w_2,\dots,w_n\)</span>
的结点，构造哈夫曼树的算法描述如下：</p>
<ul>
<li>将这 <span class="math inline">\(n\)</span> 个结点分别作为 <span
class="math inline">\(n\)</span> 棵仅含一个结点的二叉树，构成森林 <span
class="math inline">\(F\)</span>；</li>
<li>构造一个新结点，从 <span class="math inline">\(F\)</span>
中选择两棵根结点权值最小的树作为新的结点的左、右子树，并且将新结点的权值置为两个子树的权值之和；</li>
<li>从 <span class="math inline">\(F\)</span>
中删除刚才选出的两棵树，同时将刚刚新得的树加入 <span
class="math inline">\(F\)</span> 中；</li>
<li>重复二三步，直到 <span class="math inline">\(F\)</span>
中只剩下一棵树为止；</li>
</ul>
<p>构造的特点：</p>
<ul>
<li>每个初始结点最终都成为叶结点，且权值越小的结点到根节点的路径长度越大；</li>
<li>哈夫曼树的结点总数为 <span
class="math inline">\(2n-1\)</span>；</li>
<li>哈夫曼树中不存在度为1的结点；</li>
<li>哈夫曼树不唯一，但 <span class="math inline">\(WPL\)</span>
一定相同且最优；</li>
</ul>
<p><strong>哈夫曼编码</strong></p>
<p>字符集中的每个字符作为一个叶子结点，各字符出现的频度作为结点的权值，根据上面的方法构造哈夫曼树；</p>
<p>固定长度编码：每个字符用相等长度的二进制位表示；</p>
<p>可变长度编码：允许对不同字符用不等长的二进制位表示；</p>
<p>如果没有一个编码是另一个编码的前缀，则称这样的编码为<strong>前缀编码</strong>；</p>
<p>由于从给定叶子结点构造的哈夫曼树不唯一，因此哈夫曼编码也不唯一；</p>
<p>哈夫曼编码可以用于数据压缩；</p>
<h2 id="chapter6-图">Chapter6 图</h2>
<h3 id="图的定义">图的定义</h3>
<blockquote>
<p>G:Graph, V:Vertex, E:edge</p>
</blockquote>
<p><strong>定义：</strong>图 <span class="math inline">\(G\)</span>
是由顶点集 <span class="math inline">\(V\)</span> 和边集 <span
class="math inline">\(E\)</span> 组成，记为 <span
class="math inline">\(G=(V,E)\)</span>，其中 <span
class="math inline">\(V(G)\)</span> 表示图 <span
class="math inline">\(G\)</span> 中顶点的有限非空集，<span
class="math inline">\(E(G)\)</span> 表示图 <span
class="math inline">\(G\)</span> 中顶点之间的关系（边）的集合。</p>
<p>若 <span class="math inline">\(V=v_1,v_2,\dots,v_n\)</span>，则用
<span class="math inline">\(|V|\)</span> 表示图 <span
class="math inline">\(G\)</span> 中顶点的个数，也称图 <span
class="math inline">\(G\)</span> 的阶，<span
class="math inline">\(E=(u,v),u\in V,v\in V\)</span>，用 <span
class="math inline">\(|E|\)</span> 表示图 <span
class="math inline">\(G\)</span> 中边的条数；</p>
<p><strong>特点：</strong>图的顶点集一定是非空集，但边集可以是空集，总的来说图不可为空；</p>
<p><strong>无向图：</strong><span class="math inline">\(E\)</span>
是无向边（也称为<strong>边</strong>）的有限集合，边是顶点的<strong>无序</strong>对，记为
<span class="math inline">\((v,w)\)</span> 或 <span
class="math inline">\((w,v)\)</span>，二者等价。<span
class="math inline">\(v\)</span> 和 <span
class="math inline">\(w\)</span> 称为邻接点，边 <span
class="math inline">\((v,w)\)</span>
依附于这两个顶点（或与俩顶点相关联）；</p>
<p><strong>有向图：</strong><span class="math inline">\(E\)</span>
是有向边（也称为<strong>弧</strong>）的有限集合，边是顶点的<strong>有序</strong>对，记为
<span class="math inline">\(&lt;v,w&gt;\)</span>，顶点 <span
class="math inline">\(v\)</span> 称为<strong>弧尾</strong>，<span
class="math inline">\(w\)</span>
称为<strong>弧头</strong>，总体称为从顶点 <span
class="math inline">\(v\)</span> <strong>到</strong>顶点 <span
class="math inline">\(w\)</span> 的弧，也称 <span
class="math inline">\(v\)</span> 邻接<strong>到</strong> <span
class="math inline">\(w\)</span> 或 <span
class="math inline">\(w\)</span> 邻接<strong>自</strong> <span
class="math inline">\(v\)</span>，注意 <span
class="math inline">\(&lt;v,w&gt;\ne&lt;w,v&gt;\)</span>；</p>
<p><strong>简单图：</strong>①不存在重复的边（若为有向图则重复边方向也一样）
②不存在顶点到它自己的边；</p>
<p><strong>多重图：</strong>存在重复边或存在顶点到它自己的边；</p>
<p><strong>无向图顶点的度：</strong>依附于该顶点的边的条数，记为 <span
class="math inline">\(TD(v)\)</span>；</p>
<ul>
<li>对于无向图，每条边都为两个结点贡献一个度，因此所有顶点度的和等于边数的两倍
<span class="math inline">\(\sum_{i=1}^{n}ID(v_i)=2|E|\)</span>；</li>
</ul>
<p><strong>有向图顶点的度：</strong>入度+出度，即 <span
class="math inline">\(TD(v)=ID( v)+OD(v)\)</span></p>
<ul>
<li><p>入度：以该顶点为终点的有向边的数目，记为 <span
class="math inline">\(ID(v)\)</span>；</p></li>
<li><p>出度：以该顶点为起点的有向边的数目，记为 <span
class="math inline">\(OD(v)\)</span>；</p></li>
<li><p>对于有向图，每条边都为弧尾贡献一个出度，为弧头贡献一个入度，因此所有顶点的入度和与出度和相等
<span
class="math inline">\(\sum_{i=1}^{n}ID(v_i)=\sum_{i=1}^{n}OD(v_i)\)</span></p></li>
</ul>
<p><strong>路径：</strong>两个顶点之间的一条路径是由顶点组成的序列；</p>
<ul>
<li>顶点之间可能不存在路径，例如顶点没有边或只作为弧尾；</li>
<li>简单路径：顶点不重复出现的路径；</li>
<li>路径长度：路径上边的条数；</li>
<li><strong>连通/非连通：</strong>无向图中，若路径 <span
class="math inline">\(v\rightarrow w\)</span> 存在则称顶点 <span
class="math inline">\(v\)</span> 和 <span
class="math inline">\(w\)</span> 是连通的；
<ul>
<li>连通/非连通图：任意两个顶点都连通的无向图称为连通图，否则称为非连通图；</li>
<li>具有 <span class="math inline">\(n\)</span>
个结点的<strong>连通</strong>图<strong>最少</strong>有 <span
class="math inline">\(n-1\)</span>
条边，<strong>非连通</strong>图<strong>最多</strong>有 <span
class="math inline">\(C_{n-1}^2\)</span> 条边；</li>
</ul></li>
<li><strong>强连通：</strong>有向图中，若两条路径 <span
class="math inline">\(v \leftrightarrow w\)</span> 都存在，则称顶点
<span class="math inline">\(v\)</span> 和 <span
class="math inline">\(w\)</span> 是强连通的；
<ul>
<li>强连通图：任意一对顶点都强连通的有向图称为强连通图；</li>
<li>具有 <span class="math inline">\(n\)</span> 个顶点的强连通图最少有
<span class="math inline">\(n\)</span> 条边；</li>
</ul></li>
</ul>
<p><strong>回路：</strong>首尾顶点相同的路径；</p>
<ul>
<li>简单回路：除了首尾顶点外，其余顶点不重复出现的回路；</li>
</ul>
<p><strong>点到点的距离：</strong>从顶点 <span
class="math inline">\(v\)</span> 出发到顶点 <span
class="math inline">\(v\)</span> 的最短路径的长度；（当<span
class="math inline">\(v\rightarrow w\)</span>路径不存在时，记该距离为
<span class="math inline">\(\infin\)</span>）</p>
<p><strong>子图：</strong>从图的顶点集和边集中分别取子集构成的图；（不是任意选，必须能组成图）</p>
<ul>
<li><p>若子图的顶点集包含了原图的所有顶点，则称为原图的生成子图；</p></li>
<li><p><strong>极大连通子图：</strong>包含顶点和边尽可能多的连通部分，无向图中的极大连通子图称为<strong>连通分量</strong>；</p></li>
<li><p><strong>极大强连通子图：</strong>包含顶点和边尽可能多的强连通部分；</p></li>
</ul>
<p><strong>连通图的生成树：</strong>包含图中<strong>所有</strong>顶点的一个<strong>极小</strong>连通子图（边尽可能的少）``````````````</p>
<ul>
<li>$n 个顶点的生成树有 $ <span class="math inline">\(n-1\)</span>
条边；</li>
<li>同一个图的生成树不唯一；</li>
</ul>
<p><strong>树：</strong>不存在回路，且连通的无向图</p>
<ul>
<li>砍掉任意一条边都会变成非连通图；</li>
<li><span class="math inline">\(n\)</span> 个顶点的树，必定有且只有
<span class="math inline">\(n-1\)</span> 条边。因此 <span
class="math inline">\(n\)</span> 个顶点的图，如果边数 <span
class="math inline">\(|E|&gt;n-1\)</span>，就一定有回路；</li>
</ul>
<p><strong>有向树：</strong>其中一个顶点的入度为0（根节点），其余顶点的入度均为1的有向图；</p>
<ul>
<li>有向树不是强连通图；</li>
</ul>
<p><strong>非连通图的生成森林：</strong>非连通图的连通分量的生成树构成生成森林</p>
<p><strong>带权图/网：</strong>每条边带有权值的图称为带权图，也称网；</p>
<p><strong>带权路径长度：</strong>带权图中一条路径上所有边的权值之和；</p>
<p><strong>无向完全图：</strong>任意两个顶点之间都存在边的无向图；</p>
<ul>
<li>若无向图顶点数 <span class="math inline">\(|V|=n\)</span>，则 <span
class="math inline">\(|E| \in [0,C_n^2]=[0,n(n-1)/2]\)</span></li>
</ul>
<p><strong>有向完全图：</strong>任意两个顶点之间都存在方向相反的两条弧</p>
<ul>
<li>若有向图顶点数 <span class="math inline">\(|V|=n\)</span>，则 <span
class="math inline">\(|E|\in[0,2C_n^2]=[0,n(n-1)]\)</span>
（无向图的两倍）</li>
</ul>
<p><strong>稀疏图：</strong>边数很少的图，一般来说 <span
class="math inline">\(|E&lt;|V|\log|V|\)</span>时可视为稀疏图，反之为<strong>稠密图</strong>；</p>
<h3 id="图的存储方式">图的存储方式</h3>
<h4 id="邻接矩阵法">邻接矩阵法</h4>
<p>无向图：行列值<span
class="math inline">\((i,j)=(j,i)\)</span>，整体<strong>关于主对角线对称</strong>；</p>
<p>有向图：行号表示弧尾，列号表示弧头，<span
class="math inline">\((i,j)\ne(j,i)\)</span>；</p>
<p>利用邻接矩阵求顶点的度：</p>
<ul>
<li>无向图结点的度 = 所在行的非零元素个数；</li>
<li>有向图结点的：行非零元素（出度） + 列非零元素（入度）；</li>
<li>时间复杂度：<span class="math inline">\(O(|V|)\)</span>；</li>
</ul>
<p>带权图中，可以使用 <span class="math inline">\(0\)</span> 或 <span
class="math inline">\(\infin\)</span> 表示不存在边/弧；</p>
<p>邻接矩阵的空间复杂度：</p>
<ul>
<li>需要一个规模为 <span class="math inline">\(|V|\)</span>
的数组存储顶点信息，另一个规模为 <span class="math inline">\(|V|\times
|V|\)</span> 的数组存储边的信息；</li>
<li>空间复杂度：<span class="math inline">\(O(ElemType1\cdot
|V|)+O(ElemType2\cdot |V|^2)=O(|V|^2)\)</span>；</li>
<li>基于第二点结论，空间复杂度仅取决于顶点的个数；</li>
</ul>
<p>从节省空间的角度看，邻接矩阵更适合存储稠密图（边很多的图，不浪费矩阵元素）；另外可以利用对称矩阵的压缩存储方式进一步减少资源占用；</p>
<p>重要性质：设 <span class="math inline">\(A\)</span>
是普通图的邻接矩阵，则矩阵 <span class="math inline">\(A^n\)</span>
的元素 <span class="math inline">\((i,j)\)</span> 表示从顶点 <span
class="math inline">\(i\)</span> 到顶点 <span
class="math inline">\(j\)</span>，长度为 <span
class="math inline">\(n\)</span> 的路径的数目；</p>
<p>对于一个确定的图，在顶点编号确定之后，邻接矩阵的表示方式就是唯一的；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通图的邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];</span><br><span class="line">    <span class="type">bool</span> Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//是否有边或有弧</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;</span><br><span class="line">&#125; MGraph;</span><br><span class="line"><span class="comment">// 带权图的邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 999 <span class="comment">//表示“无穷&quot;</span></span></span><br><span class="line">typdefe <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];</span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//权值</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;</span><br><span class="line">&#125; MGraph;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表法">邻接表法</h4>
<p>邻接表法使用<strong>顺序+链式</strong>的存储方式表示图；</p>
<p>无向图：每一条边都被关联两次，因此边结点的总数为 <span
class="math inline">\(2|E|\)</span>，整体空间复杂度 <span
class="math inline">\(O(|V|+2|E|)\)</span>；</p>
<ul>
<li>顶点的度 = 该顶点结点的边结点链表的结点个数；</li>
</ul>
<p>有向图：每一条弧只被链接一次，因此弧结点的总数为 <span
class="math inline">\(|E|\)</span>，整体空间复杂度 <span
class="math inline">\(O(|V|+|E|)\)</span></p>
<ul>
<li>顶点的出度：该顶点结点的弧结点链表的结点个数；</li>
<li>顶点的入度：遍历所有结点的弧链表，累计指向该顶点的边结点的个数；（时间复杂度很高）</li>
</ul>
<p>对于一个确定的图，邻接表是不唯一的，因为边（弧）结点链表的顺序是可变的；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="comment">// 顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> vertex; <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode* first; <span class="comment">// 该顶点的第一条边；</span></span><br><span class="line">&#125;VNode, AdjList[MaxVertexNum];</span><br><span class="line"><span class="comment">// 边or弧</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">// 该边（弧）连接（指向）的顶点的索引</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">next</span>;</span> <span class="comment">// 本顶点的下一条边（弧）的指针</span></span><br><span class="line">    <span class="comment">// 可添加权重变量</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">// 顶点和边的数量</span></span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure>
<p><strong>邻接表 VS 邻接矩阵</strong></p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>邻接表</th>
<th>邻接矩阵</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>空间复杂度</td>
<td>无向图 O(|V|+2|E|)​；有向图 ​O(|V|+|E|)​</td>
<td>O(|V|^2)​</td>
</tr>
<tr class="even">
<td>适用对象</td>
<td>稀疏图</td>
<td>稠密图</td>
</tr>
<tr class="odd">
<td>唯一性</td>
<td>不唯一</td>
<td>唯一</td>
</tr>
<tr class="even">
<td>度的计算</td>
<td>无向图以及有向图的出度为边（弧）链表结点个数，有向图入度需要遍历所有结点的链表</td>
<td>遍历矩阵的行列，无向图对称点等价，有向图行表示出度，列表示入度</td>
</tr>
<tr class="odd">
<td>找邻边</td>
<td>除了有向图的入边需要挨个顶点遍历之外，顺着边（弧）链表往下找即可</td>
<td>无向图遍历行<strong>或</strong>列，有向图遍历行<strong>和</strong>列</td>
</tr>
</tbody>
</table>
<h4 id="十字链表和邻接多重表">十字链表和邻接多重表</h4>
<p>只适用于存储<strong>无向图</strong>：邻接多重表</p>
<p>只适用于存储<strong>有向图</strong>：十字链表</p>
<p>对于一个确定的图（无向/有向），邻接多重表或十字链表的表示方式也是不唯一的（因为边结点或弧结点的顺序不唯一）</p>
<p><strong>邻接多重表</strong></p>
<p>解决存储无向图的两个问题：</p>
<ul>
<li><p>邻接矩阵空间复杂度高 $O(|V|^2) $；</p></li>
<li><p>每条边在邻接表中都有重复的结点，造成浪费，且删除顶点、删除边等操作时间复杂度高；</p></li>
</ul>
<p>邻接多重表空间复杂度：<span
class="math inline">\(O(|V|+2|E|)\)</span>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 999;</span></span><br><span class="line"><span class="comment">// 顶点结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> vertex;</span><br><span class="line">    ArcNode* firstEdge; <span class="comment">// 依附于该顶点的第一条边的结点指针</span></span><br><span class="line">&#125; VNode;</span><br><span class="line"><span class="comment">// 边结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> i, j; <span class="comment">// 该条边依附的两个顶点序号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">iLink</span>;</span> <span class="comment">// 依附于i的下一条边的结点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">jLink</span>;</span> <span class="comment">// 依附于j的下一条边的结点指针</span></span><br><span class="line">    <span class="comment">// 可选：权重变量</span></span><br><span class="line">&#125; ArcNode;</span><br></pre></td></tr></table></figure>
<p><strong>十字链表</strong></p>
<p>解决存储有向图的两个问题：</p>
<ul>
<li>邻接矩阵空间复杂度高 $O(|V|^2) $；</li>
<li>邻接表求入度、找入边不方便；</li>
</ul>
<p>十字链表空间复杂度：<span
class="math inline">\(O(|V|^2)\)</span>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 999</span></span><br><span class="line"><span class="comment">// 顶点结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> vertex;</span><br><span class="line">    ArcNode* firstIn;  <span class="comment">// 以该顶点作为弧头的第一条弧的结点指针</span></span><br><span class="line">    ArcNode* firstOut; <span class="comment">// 以该顶点作为弧尾的第一条弧的结点指针</span></span><br><span class="line">&#125; VNode;</span><br><span class="line"><span class="comment">// 弧结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    VNode *tailVex, *headVex; <span class="comment">// 该弧的弧尾结点指针和弧头结点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">tLink</span>;</span>    <span class="comment">// 与该弧的弧头相同的下一个弧结点的指针 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">hLink</span>;</span>    <span class="comment">// 与该弧的弧尾相同的下一个弧结点的指针</span></span><br><span class="line">&#125; ArcNode;</span><br></pre></td></tr></table></figure>
<h3 id="图的基本操作">图的基本操作</h3>
<p>基本操作：</p>
<ul>
<li><p>判断是否存在边；</p>
<ul>
<li>邻接矩阵 <span class="math inline">\(O(1)\)</span>，邻接表 <span
class="math inline">\(O(1)\sim O(|V| )\)</span></li>
</ul></li>
<li><p>列出与某顶点相连的边；</p>
<ul>
<li>无向图：邻接矩阵 <span class="math inline">\(O(|V|)\)</span>，邻接表
$O(1)O(|V|) $</li>
<li>有向图：邻接矩阵 <span
class="math inline">\(O(|V|)\)</span>，邻接表：出边 <span
class="math inline">\(O(1)\sim O(|V|)\)</span> 入边 <span
class="math inline">\(O(|E|)\)</span></li>
</ul></li>
<li><p>插入顶点；</p>
<ul>
<li>邻接矩阵：<span
class="math inline">\(O(1)\)</span>，由于初始化图结点时为顶点数组和邻接矩阵数组设置了上限，因此唯一开销是在数组里设置一个新顶点；</li>
<li>邻接表：<span
class="math inline">\(O(1)\)</span>，插入一个新结点；</li>
</ul></li>
<li><p>删除顶点：</p>
<ul>
<li>无向图：
<ul>
<li>邻接矩阵：$O(| V |)
$，在顶点结点中多设置一个布尔值表示顶点是否有效，这样只需设置布尔值并将该顶点在矩阵中对应的行和列置0即可；</li>
<li>邻接表：<span class="math inline">\(O( 1 )\sim
O(|E|)\)</span>，最好情况是边链表为空，最坏情况是与其他所有顶点都有边，并且在其他顶点链表中都处于末位；</li>
</ul></li>
<li>有向图：
<ul>
<li>邻接矩阵：<span class="math inline">\(O(|V|)\)</span>；</li>
<li>邻接表：删出边 <span class="math inline">\(O(1) \sim
O(|V|)\)</span>，删入边 <span class="math inline">\(O(|E|
)\)</span>;</li>
</ul></li>
</ul></li>
<li><p>添加边：</p>
<ul>
<li>邻接矩阵：<span class="math inline">\(O(1)\)</span>；</li>
<li>邻接表：<span class="math inline">\(O(1)\)</span>，链表头插法；</li>
</ul></li>
<li><p>删除边：</p>
<ul>
<li>无向图：邻接矩阵 <span class="math inline">\(O(1)\)</span>；邻接表
<span class="math inline">\(O(|V |)\)</span></li>
<li>有向图：邻接矩阵 <span class="math inline">\(O(1
)\)</span>；邻接表：删出边 <span class="math inline">\(O(1) \sim
O(|V|)\)</span>，删入边 <span class="math inline">\(O(|E|
)\)</span>;</li>
</ul></li>
<li><p><strong>求某顶点的第一个邻接点号，当该顶点不存在或没有邻接点时返回-1</strong>；</p>
<ul>
<li>无向图：邻接矩阵：<span class="math inline">\(O(1)\sim O(|V
|)\)</span>；邻接表 <span
class="math inline">\(O(1)\)</span>，边链表第一个结点；</li>
<li>有向图：邻接矩阵：<span class="math inline">\(O(1)\sim O(|V
|)\)</span>；邻接表：找出边邻接点 <span
class="math inline">\(O(1)\)</span>，找入边邻接点 <span
class="math inline">\(O(1)\sim O(|E|)\)</span>；</li>
</ul></li>
<li><p><strong>若顶点 <span class="math inline">\(y\)</span> 是 <span
class="math inline">\(x\)</span> 的邻接点，求除了 <span
class="math inline">\(y\)</span> 之外的下一个 <span
class="math inline">\(x\)</span>
的邻接点顶点号，下一个不存在时返回-1</strong>；</p>
<ul>
<li>邻接矩阵 <span class="math inline">\(O(1)\sim O(|V
|)\)</span>；邻接表<span
class="math inline">\(O(1)\)</span>，边（弧）链表下一个结点；</li>
</ul></li>
<li><p>设置、获取指定边的权值；</p>
<ul>
<li>等价于找指定的边（弧）</li>
<li>邻接矩阵 <span class="math inline">\(O(1)\)</span>；邻接表 <span
class="math inline">\(O(1)\sim O(|V|)\)</span>；</li>
</ul></li>
</ul>
<h3 id="图的遍历">图的遍历</h3>
<h4 id="广度优先搜索-bfs">广度优先搜索 BFS</h4>
<p><strong>与树的广度优先遍历之间的联系和区别：</strong></p>
<ul>
<li>联系：搜索与某个结点相邻的所有结点（孩子结点）；</li>
<li>区别：树不存在回路，因此搜索相邻结点时不可能搜到已访问过的结点，但图可能；</li>
</ul>
<p><strong>算法实现</strong></p>
<ul>
<li>找到与一个顶点相邻的所有顶点；</li>
<li>使用布尔数组标记已访问顶点；</li>
<li>需要一个辅助队列；</li>
</ul>
<p><strong>基于邻接矩阵与邻接表的差异：</strong></p>
<ul>
<li>邻接矩阵通过遍历行或列找到下一个邻接点，顺序固定，因此BFS对邻接点的搜索是<strong>递增的</strong>，且搜索序列<strong>唯一</strong>；</li>
<li>邻接表取决于存储时设定的顺序，因此搜索序列是<strong>不唯一</strong>的；</li>
</ul>
<p><strong>潜在问题与解决方案：</strong></p>
<ul>
<li>问题：非连通图无法遍历所有结点；</li>
<li>方案：完整执行一次BFS后，检查<code>visited</code>是否还有未访问结点，是的话针对未访问结点再执行一次BFS；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MaxVertexNum];</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Gragh G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            BFS(G,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G, <span class="type">int</span> vex)</span>&#123;</span><br><span class="line">    SqQueue <span class="built_in">queue</span> = initiate();</span><br><span class="line">    visit(vex);</span><br><span class="line">    visited[vex] = <span class="literal">true</span>;</span><br><span class="line">    push_back(&amp;<span class="built_in">queue</span>, vex); <span class="comment">// 入队</span></span><br><span class="line">    <span class="keyword">while</span>(!empty(&amp;<span class="built_in">queue</span>))&#123;</span><br><span class="line">        pop_front(&amp;<span class="built_in">queue</span>, &amp;vex); <span class="comment">// 出队</span></span><br><span class="line">        <span class="comment">// NextNeighbor找到图G中除了w之外的vex的下一个邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w = FirstNeighbor(G,vex); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, vex, w))&#123; </span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                visit(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                push_back(&amp;<span class="built_in">queue</span>, w); <span class="comment">// 入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>对于无向图，调用BFS的次数等于连通分量的个数；</li>
<li>对于<strong>非强连通</strong>有向图而言，从不同的顶点出发需要调用BFS的次数可能不同，从出度为0的结点出发固然需要调用更多次；</li>
<li>空间复杂度：队列长度取决于顶点的最大邻接点个数，因此最坏情况为 <span
class="math inline">\(O(|V|)\)</span>；</li>
<li>时间复杂度：开销来源于访问所有顶点和边；
<ul>
<li>邻接矩阵：访问 <span class="math inline">\(|V|\)</span> 个顶点需要
<span
class="math inline">\(O(|V|)\)</span>，查找一个顶点的全部邻接点需要
<span class="math inline">\(O(|V|)\)</span>，因此复杂度为 <span
class="math inline">\(O(|V|)+O(|V|^2)=O(|V|^2)\)</span>；</li>
<li>邻接表：无向图查找所有邻接点共需要 <span
class="math inline">\(O(2|E|)\)</span>，有向图需要 $O(|E|)
$，因此复杂度为 <span class="math inline">\(O(|V|+|E|)\)</span>；</li>
</ul></li>
</ul>
<p><strong>广度优先生成树</strong></p>
<p>根据广度优先的遍历顺序生成的树，同一个结点的所有邻接结点都是该结点的孩子结点，且互相是兄弟结点，遵循从左到右的顺序；</p>
<p>广度优先生成树是同一个图的生成树中高度最小的；</p>
<p>基于邻接表的存储结构会造成生成树不唯一；</p>
<p><strong>广度优先生成森林</strong></p>
<p>非连通图的连通分量通过BFS各自生成的树组成的森林称为广度优先生成森林；</p>
<h4 id="深度优先搜索-dfs">深度优先搜索 DFS</h4>
<p>图的DFS相当于树的先序遍历；</p>
<p>复杂度分析：</p>
<ul>
<li><p>对于无向图，调用DFS的次数等于连通分量的个数；</p></li>
<li><p>对于<strong>非强连通</strong>有向图而言，从不同的顶点出发需要调用DFS的次数可能不同，从出度为0的结点出发固然需要调用更多次；</p></li>
<li><p>空间复杂度：来自递归的深度，最好情况是所有结点都只有唯一邻接点且连通
<span class="math inline">\(O(1)\)</span>，最坏情况是类似线性的结构
<span class="math inline">\(O(|V|)\)</span>；</p></li>
<li><p>时间复杂度：与广度优先相同；</p></li>
</ul>
<p>深度优先生成树：从根节点出发，每条路径都是一个子树；</p>
<p>非连通图的连通分量通过DFS各自生成的树组成的森林称为深度优先生成森林；</p>
<p>基于邻接表的表示方式不唯一，因此DFS遍历序列也不唯一，生s成树也不唯一；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MaxVertexNum];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        visited[v] = flase;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(G,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> vex)</span>&#123;</span><br><span class="line">    visit(vex);</span><br><span class="line">    visited[vex] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> w = FirstNeighbor(G, vex); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, vex, w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            DFS(G, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树">最小生成树</h3>
<p>树的权：树中所有边的权值之和；</p>
<p>一个带权连通无向图，可以有不同的生成树，每棵树的权也可能不同。</p>
<p><strong>概念：</strong>设 <span class="math inline">\(R\)</span> 为图
<span class="math inline">\(G\)</span> 的所有生成树的集合，则 <span
class="math inline">\(R\)</span>
中权最小的生成树称为最小生成树（<strong>MST</strong>,Minimum-Spanning-Tree），又称最小代价树；</p>
<ul>
<li><p>同一个图的MST可能有多个，但边的权值之和总是唯一且最小的；</p></li>
<li><p>MST的边数 = 顶点数 -
1；去掉任意一条就不连通，增加一条则会出现回路；</p></li>
<li><p>如果一个连通图本身就是一棵树，则其最小生成树就是它本身；</p></li>
<li><p>只有连通图才有生成树，非连通图只有生成森林；</p></li>
</ul>
<p>构建最小生成树的算法：Prim算法（普里姆）、Kruskal算法（克鲁斯卡尔）</p>
<p><strong>Prim算法</strong></p>
<p>从某个顶点开始构建生成树，在已纳入生成树的所有顶点的邻接点中，找到代价最小的<strong>顶点</strong>纳入生成树（来源点就是双亲结点），直到所有顶点都纳入为止；</p>
<ul>
<li>当最小代价顶点有多个时，就有多个不同的MST（不同MST的数量不受起始点不同的影响），但它们的权是相等且最小的；</li>
<li>算法实现思想：
<ul>
<li>数组<code>isJoined</code>标记各顶点是否加入树，数组<code>cost</code>记录当前顶点的各邻接点纳入树的最低代价；</li>
<li>循环遍历所有结点，初始时更新基于第一个结点的代价数组<code>cost</code>；</li>
<li>遍历所有结点，找到<code>cost</code>最小且<code>isJoined=false</code>的顶点，将其加入树，并遍历<code>cost</code>更新与新加入点邻接的点的代价（只在代价小于原<code>cost</code>值时覆盖）；</li>
<li>重复上一步直到所有顶点都纳入树为止；</li>
</ul></li>
<li>时间复杂度： <span
class="math inline">\(O(|V|^2)\)</span>，适用于边稠密图；
<ul>
<li>大循环一共需要 <span
class="math inline">\(O(|V|-1)=O(|V|)\)</span>，内部两个独立小循环：<span
class="math inline">\(O(|V|)+O(|V|)=O(|V|)\)</span>；</li>
</ul></li>
</ul>
<p><strong>Kruskal算法</strong></p>
<p>每次选择一条权值最小的<strong>边</strong>，使该条边的两头连通（已连通的就不选），直到所有结点都连通；</p>
<ul>
<li>算法实现思想：
<ul>
<li>将所有的边结点按照权值递增排序，存放在数组中；</li>
<li>按递增顺序遍历数组，检查两个顶点是否连通，若不连通则让其连通（并查集）；</li>
<li>持续遍历直到所有顶点都纳入树为止；</li>
</ul></li>
<li>时间复杂度：<span
class="math inline">\(O(|E|\log_2|E|)\)</span>，适用于边稀疏图；
<ul>
<li>遍历数组：<span class="math inline">\(O(|E|)\)</span>；</li>
<li>判断顶点是否属于同一个集合：<span
class="math inline">\(O(\log_2|E|)\)</span>；</li>
</ul></li>
</ul>
<h3 id="最短路径问题">最短路径问题</h3>
<h4 id="单源最短路径问题">单源最短路径问题</h4>
<h5 id="bfs-广度优先搜索算法">BFS 广度优先搜索算法</h5>
<p>在原BFS算法的基础上添加两个数组</p>
<ul>
<li><code>distance[vexnum]</code>：表示从起始点到每个点的累计距离，初始化为
<span class="math inline">\(\infty\)</span>；</li>
<li><code>fatherNode[vexnum]</code>：标记所搜索的邻接点的直接来源结点号；</li>
</ul>
<p>执行完BFS后，数组里记录的就是从初始点到其他所有顶点的最短路径以及路程长度；</p>
<p><strong>局限性：</strong>BFS只能处理<strong>无权</strong>图的单源最短路问题（因为BFS每个结点只处理一次，无法在后续的寻路中更新先前的最短路），无法处理有权重图；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 9999</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_MinDistance</span><span class="params">(Graph G, <span class="type">int</span> origin)</span>&#123;</span><br><span class="line">    SqQueue <span class="built_in">queue</span> = initiate();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;</span><br><span class="line">        distance[i] = INFINITY; <span class="comment">// 距离初值为无穷大</span></span><br><span class="line">        fatherNode[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    distance[origin] = <span class="number">0</span>; <span class="comment">// 起始点置零</span></span><br><span class="line">    visited[origin] = <span class="literal">true</span>;</span><br><span class="line">    push_back(&amp;<span class="built_in">queue</span>, origin);</span><br><span class="line">    <span class="keyword">while</span>(!empty(&amp;<span class="built_in">queue</span>))&#123;</span><br><span class="line">        pop_front(&amp;<span class="built_in">queue</span>, &amp;origin);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w = FirstNeighbor(G,origin); w&gt;=<span class="number">0</span>; w=NextNeighbor(G, origin, w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                distance[w] = distance[origin] + <span class="number">1</span>;</span><br><span class="line">                fatherNode[w] = origin;</span><br><span class="line">                push_back(&amp;<span class="built_in">queue</span>, &amp;w);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dijkstra-迪杰斯特拉算法">Dijkstra 迪杰斯特拉算法</h5>
<p>在BFS的基础上删除<code>visited</code>并增加一个数组：</p>
<ul>
<li><code>found[vexnum]</code>：标记每个结点是否已经找到最短路径；</li>
</ul>
<p>算法思想：两步循环：①更新邻接点累计权值
②挑选权值最小的未访问邻接点访问并更新其父结点；</p>
<p>时间复杂度：外循环 <span
class="math inline">\(O(|V|-1)=O(|V|)\)</span>，内循环更新与处理 <span
class="math inline">\(O(|V|)+ O(|V|)= O(|V|)\)</span> ，乘积 <span
class="math inline">\(O(|V|^2)\)</span>；</p>
<p><strong>局限性：</strong>不适用于有负权值的带权图；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于邻接表`实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65536</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(Graph G, <span class="type">int</span> origin)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;</span><br><span class="line">        distance[i] = INFINITY;</span><br><span class="line">        fatherNode[i] = <span class="number">-1</span>;</span><br><span class="line">        found[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    distance[origin] = <span class="number">0</span>;</span><br><span class="line">    found[origin] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum(found) &lt; G.vexnum)&#123;</span><br><span class="line">        <span class="comment">// 更新distance</span></span><br><span class="line">        <span class="keyword">for</span>(ArcNode* arc = G.vertices[origin]-&gt;first; arc != <span class="literal">NULL</span>; arc = arc-&gt;next)</span><br><span class="line">            <span class="keyword">if</span>(distance[origin] + arc-&gt;weight &lt; distance[arc-&gt;adjvex])&#123; <span class="comment">// 假设表示权重的变量是weight</span></span><br><span class="line">                distance[arc-&gt;adjvex] = distance[origin] + arc-&gt;weight; </span><br><span class="line">                fatherNode[arc-&gt;adjvex] = origin;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 处理distance最小且found为false的点</span></span><br><span class="line">        <span class="type">int</span> id = minIndex(distance, found); <span class="comment">// 遍历所有顶点，取出distance最小且found为false的顶点序号</span></span><br><span class="line">        found[id] = <span class="literal">true</span>;</span><br><span class="line">        origin = id;  <span class="comment">// 作为下一次更新的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="每对顶点的最短路径问题">每对顶点的最短路径问题</h4>
<h5 id="floyd-弗洛伊德算法">Floyd 弗洛伊德算法</h5>
<p>使用动态规划思想，将问题求解分为多个阶段：①不允许中转，求最短路
②允许在<span class="math inline">\(v_0\)</span>中转，求最短路
③允许在<span class="math inline">\(v_1\)</span>中转，求最短路 <span
class="math inline">\(\dots\)</span></p>
<p>算法思想：</p>
<ul>
<li>创建一个与图的邻接矩阵同等规模的矩阵<code>transmitMatrix</code>，其元素
<span class="math inline">\((i,j)\)</span> 表示从顶点 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j\)</span> 经过的中转点，初值设为-1；</li>
<li>按照阶段顺序设置允许中转点，以 <span
class="math inline">\(A\)</span>
表示图的邻接矩阵，每轮递推检查矩阵的所有元素：
<ul>
<li>若满足 <span class="math inline">\(A[i][j] &gt;
A[i][k]+A[k][j]\)</span>，则将 <span
class="math inline">\(A[i][j]\)</span>
的值置为后者，表示通过中转的路径距离更短；</li>
<li>同时在<code>transmitMatrix</code>中<span
class="math inline">\((i,j)\)</span>的位置填上中转点序号<span
class="math inline">\(k\)</span>；</li>
</ul></li>
</ul>
<p>Floyd算法每轮递推都建立在之前递推得出的最优方案基础之上，因此最终从<code>transmitMatrix</code>中推导最优路径时需要递归推导；</p>
<p>时间复杂度：递推大循环共有<span
class="math inline">\(|V|\)</span>轮，内循环每次遍历规模为<span
class="math inline">\(|V|^2\)</span>的邻接矩阵的所有点，因此复杂度为
<span class="math inline">\(O(|V|^3)\)</span></p>
<p>局限性：无法处理带负权<strong>回路</strong>的图；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">floyd</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.vexnum; ++k) <span class="comment">// 递推轮数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) <span class="comment">// 检查矩阵的所有点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">                <span class="keyword">if</span>(G.Edge[i][j] &gt; G.Edge[i][k] + G.Edge[k][j])&#123;</span><br><span class="line">                    G.Edge[i][j] = G.Edge[i][k] + G.Edge[k][j];  <span class="comment">// 取更短的路径</span></span><br><span class="line">                    transmitMatrix[i][j] = k;  <span class="comment">// 中转点</span></span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归获取最优路径并打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="type">int</span> trsm = transmitMatrix[start][end];</span><br><span class="line">    <span class="keyword">if</span>(trsm == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;%d\n&quot;</span>, start, end);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printPath(start, trsm);</span><br><span class="line">        printPath(trsm, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有向无环图的应用">有向无环图的应用</h3>
<h4 id="用有向五环图描述表达式">用有向五环图描述表达式</h4>
<p>有向无环图，即<strong>不存在环（回路）</strong>的有向图（DAG，Directed
Acyclic Graph）</p>
<p>用有向五环图表示表达式的步骤：</p>
<ul>
<li>把各个操作数不重复地排成一排</li>
<li>标出各个运算符的运行顺序（顺序是为了确保下一步不遗漏任何一个运算符，并且不搞错左右操作数）</li>
<li>按顺序放置运算符，注意<strong>分层</strong></li>
<li><strong>简化：</strong>自底向上逐层检查同层运算符是否可以合并（操作数相同的运算符可以合并）</li>
</ul>
<p>一个表达式的有向无环图表示是不唯一的；（因为第二步的顺序不需要遵守计算机的原则，因此有些顺序可以调换）</p>
<h4 id="拓扑排序">拓扑排序</h4>
<p><strong>AOV网</strong>（Activity On Vertex
NetWork，用顶点表示活动的网），用DAG有向无环图表示一个工程，顶点表示活动，有向边
<span class="math inline">\(&lt;V_i,V_j&gt;\)</span>表示活动<span
class="math inline">\(V_i\)</span>必须先于活动<span
class="math inline">\(V_j\)</span>进行；</p>
<p><strong>拓扑排序：</strong>找到做事的先后顺序</p>
<ul>
<li>从AOV网中选择一个入度为0的顶点并输出（将所有入度为0的顶点入栈，每次弹出一个并输出）；</li>
<li>从网中删除该顶点和所有以它为弧尾的弧（弹出时遍历弧链表，将弧头入度-1，并将减后得0的顶点入栈）；</li>
<li>重复上面两步直到当前AOV网为空，或当前不存在无前驱的顶点为止；</li>
</ul>
<p>只有DAG图存在拓扑排序序列，一旦有环就会在某时刻无法找到入度为0的顶点，无法继续进行拓扑排序；</p>
<p>由于邻接表的表示一个图的方式不唯一，因此在将入度减为0的顶点入栈时可能有多个选择，因此对于未确定邻接表的图，拓扑排序序列也不唯一；</p>
<p>时间复杂度：每个顶点、每条边都要处理一次</p>
<ul>
<li>邻接表 <span class="math inline">\(O(|V|+|E|)\)</span>；邻接矩阵
<span class="math inline">\(O(|V|^2)\)</span>；</li>
</ul>
<p><strong>逆拓扑排序：</strong>将所有出度为0的顶点入栈，每次弹出一个输出，并找到所有入弧，将弧尾出度减一，且将减后得0的顶点入栈；</p>
<ul>
<li>若采用邻接表的存储方式，找到入弧需要遍历所有结点的弧链表，开销较大；</li>
<li>逆邻接表：顶点的弧链表表示的是该顶点作为<strong>弧头</strong>的弧的链表，与普通邻接表相反；</li>
<li>同样地，基于邻接表的逆拓扑排序可能不唯一；若存在回路，逆拓扑排序就不存在；</li>
</ul>
<p><strong>DFS实现逆拓扑排序</strong>：在每一层递归调用弹出递归栈时（即每层递归结束后）输出当前的顶点；</p>
<ul>
<li>由于存在回路表示某个顶点可能被重复访问，因此可在判断邻接点是否已访问的<code>if</code>条件后加上<code>else</code>指明存在回路，序列不存在；</li>
</ul>
<p><strong>DFS实现拓扑排序：</strong>由于拓扑排序和逆拓扑排序的序列互逆，因此只需要将"输出当前结点"改为进栈，最后一一弹出便可实现用DFS实现拓扑排序；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序的代码实现</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TopologicalSort</span><span class="params">(ALGraph G, <span class="type">int</span> indegree[], <span class="type">int</span> sequence[])</span>&#123;</span><br><span class="line">    SqStack <span class="built_in">stack</span> = initiate();</span><br><span class="line">    <span class="comment">// 将入度为0的顶点进栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">            push(&amp;<span class="built_in">stack</span>, i);</span><br><span class="line">    <span class="type">int</span> top, count = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">// 弹出栈顶，遍历该顶点的所有弧，将弧头入度-1（相当于删除了栈顶与栈顶的出弧），并将减后得0的顶点入栈</span></span><br><span class="line">    <span class="keyword">while</span>(!empty(&amp;<span class="built_in">stack</span>))&#123;</span><br><span class="line">        pop(&amp;<span class="built_in">stack</span>, &amp;top);</span><br><span class="line">        sequence[count++] = top;</span><br><span class="line">        <span class="keyword">for</span>(ArcNode* arc = G.vertices[top]-&gt;first; arc != <span class="literal">NULL</span>; arc = arc-&gt;next)</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[arc-&gt;adjvex]))</span><br><span class="line">                push(&amp;<span class="built_in">stack</span>, arc-&gt;adjvex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键路径">关键路径</h3>
<p><strong>AOE网</strong>（Activity On Edge
Network）：用顶点表示事件，有向边表示活动，边的权值表示完成该活动的开销，称为用边表示活动的网络；</p>
<ul>
<li><p>只有在某顶点所代表的事件发生后，从该顶点出发的各个有向边所代表的活动才能开始；</p></li>
<li><p>只有在进入某顶点的各有向边的活动都已结束后，该顶点所代表的事件才能发生；</p></li>
<li><p>有些活动可以并行进行；</p></li>
<li><p>AOE网中只有一个入度为0的顶点，称为开始顶点（源点），表示整个工程的开始；</p></li>
<li><p>AOE网中只有一个出度为0的顶点，称为结束顶点（汇点），表示整个工程的结束；</p></li>
</ul>
<p><strong>关键路径：</strong>从源点到汇点的有向路径可能有多条，所有路径中，具有<strong>最大长度</strong>（即总时间最长）的路径称为关键路径；</p>
<ul>
<li><p><strong>关键活动：</strong>关键路径上的活动，关键活动组成了关键路径；</p></li>
<li><p>完成整个工程至少需要的时间：关键路径的长度；</p></li>
<li><p>要想不延期，关键活动必须按时完成；</p></li>
<li><p>缩短关键活动的时间，可以缩短整个工程的工期；</p>
<ul>
<li>缩短到一定程度时，关键活动可能变成非关键活动；</li>
<li>若有多条关键路径，则只提高一条上的关键活动速度无法缩短整个工程工期，每条都提高才行；</li>
</ul></li>
</ul>
<p><strong>对于事件</strong><span class="math inline">\(v_k\)</span></p>
<ul>
<li><p>最早发生时间<span
class="math inline">\(ve(k)\)</span>：所有从<span
class="math inline">\(v_k\)</span>开始的活动能够开工的最早时间；</p></li>
<li><p>最迟发生时间<span
class="math inline">\(vl(k)\)</span>：在不推迟整个工程完成期限的前提下，该事件最晚必须发生的时间；</p></li>
</ul>
<p><strong>对于活动</strong><span class="math inline">\(a_i\)</span></p>
<ul>
<li><p>最早开始时间<span
class="math inline">\(e(i)\)</span>：该弧的弧尾表示的事件的最早发生时间；</p></li>
<li><p>最迟开始时间<span
class="math inline">\(l(i)\)</span>：该弧的弧头表示的事件的最迟发生时间与该活动所需时间之差；</p></li>
<li><p>时间余量<span
class="math inline">\(d(i)=l(i)-e(i)\)</span>：在不拖延整个工程期限的前提下，该活动可以拖延的时间</p>
<ul>
<li>若一个活动的时间余量为0，则说明该活动必须如期完成，即该活动是一个<strong>关键活动</strong>；</li>
</ul></li>
</ul>
<p><strong>求关键路径的步骤：</strong>目的在于求每个活动的时间余量，依次找出关键路径</p>
<ul>
<li><p>求所有事件的最早发生时间 <span
class="math inline">\(ve\)</span></p>
<ul>
<li>拓扑排序，按照序列依次求各个顶点的 <span
class="math inline">\(ve\)</span>，源点为0，若有多个前驱结点，就取权和最大的；</li>
<li>取权和最大值的原因：确保同一个弧头的每条弧的活动都执行完了，弧头事件才开始；</li>
</ul></li>
<li><p>求所有事件的最迟发生时间 <span
class="math inline">\(vl\)</span></p>
<ul>
<li>逆拓扑排序，按照序列依次求各个顶点的 <span
class="math inline">\(vl\)</span>，汇点的最早和最迟发生时间相同（直接使用上一步汇点的计算结果即可），若有多个后继结点，就取权差最小的；</li>
<li>取权差最小值的原因：确保每个弧的活动都能执行完；</li>
</ul></li>
<li><p>求所有活动的最早开始时间 <span
class="math inline">\(e\)</span>，等于弧尾事件的 $ve $；</p></li>
<li><p>求所有活动的最迟开始时间 <span
class="math inline">\(l\)</span>，弧头事件的 <span
class="math inline">\(vl\)</span> 减去该弧活动所需时间；</p></li>
<li><p>求所有活动的时间余量 <span
class="math inline">\(d=l-e\)</span>；</p></li>
<li><p>时间余量为0的活动组成的路径为关键路径；</p></li>
</ul>
<h2 id="chapter7-查找">Chapter7 查找</h2>
<h3 id="概念">概念</h3>
<p><strong>查找</strong>：在数据集合中寻找满足某种满足条件的数据元素的过程；</p>
<p><strong>查找表（查找结构）</strong>：用于查找的数据集合，由同一类型的数据元素（或记录）组成；</p>
<p><strong>关键字：</strong>数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，结果应该是唯一的；</p>
<p><strong>对查找表的常见操作：</strong>查找、插入、删除</p>
<ul>
<li><p>只进行查找操作的称为静态查找表，只需要关注查找效率；</p></li>
<li><p>除了查找还要进行插删操作的，称为动态查找表，需要关注插删操作是否容易实现；</p></li>
</ul>
<p><strong>查找算法的评价指标：</strong></p>
<ul>
<li>查找长度：需要对比关键字的次数；</li>
<li>平均查找长度（ASL,Average Search
Length）：所有查找过程中进行关键字比较次数的均值；
<ul>
<li><span
class="math inline">\(ASL=\sum_{i=1}^{n}P_iC_i\)</span>，其中<span
class="math inline">\(P_i\)</span>表示元素 <span
class="math inline">\(i\)</span>
在查找表中的占比（或理解为被查找的概率），<span
class="math inline">\(C_i\)</span>表示查找该元素的对比次数；</li>
</ul></li>
<li>评价一个查找算法的效率时，通常分开考虑查找成功和失败的ASL；</li>
</ul>
<p><strong>构建查找判定树分析ASL：</strong></p>
<ul>
<li>一个成功结点的查找长度 = 该结点自身所在层数；</li>
<li>一个失败结点的查找长度 = 其父结点所在层数；</li>
<li>默认情况下，各种失败情况或成功情况等可能发生；</li>
</ul>
<h3 id="几种查找算法">几种查找算法</h3>
<h4 id="顺序查找">顺序查找</h4>
<p>从头到尾挨个查找，通常用于线性表；</p>
<p>有序表的查找优化方案：</p>
<ul>
<li>当查找表中的元素是递增或递减（有序）存放时，可在元素不满足大小关系时停止查找；</li>
<li>当各个关键字被查找的概率不等时，可将被查概率较大的放在查找表靠前的位置；</li>
</ul>
<p><strong>效率分析：</strong>对于普通查找表的顺序查找，成功与查找失败的ASL都是
<span class="math inline">\(O(n)\)</span>，但有特殊情况：</p>
<p>以在<strong>有序查找表</strong>中进行顺序查找为例，<span
class="math inline">\(n\)</span>个元素的查找表具有<span
class="math inline">\(n\)</span>个成功结点与<span
class="math inline">\(n+1\)</span>个失败结点，每个失败结点的占比都为
<span
class="math inline">\(\cfrac{1}{n+1}\)</span>，因此查找失败的ASL就等于：
<span class="math display">\[
ASL_{fail}=\cfrac{1+2+3+\dots+n+n}{n+1}=\cfrac{n}{2}+\cfrac{n}{n+1}
\]</span> 分子的两个<span
class="math inline">\(n\)</span>代表成功结点<code>43</code>的两个孩子失败结点的查找次数；</p>
<p><img src="7.1.jpg" style="zoom:50%"></p>
<h3 id="折半查找二分查找">折半查找（二分查找）</h3>
<p><strong>适用范围：</strong>仅适用于<strong>有序</strong>的<strong>顺序表</strong>；</p>
<p><strong>折半查找判定树构造：</strong></p>
<ul>
<li>若包含<code>low</code>和<code>high</code>之间的元素个数为奇数，则以mid为根节点递归二分构造即可；</li>
<li>若包含<code>low</code>和<code>high</code>之间的元素个数为偶数，则mid分割后，左半边要比右半边少一个元素；
<ul>
<li>只有可能是右子树结点比左子树多；</li>
<li>每次分层后的<code>low</code>结点都是左子树，<code>high</code>结点都是右子树；</li>
<li>此处以<strong>向下取整</strong>作为取<code>mid</code>的方式，如果是向上取整，则左比右要多一个；</li>
</ul></li>
<li><strong>特点：</strong>右子树结点数 - 左子树结点数 = 0或1
<ul>
<li>折半查找判定树一定是平衡二叉树；</li>
<li>只有最下面一层是不满的，因此树高的计算方式与完全二叉树相同： <span
class="math inline">\(h=\lceil \log_2(n+1)\rceil\)</span> 或 <span
class="math inline">\(h=\lfloor\log_2n\rfloor+1\)</span>；</li>
<li>结点关键字（序号）满足：左&lt;中&lt;右，因此该树还是二叉排序树；</li>
<li>失败结点个数：<span
class="math inline">\(n+1\)</span>，也是树的空链域个数；</li>
</ul></li>
<li><strong>效率：</strong>不论查找成功还是失败，都有 <span
class="math inline">\(ASL \le h\)</span>，因此时间复杂度为 $O(_2n)
$</li>
</ul>
<p><img src="7.2.png" style="zoom:60%"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n, key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = n<span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分块查找">分块查找</h3>
<p>分块查找，又称索引顺序查找，数据分块存储，块内无序、块间有序；</p>
<p><img src="7.3.png" style="zoom:60%"></p>
<p><strong>算法思想：</strong></p>
<ul>
<li>索引表中记录每个分块的<strong>最大关键字</strong>以及分块的区间；</li>
<li>先查索引表（顺序或折半查找都行），再对特定分块内的元素进行顺序查找（因为块内无序，所以只能顺序查找）；</li>
</ul>
<p><strong>效率分析：</strong></p>
<ul>
<li>ASL = 查索引表的ASL + 查分块内元素的ASL；</li>
<li>假设有 <span class="math inline">\(n\)</span> 个元素，均匀分为 <span
class="math inline">\(b\)</span> 块，每块内有 <span
class="math inline">\(s\)</span> 个元素，则
<ul>
<li>顺序查找索引表：<span
class="math inline">\(ASL=\cfrac{b+1}{2}+\cfrac{s+1}2\)</span>，通分后可求得当
<span class="math inline">\(s=\sqrt{n}\)</span> 时，<span
class="math inline">\(ASL_{min}=\sqrt{n}+1\)</span></li>
<li>折半查找索引表：<span
class="math inline">\(ASL=\lceil\log_2(b+1)\rceil+\cfrac{s+1}{2}\)</span></li>
</ul></li>
</ul>
<p><strong>注意点：</strong>对索引表进行折半查找时，若索引表中不包含目标关键字，则折半查找最终会停在
<code>low &gt; high</code> 的位置，此时要在 <code>low</code>
指向的分块中找。</p>
<ul>
<li>只有当<code>low</code>超出了索引表的范围时才判定为查找失败；</li>
</ul>
<h3 id="b树">B树</h3>
<h4 id="特性">特性</h4>
<p>B树，又称<strong>多路平衡查找树</strong>（balance），B树中所有结点的孩子个数的最大值（最大分叉数）称为B树的阶，通常用
<span class="math inline">\(m\)</span> 表示。</p>
<p><img src="7.4.png" style="zoom:60%"></p>
<p><span
class="math inline">\(m\)</span>阶B树的<strong>核心特性</strong>：（分叉数
= 子树个数）</p>
<ul>
<li>根节点的分叉数 <span
class="math inline">\(\in[2,m]\)</span>，关键字数 <span
class="math inline">\(\in[1,m-1]\)</span>；</li>
<li>其他结点的分叉数 <span class="math inline">\(\in [\lceil
m/2\rceil,m]\)</span>，关键字数 <span class="math inline">\(\in [\lceil
m/2-1\rceil,m-1]\)</span></li>
<li>对任一结点，其所有子树的高度相同；</li>
<li>关键字的值：<span
class="math inline">\(P_0&lt;K_1&lt;P_1&lt;K_2&lt;P_2&lt;\dots\)</span>
其中<span
class="math inline">\(P\)</span>表示左子树关键字的最大值或右子树关键字的最小值，<span
class="math inline">\(K\)</span>表示当前结点中的关键字值的范围；</li>
<li>B树的失败结点只能出现在最下面一层；</li>
<li>一棵含有 <span class="math inline">\(n\)</span> 个关键字的 <span
class="math inline">\(m\)</span> 叉B树，其高度的范围是：<span
class="math inline">\(\log_m(n+1)\le h \le \log_{\lceil
m/2\rceil}\cfrac{n+1}{2}+1\)</span>；</li>
</ul>
<h4 id="b树的插入与删除">B树的插入与删除</h4>
<p>核心要求：</p>
<ul>
<li>对于<span
class="math inline">\(m\)</span>阶B树，除了根节点外，每个结点的关键字数量必须在
<span class="math inline">\(\in [\lceil m/2-1\rceil,m-1]\)</span>
区间内；</li>
<li>关键字的值要保持：<span
class="math inline">\(P_0&lt;K_1&lt;P_1&lt;K_2&lt;P_2&lt;\dots\)</span></li>
</ul>
<p><strong>B树的插入：</strong></p>
<ul>
<li>通过查找确定插入位置，注意一定是在终端结点进行插入；</li>
<li>插入关键字不会使关键字数量溢出时，直接插入；</li>
<li>若插入后结点关键字超过上限，则需将中间值放到父结点中，并将当前结点一分为二；
<ul>
<li>该操作若导致父结点关键字个数溢出，则需要将父结点也进行分裂，直到不再溢出；</li>
<li>若一直分裂到根节点仍然溢出，则分裂根节点会使树的整体高度+1；</li>
</ul></li>
</ul>
<p><strong>B树的删除</strong></p>
<ul>
<li>删除非终端结点关键字
<ul>
<li>用其直接前驱（左子树最右下）或直接后继（右子树最左下）结点顶替位置，转化为对终端结点关键字的删除操作；</li>
</ul></li>
<li>删除终端结点关键字
<ul>
<li>删除操作不会使结点关键字数量低于下限时，直接删除；</li>
<li>若删除后结点关键字数低于下限
<ul>
<li>若兄弟结点关键字够借，通过与父结点交换关键字，达到平衡的目的；</li>
<li>若兄弟结点关键字不够借，则需要与兄弟结点，以及父结点内夹中的关键字合并；
<ul>
<li>若合并后导致父结点关键字数低于下限，需要让父结点再与其兄弟结点以及父父结点夹中关键字合并；</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="b树-1">B+树</h3>
<p>类似于分块查找思想构建的多级多阶树；</p>
<p><img src="7.5.png" style="zoom:60%"></p>
<p>一棵<span class="math inline">\(m\)</span>阶B+树的特性：</p>
<ul>
<li><p>根节点的分叉数 <span class="math inline">\(\in
[1,m]\)</span>，关键字数 <span class="math inline">\(\in
[1,m]\)</span>；</p></li>
<li><p>其他结点的分叉数 <span class="math inline">\(\in [\lceil m/2
\rceil,m]\)</span>，关键字数 <span class="math inline">\(\in [\lceil m/2
\rceil,m]\)</span>；</p></li>
<li><p>结点的子树个数与关键字个数相等；</p></li>
<li><p>每个分支结点最多有<span
class="math inline">\(m\)</span>棵子树；</p></li>
<li><p>非叶根节点至少有两棵子树，其他每个分支结点至少有<span
class="math inline">\(\lceil m/2 \rceil\)</span>棵子树；</p></li>
<li><p>分支结点的每个关键字都是该结点的某一个孩子结点中所有记录的最大值，且只起到索引的作用；</p></li>
<li><p>与记录的地址相关的关键字只保存在所有叶子结点中，且从左到右有按关键字大小顺序排列，兄弟结点是单向链接的（支持顺序查找）；</p></li>
</ul>
<p><strong>B树 VS B+树</strong></p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 46%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>m阶B树</th>
<th>m阶B+树</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>类比</td>
<td>二叉查找树--&gt;m叉查找树</td>
<td>分块查找--&gt;多级分块查找</td>
</tr>
<tr class="even">
<td>关键字与分叉</td>
<td>n个关键字对应n+1个分叉（子树）</td>
<td>n个关键字对应n个分叉</td>
</tr>
<tr class="odd">
<td>结点包含的信息</td>
<td>所有结点都包含记录的信息</td>
<td>只有叶子结点包含记录信息</td>
</tr>
<tr class="even">
<td>查找方式</td>
<td>不支持顺序查找，可能在任意层结点中查找成功；查找速度不稳定</td>
<td>支持顺序查找，不论成败都停在叶子结点所在层；查找速度稳定</td>
</tr>
<tr class="odd">
<td><strong>相同点</strong></td>
<td>除了根节点外的每个结点最少都要有<span class="math inline">\(\lceil
m/2 \rceil\)</span>个分叉，任何结点的所有子树都一样高</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="散列查找">散列查找</h3>
<h4 id="基本概念-2">基本概念</h4>
<p>散列（Hash），又称<strong>哈希</strong>；</p>
<p>散列表：一种数据结构，数据元素的关键字与其存储地址直接相关；</p>
<p>散列函数：描述关键字与其在散列表中的存储地址关系的函数</p>
<p>冲突：通过散列函数映射到的存储位置上已有元素存放；</p>
<p>同义词：通过散列函数映射到同一个存储位置的关键字；</p>
<p>装填因子：<span class="math inline">\(\alpha\)</span> =
散列表中记录的个数 / 表长；</p>
<h4 id="常见散列函数">常见散列函数</h4>
<p>除留余数法：<span class="math inline">\(H(key)=key \space \% \space
p\)</span>，其中<span
class="math inline">\(p\)</span>是不大于表长但最接近或等于表长的<strong>质数</strong>；</p>
<ul>
<li>用质数取模，分布更均匀，冲突更少；</li>
</ul>
<p>直接定址法：<span class="math inline">\(H(key)=key\)</span> 或 <span
class="math inline">\(H(key)=a\times key+b\)</span>；</p>
<ul>
<li>目的是让不同的关键字尽可能少冲突，适合关键字的分布基本连续的情况；</li>
</ul>
<p>数字分析法：选取数码分布较为均匀的若干位作为散列地址（例如手机尾号后四位）；</p>
<p>平方取中法：取关键字的平方值的中间几位数字作为散列地址（例如以身份证号作为关键字存储学校学生信息）；</p>
<ul>
<li>这种方法得到的散列地址与关键字的每位都有关系；</li>
</ul>
<h4 id="冲突的处理方式">冲突的处理方式</h4>
<p>拉链法（链地址法）：同义词用链表串起来；</p>
<ul>
<li>计算拉链法的ASL时，若映射的位置上为空链表（即NULL），则该处不算一次对比；</li>
<li>查找成功的ASL等于各个冲突次数的结点数加权和均值；</li>
<li>查找失败的ASL等于装填因子；</li>
<li>优化方法：让链表中的元素以升序或降序方式排列，可提高在链表中执行顺序查找的效率；</li>
</ul>
<p>开放定址法：<span class="math inline">\(H_i=(H(key)+d_i)\space \%
\space m\)</span>，其中<span
class="math inline">\(d_i\)</span>称为增量序列，有三种常见方法确定其取值</p>
<ul>
<li>线性探测法：<span
class="math inline">\(d_i=0,1,2,3,\dots,m-1\)</span>；
<ul>
<li>由于该方法判断查找失败的依据是查找到空位置，因此删除某个元素时需要用一个变量表明是删除了不是空了；</li>
<li>该方法很容易造成同义词、非同义词的“聚集（堆积）现象”，降低查找效率；</li>
</ul></li>
<li>平方探测法（二次探测法）：<span
class="math inline">\(d_i=0^2,1^2,-1^2,2^2,-2^2,\dots,k^2,-k^2\)</span>
其中<span class="math inline">\(k\le m/2\)</span>；
<ul>
<li>比起线性探测法，可是关键字分布更分散一些；</li>
<li>注意：使用该方法时，散列表长度<span
class="math inline">\(m\)</span>必须是一个可以表示成<span
class="math inline">\(4j+3\)</span>的素数，这样才能探测到所有的位置；</li>
</ul></li>
<li>伪随机序列法：<span class="math inline">\(d_i\)</span>
为一个伪随机序列</li>
</ul>
<p>再散列法：准备多个散列函数，一个发生冲突了就用下一个；</p>
<h4 id="查找效率">查找效率</h4>
<p>查找效率取决于：①散列函数 ②处理冲突的方法 ③装填因子；</p>
<p>冲突会增加ASL，降低查找效率，对给定的关键字集合，应该尽可能地将它们均匀散列到表中的各个地址上，使冲突更少；</p>
<p>散列查找是典型的“用空间换时间”的算法，只要散列函数设计得合理，则当散列表越长时，冲突的概率就会越低；</p>
<h2 id="chapter8-排序">Chapter8 排序</h2>
<h3 id="概念-1">概念</h3>
<p>排序：将个元素按关键字递增/递减的顺序重新排列；</p>
<p>分类：</p>
<ul>
<li>内部排序：数据都存在内存中；</li>
<li>外部排序：数据太多，无法一次性全部放入内存中；</li>
</ul>
<p>评价指标：</p>
<ul>
<li>时间复杂度、空间复杂度；</li>
<li>稳定性：关键字相同的元素在排序后的相对顺序是否改变；</li>
</ul>
<h3 id="内部排序">内部排序</h3>
<h4 id="插入排序">插入排序</h4>
<h5 id="简单插入排序">简单插入排序</h5>
<p>算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，知道全部记录插入完成；</p>
<p>直接插入排序：顺序查找到插入的位置，适用于顺序表、链表；</p>
<p>折半插入排序：折半查找到插入的位置，仅适用于顺序表；</p>
<ul>
<li>当<code>low&gt;high</code>时停止折半查找，并将
<code>[low, i-1]</code> 区间内是所有元素右移一格；
<ul>
<li>因为是先移动<code>data[j]~data[i-1]</code>，再将<code>data[i]</code>放置到<code>data[j]</code>的位置，因此需要一个临时变量存储<code>data[i]</code>的值以免在放置前被覆盖；</li>
</ul></li>
<li>当<code>mid=key</code>时，应该继续令<code>low=mid+1</code>，确保稳定性；最终应该将元素插入到<code>low</code>（或<code>high+1</code>）所指位置；</li>
</ul>
<p>性能分析：</p>
<ul>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span>；</li>
<li>时间复杂度：
<ul>
<li>最好：原本有序 <span class="math inline">\(O(n)\)</span></li>
<li>最坏：原本逆序 <span class="math inline">\(O(n^2)\)</span></li>
<li>平均：<span class="math inline">\(O(n^2)\)</span></li>
</ul></li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(data[i] &lt; data[i - <span class="number">1</span>])&#123;</span><br><span class="line">            temp = data[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; temp; --j)</span><br><span class="line">                data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">            data[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 折半插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, low, high, mid, temp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        temp = data[i];</span><br><span class="line">        low = <span class="number">0</span>; high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] &gt; temp)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= low; --j)</span><br><span class="line">            data[j+<span class="number">1</span>] = data[j];</span><br><span class="line">        data[low] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="希尔排序">希尔排序</h5>
<p>算法思想：先追求表中的元素部分有序，再逐步逼近全局有序；</p>
<p>方式：将待排序表分割成若干形如 <span
class="math inline">\(L[i,i+d,i+2d,\dots,i+kd]\)</span>
的特殊子表，对各个字表分别进行直接插入排序，缩小增量 <span
class="math inline">\(d\)</span>（通常取半），重复上述过程，直到 <span
class="math inline">\(d=1\)</span> 为止；</p>
<ul>
<li>第一次的增量 <span class="math inline">\(d\)</span>
通常可以选取元素个数的一半；</li>
<li>仅适用于顺序表；</li>
</ul>
<p>性能分析：</p>
<ul>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span>；</li>
<li>时间复杂度：最好情况与增量序列的选择有关，最坏情况是令<span
class="math inline">\(d=1\)</span>，等于直接插入排序 <span
class="math inline">\(O(n^2)\)</span>
<ul>
<li>当 <span class="math inline">\(n\)</span> 当某个范围内时，可达到
<span class="math inline">\(O(n^{1.3})\)</span>；</li>
</ul></li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(d = n/<span class="number">2</span>; d &gt;= <span class="number">1</span>; d=d/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(i = d; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(data[i] &lt; data[i - d])&#123;</span><br><span class="line">                temp = data[i];</span><br><span class="line">                <span class="keyword">for</span>(j = i - d; j &gt; <span class="number">0</span> &amp;&amp; data[j] &gt; temp; j-=d)</span><br><span class="line">                    data[j + d] = data[j];</span><br><span class="line">                data[j + d] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交换排序">交换排序</h4>
<p>根据序列中两个元素关键字的比较结果来调换这两个记录的位置；</p>
<p>常用的交换排序算法有：冒泡排序和快速排序；</p>
<h5 id="冒泡排序">冒泡排序</h5>
<p>可以正向每次冒最大的数，也可以逆向每次冒最小的数；</p>
<p>适用于顺序表和链表；</p>
<p>空间复杂度：<span class="math inline">\(O(1)\)</span>；</p>
<p>时间复杂度：</p>
<ul>
<li>最好情况：原本有序，大循环只需一趟，总共对比<span
class="math inline">\(n-1\)</span>次关键字，因此复杂度为 <span
class="math inline">\(O(n)\)</span>；</li>
<li>最坏情况：原本逆序，大循环需要 <span
class="math inline">\(n-1\)</span>
趟，总对比次数=总<strong>交换次数</strong>=<span
class="math inline">\(\sum_{i=1}^{n-1}=\cfrac{n(n-1)}{2}\)</span>
次，因此复杂度为 <span class="math inline">\(O(n^2)\)</span>；
<ul>
<li>每<strong>交换</strong>元素一次，需要<strong>移动</strong>元素三次；</li>
</ul></li>
<li>平均：（最好+最坏）/2 = $O(n^2) $；</li>
</ul>
<p>稳定性：因为只在<code>data[i-1] &gt; data[i]</code>时交换，所以稳定；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!sorted)&#123;</span><br><span class="line">        sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i - <span class="number">1</span>] &gt; data[i])&#123;</span><br><span class="line">                swap(&amp;data[i - <span class="number">1</span>], &amp;data[i]);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速排序">快速排序</h5>
<p>快排是所有内部排序算法中，平均性能最好的；</p>
<p>与冒泡排序的区别：冒泡每次将最大值（最小值）固定到表尾（表头），而快排每次确定一个中间元素的位置；</p>
<p>算法思想：</p>
<ul>
<li>每次找一个元素作为基准（或称为枢轴，通常取首元素），通过一次划分将待排序表以基准为分界线分为左右两部分（左小右大），由此确定了基准的位置；
<ul>
<li>一次划分：对当前排序表用枢轴元素进行分割，也是确定枢轴元素位置的过程；</li>
<li>一趟排序：对存在的所有字表都进行一次划分的总操作；</li>
</ul></li>
<li>递归地对两个字表重复上述过程，直到每部分只有一个元素或为空为止；</li>
</ul>
<p>性能评价：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n*d)\)</span>，其中 <span
class="math inline">\(d\)</span> 为递归层数。将<span
class="math inline">\(n\)</span>个元素不断分割的过程表示成二叉树，树的高度就是递归层数；
<ul>
<li>由于 <span class="math inline">\(n\)</span>
个结点的二叉树的最小高度为 <span
class="math inline">\(\lfloor\log_2n\rfloor+1\)</span>，最大高度为 <span
class="math inline">\(n\)</span>，因此递归层数 <span
class="math inline">\(\in [\lfloor\log_2n\rfloor+1,n]\)</span>；</li>
<li>综上，最好情况 <span
class="math inline">\(O(n\log_2n)\)</span>，最坏情况 <span
class="math inline">\(O(n^2)\)</span>，平均 <span
class="math inline">\(O(n\log_2n)\)</span>；
<ul>
<li>最好情况：每次选中的枢轴都能均匀地划分排序序列，使递归层数小；</li>
<li>最坏情况：每次都不均匀划分，递归层数最大，例如原本就有序的序列，每次取首元素作为枢轴，效率最低；</li>
</ul></li>
</ul></li>
<li>空间复杂度：<span class="math inline">\(O(d) \in
[O(\log_2n,O(n)]\)</span>；</li>
</ul>
<p>优化方案：</p>
<ul>
<li>以头、中、尾三个位置的元素的中间值作为枢轴元素；</li>
<li>随机选取一个元素作为枢轴元素；</li>
</ul>
<p>稳定性：不稳定；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = data[low]; <span class="comment">// 枢轴元素</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; data[high] &gt;= pivot)  <span class="comment">// 左移high直到碰到一个比基准小的数</span></span><br><span class="line">            high--;</span><br><span class="line">        data[low] = data[high]; <span class="comment">// 将该数放到基准的位置上</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; data[low] &lt;= pivot) <span class="comment">// 右移low直到碰到一个比基准大的数</span></span><br><span class="line">            low++;</span><br><span class="line">        data[high] = data[low]; <span class="comment">// 将该数放到刚刚high腾出的空位上</span></span><br><span class="line">    &#125;</span><br><span class="line">    data[low] = pivot; <span class="comment">// 确定基准元素的位置</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> pivotPos = partition(data, low, high); <span class="comment">// 划分主表，返回基准元素的合适位置</span></span><br><span class="line">        quickSort(data, low, pivotPos<span class="number">-1</span>); <span class="comment">// 划分左子表</span></span><br><span class="line">        quickSort(data, pivotPos+<span class="number">1</span>, high); <span class="comment">// 划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择排序">选择排序</h4>
<p>主要思想：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列；</p>
<h5 id="简单选择排序">简单选择排序</h5>
<p>每次从头到位扫描，找到最小的元素，放到头部位置并缩小规模；</p>
<p>适用顺序表和链表；</p>
<p>性能评价：</p>
<ul>
<li>空间复杂度：$O(n) $；</li>
<li>时间复杂度：无论什么情况都需要 <span
class="math inline">\(n-1\)</span> 趟处理，总共对比次数 <span
class="math inline">\(\sum_{i=1}^{n-1}=\cfrac{n(n-1)}{2}\)</span>，交换元素次数
<span class="math inline">\(&lt;n-1\)</span>，因此复杂度 <span
class="math inline">\(O(n^2)\)</span>；</li>
</ul>
<p>稳定性：不稳定；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> head = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) <span class="comment">// 找到最小值的索引</span></span><br><span class="line">            <span class="keyword">if</span>(data[j] &lt; data[head])</span><br><span class="line">                head = j;</span><br><span class="line">        <span class="keyword">if</span>(head != i)</span><br><span class="line">            swap(&amp;data[head], &amp;data[i]); <span class="comment">// 交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="堆排序">堆排序</h5>
<p>堆（Heap）：若<span
class="math inline">\(n\)</span>个关键字组成的序列 <span
class="math inline">\(L[1,2,\dots,n]\)</span>
满足下面某一条性质，则称为堆：</p>
<ul>
<li>若满足：<span class="math inline">\(L(i) \ge L(2i)\)</span> 且 <span
class="math inline">\(L(i) \ge
L(2i+1)\)</span>，则称为大根堆（大项堆），其中 <span
class="math inline">\(1\le i\le n/2\)</span>；</li>
<li>若满足：<span class="math inline">\(L(i) \le L(2i)\)</span> 且 <span
class="math inline">\(L(i) \le
L(2i+1)\)</span>，则称为小根堆（小项堆），其中 <span
class="math inline">\(1\le i\le n/2\)</span>；</li>
</ul>
<p>从树的视角看：</p>
<ul>
<li>大根堆：完全二叉树中，任何一个结点都有：根 <span
class="math inline">\(\ge\)</span> 左右孩子；</li>
<li>小根堆：完全二叉树中，任何一个结点都有：根 <span
class="math inline">\(\le\)</span> 左右孩子；</li>
</ul>
<p>算法思想：基于<strong>大根堆</strong>实现的是<strong>递增</strong>排序，小根堆是递减排序；</p>
<ul>
<li>建立大根堆</li>
<li>选择根节点关键字加入有序子序列s，并将除去根节点之后的剩余部分再调整为大根堆；</li>
<li>重复上一步，直到所有关键字都加入有序子序列中为止；</li>
</ul>
<p>稳定性：不稳定；</p>
<p><strong>step1 建立大根堆</strong></p>
<p>将初始序列看作树的顺序存储结构，注意该存储方式的0号位置存储结点个数，关键字从1号位置开始存储；</p>
<p>自底向上遍历所有分支结点，检查当前结点是否满足 根<span
class="math inline">\(\ge\)</span>左右
的要求，若不满足，则将当前结点与两个孩子中更大的一个互换；</p>
<p>如果元素互换破坏了下一层的大根堆，则用相同的方式让小元素不断下坠；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>; i &gt; <span class="number">0</span>; --i) <span class="comment">// 自底向上遍历所有分支结点</span></span><br><span class="line">        headAdjust(data, i, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headAdjust</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> k, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    data[<span class="number">0</span>] = data[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span> * k; i &lt;= n; i*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n &amp;&amp; data[i] &lt; data[i+<span class="number">1</span>]) <span class="comment">// &lt;n 确保存在右子树data[i+1]</span></span><br><span class="line">            i++; <span class="comment">// 将i指向左右孩子中值更大的那个</span></span><br><span class="line">        <span class="keyword">if</span>(data[i] &lt; data[<span class="number">0</span>]) <span class="comment">// 与根进行比较</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 孩子比根大时覆盖根的值，并设置为下一次待调整的根</span></span><br><span class="line">            data[k] = data[i];</span><br><span class="line">            k = i; <span class="comment">//  假定将原根节点放到孩子的位置上，下一轮循环将判断是否继续下沉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    data[k] = data[<span class="number">0</span>]; <span class="comment">// 当i超出n时表示已无法继续下沉，因此可直接放置原根节点ss</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>step2 堆排序</strong></p>
<p>每一趟将堆顶元素加入有序子序列，并将待排序元素序列再次调整为大根堆（小元素不断下坠）；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">// 建立大根堆</span></span><br><span class="line">    buildMaxHeap(data, n);</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; --i)&#123; <span class="comment">// 从1开始存放</span></span><br><span class="line">        swap(&amp;data[<span class="number">0</span>], &amp;data[n]); <span class="comment">// 将大根堆的根尾互换，使最大值（根）放到数组末尾的位置；</span></span><br><span class="line">        headAdjust(data, <span class="number">1</span>, i<span class="number">-1</span>); <span class="comment">// 将调整剩余部分调整为大根堆，并缩小待调整数组规模；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法效率分析：</strong></p>
<ul>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span>；</li>
<li>时间复杂度：<span class="math inline">\(O(n) +O(n\log_2n) =
O(n\log_2n)\)</span>；</li>
</ul>
<p><strong>建立大根堆的时间复杂度分析：</strong></p>
<p>一个结点，每下坠一层，最多只需要对比关键字2次，第一次是左右孩子的对比，第二次是左右孩子中较大者与根的对比；</p>
<p>若树高为 <span class="math inline">\(h\)</span>，某结点在第 <span
class="math inline">\(i\)</span> 层，则这个结点最多可能下坠 <span
class="math inline">\(h-i\)</span> 层，因此关键字对比次数最多为 <span
class="math inline">\(2(h-i)\)</span>；</p>
<p><span class="math inline">\(n\)</span> 个结点的完全二叉树高度为 <span
class="math inline">\(h=\lfloor\log_2n\rfloor+1\)</span>，第 $ i$
层最多有 <span class="math inline">\(2^{i-1}\)</span> 个结点，只有第
<span class="math inline">\(1\)</span> 到第 <span
class="math inline">\(h-1\)</span> 层的结点才可能下坠；</p>
<p>因此，所有结点的对比次数之和不会超过： <span class="math display">\[
2^0\cdot
2(h-1)+2^1\cdot2(h-2)+\dots+2^{h-1}\cdot2(h-(h-1))\\=\sum_{i=1}^{h-1}[2^{i-1}\cdot2(h-i)]
\\= \sum_{i=1}^{h-1}2^i(h-i)
\]</span> 令 <span class="math inline">\(j=h-i\)</span> 换元，并代入
<span
class="math inline">\(h=\lfloor\log_2n\rfloor+1\)</span>，化简并使用错位相减法可求得：
<span class="math display">\[
\sum_{i=1}^{h-1}2^i(h-i) =\sum_{j=1}^{h-1}2^{h-j}j =
\sum_{j=1}^{h-1}2^{\lfloor\log_2n\rfloor}\cdot 2 \cdot 2^{-j}\cdot j \\
\le 2n\sum_{j=1}^{h-1} 2^{-j}\cdot j \le 4n
\]</span> 由此可知建立大根堆的时间复杂度为 <span
class="math inline">\(O(n)\)</span>；</p>
<p><strong>排序过程的时间复杂度：</strong></p>
<p><span class="math inline">\(n\)</span> 个结点，总共需要 <span
class="math inline">\(n-1\)</span> 趟排序，每趟排序都需要</p>
<ul>
<li>交换首尾元素 <span class="math inline">\(O(1)\)</span>；</li>
<li>调整大根堆：<span class="math inline">\(O(\log_2n)\)</span>
<ul>
<li>消耗主要关键字对比次数上，每下坠一层最多对比两次；</li>
<li>任意结点的下坠次数都不会超过根节点，因此每个结点的比较次数不会超过
<span class="math inline">\(2(h-1)\)</span>；</li>
<li>代入高度表达式可得该部分的复杂度为 <span
class="math inline">\(O(\log_2n)\)</span>；</li>
</ul></li>
</ul>
<p>因此排序部分的复杂度为 $ O(n_2n)$</p>
<h6 id="堆的插入与删除操作">堆的插入与删除操作</h6>
<p>插入：大根堆就让新元素不断下沉，小根堆让新元素不断上升；</p>
<ul>
<li>下沉：与左右孩子中的较大者互换，最多对比两次；</li>
<li>上升：比双亲结点小就与双亲结点互换，只对比一次；</li>
</ul>
<p>删除：用堆底的元素顶替被删除元素的位置，并以该位置为根节点调整大小根堆；</p>
<h4 id="二路归并排序">二路归并排序</h4>
<p>归并（Merge），又称合并，意在把两个或多个已经有序的序列合并成一个；</p>
<p><span class="math inline">\(m\)</span>
路归并：每选出一个小元素需要对比 <span
class="math inline">\(m-1\)</span> 次关键字；</p>
<p>内部排序中的归并一般是2路归并；</p>
<p>算法思想：将初始序列的每一项都看成一个有序的子序列，每一轮都归并相邻的两个元素（不重叠），之后基于前一轮的归并结果继续归并，直到只有一个序列为止；</p>
<p>程序思想：递归+分治</p>
<ul>
<li>用<code>low</code>和<code>high</code>指向原始序列的头和尾，并用<code>mid</code>分割成两个序列，第一个序列为<code>[low, mid]</code>，第二个为<code>[mid+1, high]</code>；</li>
<li>对左半部分 <code>[low, mid]</code> 递归地进行归并排序；</li>
<li>对右半部分 <code>[mid+1, high]</code> 递归地进行归并排序；</li>
<li>将左右两个子序列 <code>Merge</code> 为一个；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* b = (<span class="type">int</span>*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="type">int</span>) * n); <span class="comment">// 辅助数组</span></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">       <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(data, low, mid);</span><br><span class="line">        mergeSort(data, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(data, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二路归并</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="comment">// 副本，避免排序过程被重新放入data的元素影响</span></span><br><span class="line">    <span class="keyword">for</span>(k = low; k &lt;= high; ++k)</span><br><span class="line">        b[k] = data[k];</span><br><span class="line">    <span class="comment">// 归并，循环每次挑出两个子序列中首元素较小的，按顺序写回原序列</span></span><br><span class="line">    <span class="keyword">for</span>(i = low, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; ++k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] &lt;= b[j])</span><br><span class="line">            data[k] = b[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data[k] = b[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for环结束后若有任何一个子序列非空，则将该序列剩下的所有元素按顺序写回去</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        data[k++] = b[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">        data[k++] = b[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>算法效率分析：</strong></p>
<ul>
<li>空间复杂度：<span
class="math inline">\(O(n)\)</span>，来源于辅助数组<code>b</code>的大小（取决于原序列的元素个数）；</li>
<li>时间复杂度：$O(n)+O(_2n) = O(_2n) $；</li>
</ul>
<p>2路归并的归并树在形态上就是一棵倒立的二叉树，原始序列分布在树的最底层（视觉上是最顶层）；</p>
<p>二叉树第 <span class="math inline">\(i\)</span> 层最多有 <span
class="math inline">\(2^{i-1}\)</span> 个结点，若树高为 <span
class="math inline">\(h\)</span>，则第 <span
class="math inline">\(h\)</span> 层的结点数（即序列元素个数）满足：<span
class="math inline">\(n = 2^{h-1}\)</span>；</p>
<p>由上一点可知，<span class="math inline">\(h-1 =
\log_2n\)</span>，而归并的趟数 = 归并树的高度 - 1，因此归并趟数为 <span
class="math inline">\(\lceil\log_2n\rceil\)</span>；</p>
<p>每一趟归并的总对比次数都不会超过 <span
class="math inline">\(n-1\)</span>，即每一趟归并的时间复杂度为 <span
class="math inline">\(O(n)\)</span>；</p>
<h4 id="基数排序">基数排序</h4>
<p>基数排序（Radix Sort）不是基于比较的排序算法；</p>
<p>适用情况：通常用于链表的排序；</p>
<p>擅长解决的问题：</p>
<ul>
<li>数据元素的关键字可以方便地拆分为 <span
class="math inline">\(d\)</span> 组，且 <span
class="math inline">\(d\)</span> 较小；</li>
<li>每组关键字的取值范围不大，即 <span class="math inline">\(r\)</span>
较小；</li>
<li>数据元素个数较多，即 <span class="math inline">\(n\)</span>
较大；</li>
</ul>
<p>算法思想：</p>
<ul>
<li>将每个关键字拆分为 <span class="math inline">\(d\)</span>
组（位），建立 <span class="math inline">\(r\)</span> 个队列；</li>
<li>按照各个关键字位权重递增的次序，做 <span
class="math inline">\(d\)</span> 趟分配和收集；
<ul>
<li>分配：顺序扫描各个元素，按当前选择的“位”做队列分配 $O(d) $；</li>
<li>收集：将各个队列的结点依次出队并链接 <span
class="math inline">\(O(r)\)</span> ；
<ul>
<li>收集时不需要每个队列都做循环出队，只需要将外部链表的<code>next</code>指针指向当前队列的<code>front</code>即可完成整个队列的收集；</li>
</ul></li>
</ul></li>
</ul>
<p>稳定性：稳定；</p>
<p>算法效率分析：</p>
<ul>
<li>空间复杂度：<span class="math inline">\(O(r)\)</span>，<span
class="math inline">\(r\)</span>是基数，代表了元素每一位可能的取值的个数；</li>
<li>时间复杂度：<span class="math inline">\(O(d\cdot(n+r))\)</span>
<ul>
<li>一趟分配 <span class="math inline">\(n\)</span> 个元素 <span
class="math inline">\(O(n)\)</span>，一趟收集 <span
class="math inline">\(r\)</span> 组数据 <span
class="math inline">\(O(r)\)</span>；</li>
<li>总共需要 <span class="math inline">\(d\)</span> 趟，<span
class="math inline">\(d\)</span> 表示序列中元素的最大位数（例如
<code>&#123;129,7,46&#125;</code> 中 <span
class="math inline">\(d=3\)</span>）；</li>
</ul></li>
</ul>
<h3 id="外部排序">外部排序</h3>
<h4 id="基本原理和方式">基本原理和方式</h4>
<p><strong>内外存数据交换原理：</strong></p>
<ul>
<li>操作系统以“块“为单位对磁盘存储空间进行管理；</li>
<li>修改外存的数据需要经历 ①将外存数据读入内存输入缓冲区
②在内存中修改数据 ③通过内存的输出缓冲区写回外存；</li>
</ul>
<p><strong>需要外部排序的原因：</strong>外存数据无法一次全部读入内存；</p>
<p><strong>外部排序策略：</strong>归并排序，最少只需在内存中分配3块与磁盘块等大的缓冲区，即可实现任意一个外部大文件的排序；</p>
<ul>
<li>根据缓冲区个数读入多块数据，内部排序，再按块写回外存，即生成初始归并段；</li>
<li>对所有归并段进行递归多趟归并；</li>
</ul>
<p><strong>重要结论：</strong>采用多路归并可以减少归并趟数，从而减少磁盘I/O（读写）次数；</p>
<ul>
<li><p>对 <span class="math inline">\(r\)</span> 个初始归并段，做 <span
class="math inline">\(k\)</span> 路归并，则归并树可以用 <span
class="math inline">\(k\)</span> 叉树表示，若树高为 <span
class="math inline">\(h\)</span>，则<strong>归并趟数</strong>为 <span
class="math inline">\(h-1=\lceil\log_kr\rceil\)</span>；</p></li>
<li><p>由上一点可知，<span class="math inline">\(k\)</span> 越大，<span
class="math inline">\(r\)</span> 越小，归并趟数越少；</p>
<ul>
<li><strong>优化方案一：</strong>增加归并路数 <span
class="math inline">\(k\)</span>，进行<strong>多路平衡归并</strong>，注意
<span class="math inline">\(k\)</span> 路平衡归并的条件有：
<ul>
<li>最多只能有 <span class="math inline">\(k\)</span>
个段合并为一个；</li>
<li>每一趟归并中，若有 <span class="math inline">\(m\)</span>
个归并段参与归并，则经过这一趟处理会得到 <span
class="math inline">\(\lceil m/k\rceil\)</span> 个新的归并段；</li>
</ul></li>
<li><strong>优化方案二：</strong>增加初始归并段长度，减少初始归并段数量
<span class="math inline">\(r\)</span>；
<ul>
<li>若外存待排序数据有 <span class="math inline">\(N\)</span>
个记录（多个记录组成一个块），内存支持存储的记录个数为 <span
class="math inline">\(L\)</span>，则初始归并段数量为 <span
class="math inline">\(r=\dfrac{N}{L}\)</span>；</li>
</ul></li>
</ul></li>
</ul>
<p><strong>多路归并的负面影响：</strong>对于 <span
class="math inline">\(k\)</span> 路归并，</p>
<ul>
<li>需要开辟 <span class="math inline">\(k\)</span>
个输入缓冲区，内存开销增大；</li>
<li>每挑出一个关键字都需要对比 <span class="math inline">\(k-1\)</span>
次；</li>
</ul>
<h4 id="败者树">败者树</h4>
<p><strong>用途：</strong>优化多路归并带来的关键字对比次数增大，导致降低效率的缺陷；</p>
<p>败者树可视为一棵完全二叉树（多了一个头）</p>
<ul>
<li><span class="math inline">\(k\)</span> 个叶子结点分别对应 <span
class="math inline">\(k\)</span>
个归并段中当前参加比较的元素（归并段靠前的元素）</li>
<li>分支结点用来记录左右子树中“失败者”来自的孩子编号（归并段编号）</li>
<li>分支结点记录的是失败者编号，但胜利者要继续往上比较，一直到根节点为止，选出最终的优胜者；</li>
</ul>
<p>利用败者树，在多路平衡归并算法中，每挑出一个关键字只需要对比 <span
class="math inline">\(\lceil \log_2k \rceil\)</span> 次关键字；</p>
<ul>
<li>高度为 <span class="math inline">\(h\)</span> 的完全二叉树在第 <span
class="math inline">\(h\)</span> 层最多有 <span
class="math inline">\(2^{h-1}\)</span> 个结点，因此 <span
class="math inline">\(k\)</span> 路元素个数 <span
class="math inline">\(k = 2^{h-1}\)</span>，解得 <span
class="math inline">\(h-1 = \log_2k\)</span>；</li>
<li>又因为 <span class="math inline">\(h-1\)</span>
表示了关键字对比的最大次数，因此每选出一个最小/最大元素，最多只需要对比
<span class="math inline">\(\log_2k\)</span> 次；</li>
</ul>
<p>注意：败者树优化的部分在于从“每次都对比<span
class="math inline">\(k-1\)</span>次”到“只有构建败者树的时候需要对比<span
class="math inline">\(k-1\)</span>次”，此后每次选最大/最小值最多都只要
<span class="math inline">\(\log_2k\)</span> 次对比；</p>
<h4 id="置换-选择排序">置换-选择排序</h4>
<p>用途：优化增大初始归并段长度，减少初始归并段数量的方式；</p>
<p>原来的方式是 <span
class="math inline">\(r=\dfrac{N}{L}\)</span>，受限于用于内部排序的内存工作区容量
<span class="math inline">\(L\)</span>；</p>
<p>置换-选择排序可构建出长度不规则的多个归并段，并且这些归并段大小不受内存工作区容量限制；</p>
<p>算法思想：设初始待排序文件为 <span
class="math inline">\(FI\)</span>，初始归并段输出文件（输出缓冲区）为
<span class="math inline">\(FO\)</span>，内存工作区为 <span
class="math inline">\(WA\)</span>；假设 <span
class="math inline">\(WA\)</span> 最多可容纳 <span
class="math inline">\(w\)</span> 个记录</p>
<ul>
<li>（1）从 <span class="math inline">\(FI\)</span> 读入 <span
class="math inline">\(w\)</span> 个记录到 <span
class="math inline">\(WA\)</span> 中；</li>
<li>（2）从 <span class="math inline">\(WA\)</span>
中选出其中关键字最小的记录，记为 <code>MINIMAX</code> 记录；</li>
<li>（3）将 <code>MINIMAX</code> 记录输出到 <span
class="math inline">\(FO\)</span>，当缓冲区 <span
class="math inline">\(FO\)</span> 满载时会自动输出到外存中；</li>
<li>（4）若 <span class="math inline">\(FI\)</span> 非空，则从 <span
class="math inline">\(FI\)</span> 读入下一个记录到 <span
class="math inline">\(WA\)</span> 中；</li>
<li>（5）从 <span class="math inline">\(WA\)</span> 中选出关键字比
<code>MINIMAX</code> 的关键字更大的最小关键字，以其记录作为新的
<code>MINIMAX</code> 记录；</li>
<li>重复（3）～（5），直到 <span class="math inline">\(WA\)</span>
中选不出新的 <code>MINIMAX</code>
为止，由此得到一个初始归并段，此时输出一个归并段的结束标志到 <span
class="math inline">\(FO\)</span> 中；</li>
<li>重复（2）～（6），直到 <span class="math inline">\(WA\)</span>
为空，由此得到所有初始归并段；</li>
</ul>
<h4 id="最佳归并树">最佳归并树</h4>
<p>理论基础</p>
<ul>
<li><p>每个归并片段对应一个叶子结点，且归并段包含的数据块的数量作为叶结点的权值；</p></li>
<li><p>归并树的带权路径长度 WPL =
所有叶结点的带权路径长度之和；</p></li>
<li><p>归并过程中的磁盘 I/O 次数 = 归并树的WPL *
2（WPL=读次数=写次数）；</p></li>
</ul>
<p>注意：<span class="math inline">\(k\)</span>
叉归并的最佳归并树一定是严格的 <span class="math inline">\(k\)</span>
叉树，即树中只有度为 <span class="math inline">\(k\)</span> 和度为 <span
class="math inline">\(0\)</span> 的结点；</p>
<p>构造最佳归并树：</p>
<ul>
<li>最佳归并树就是WPL最小的归并树，即用 <span
class="math inline">\(k\)</span> 个归并段作为叶子结点构建 <span
class="math inline">\(k\)</span> 叉哈夫曼树；
<ul>
<li>每次选择 <span class="math inline">\(k\)</span>
个权值最小的结点合并（视虚段为权值等于0的叶结点），并将它们的权值之和作为合并结点的权值；</li>
</ul></li>
<li>是否需要补充虚段：
<ul>
<li>若（初始归并段数量 - 1） % (k-1) = 0，说明刚好可以构成严格 <span
class="math inline">\(k\)</span> 叉树，不需要添加虚段；</li>
<li>若（初始归并段数量 - 1） % (k-1) = u <span
class="math inline">\(\ne\space 0\)</span>，则需要补充 <span
class="math inline">\((k-1)-u\)</span> 个虚段；</li>
</ul></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/archives/40525/" rel="prev" title="C++使用OpenCV实现简易贪吃蛇">
      <i class="fa fa-chevron-left"></i> C++使用OpenCV实现简易贪吃蛇
    </a></div>
      <div class="post-nav-item">
    <a href="/archives/23212/" rel="next" title="Win10下使用VMware搭建Hadoop集群">
      Win10下使用VMware搭建Hadoop集群 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%8B%E9%81%93dsa%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">王道DSA笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter1-%E7%BB%AA%E8%AE%BA"><span class="nav-number">1.1.</span> <span class="nav-text">Chapter1 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text">Chapter2 线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">顺序表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%B4%E6%8F%92%E6%B3%95"><span class="nav-number">1.2.3.1.1.</span> <span class="nav-text">头插法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="nav-number">1.2.3.1.2.</span> <span class="nav-text">尾插法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E4%BD%8D%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.3.2.1.</span> <span class="nav-text">按位查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.3.2.2.</span> <span class="nav-text">按值查找</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">插入和删除</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E5%BA%8F%E6%8F%92%E5%85%A5"><span class="nav-number">1.2.3.3.1.</span> <span class="nav-text">指定位序插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5"><span class="nav-number">1.2.3.3.2.</span> <span class="nav-text">指定结点插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E5%BA%8F%E5%88%A0%E9%99%A4"><span class="nav-number">1.2.3.3.3.</span> <span class="nav-text">指定位序删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E5%88%A0%E9%99%A4"><span class="nav-number">1.2.3.3.4.</span> <span class="nav-text">指定结点删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.4.</span> <span class="nav-text">双链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-1"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">删除</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E5%BA%8F%E5%88%A0%E9%99%A4-1"><span class="nav-number">1.2.4.3.1.</span> <span class="nav-text">指定位序删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E5%88%A0%E9%99%A4-1"><span class="nav-number">1.2.4.3.2.</span> <span class="nav-text">指定结点删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.5.</span> <span class="nav-text">循环链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.6.</span> <span class="nav-text">静态链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.2.7.</span> <span class="nav-text">顺序表与链表的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">Chapter3 栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.1.</span> <span class="nav-text">栈的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="nav-number">1.3.2.</span> <span class="nav-text">顺序栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="nav-number">1.3.3.</span> <span class="nav-text">顺序共享栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%A0%88"><span class="nav-number">1.3.4.</span> <span class="nav-text">链栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">带头结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">不带头结点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.5.</span> <span class="nav-text">队列的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="nav-number">1.3.6.</span> <span class="nav-text">顺序队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E5%88%97"><span class="nav-number">1.3.7.</span> <span class="nav-text">链队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9-1"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">带头结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9-1"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">不带头结点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.3.8.</span> <span class="nav-text">双端队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.3.9.</span> <span class="nav-text">栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">括号匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">1.3.9.2.</span> <span class="nav-text">表达式求值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.9.2.1.</span> <span class="nav-text">中缀表达式转后缀表达式的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.9.2.2.</span> <span class="nav-text">计算后缀表达式的实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">1.3.9.3.</span> <span class="nav-text">递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.3.10.</span> <span class="nav-text">队列的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-number">1.3.11.</span> <span class="nav-text">矩阵的压缩存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.11.1.</span> <span class="nav-text">一维数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.11.2.</span> <span class="nav-text">二维数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%9F%A9%E9%98%B5"><span class="nav-number">1.3.11.3.</span> <span class="nav-text">普通矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">1.3.11.4.</span> <span class="nav-text">对称矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="nav-number">1.3.11.5.</span> <span class="nav-text">三角矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="nav-number">1.3.11.6.</span> <span class="nav-text">三对角矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="nav-number">1.3.11.7.</span> <span class="nav-text">稀疏矩阵</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter4-%E4%B8%B2"><span class="nav-number">1.4.</span> <span class="nav-text">Chapter4 串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.4.1.</span> <span class="nav-text">串的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E4%B8%8E%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">串与线性表的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.2.</span> <span class="nav-text">串的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.3.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.4.</span> <span class="nav-text">串的朴素模式匹配算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kmp%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.5.</span> <span class="nav-text">KMP算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter5-%E6%A0%91"><span class="nav-number">1.5.</span> <span class="nav-text">Chapter5 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.5.1.</span> <span class="nav-text">树的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.5.2.</span> <span class="nav-text">二叉树的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.3.</span> <span class="nav-text">二叉树的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.5.4.</span> <span class="nav-text">二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">先序&#x2F;中序&#x2F;后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">层次遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.5.5.</span> <span class="nav-text">从遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.5.6.</span> <span class="nav-text">线索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.7.</span> <span class="nav-text">树的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.5.8.</span> <span class="nav-text">森林和二叉树的相互转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.5.9.</span> <span class="nav-text">树和森林的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">1.5.10.</span> <span class="nav-text">二叉排序树（二叉查找树）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.5.11.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">1.5.12.</span> <span class="nav-text">哈夫曼树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter6-%E5%9B%BE"><span class="nav-number">1.6.</span> <span class="nav-text">Chapter6 图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.6.1.</span> <span class="nav-text">图的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.6.2.</span> <span class="nav-text">图的存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">邻接矩阵法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">邻接表法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E5%92%8C%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">十字链表和邻接多重表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.3.</span> <span class="nav-text">图的基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.6.4.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-bfs"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">广度优先搜索 BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-dfs"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">深度优先搜索 DFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">1.6.5.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.6.</span> <span class="nav-text">最短路径问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.6.1.</span> <span class="nav-text">单源最短路径问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#bfs-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.6.1.1.</span> <span class="nav-text">BFS 广度优先搜索算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dijkstra-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.6.1.2.</span> <span class="nav-text">Dijkstra 迪杰斯特拉算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%8F%E5%AF%B9%E9%A1%B6%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.6.2.</span> <span class="nav-text">每对顶点的最短路径问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#floyd-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.6.2.1.</span> <span class="nav-text">Floyd 弗洛伊德算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.6.7.</span> <span class="nav-text">有向无环图的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%9C%89%E5%90%91%E4%BA%94%E7%8E%AF%E5%9B%BE%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.6.7.1.</span> <span class="nav-text">用有向五环图描述表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">1.6.7.2.</span> <span class="nav-text">拓扑排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">1.6.8.</span> <span class="nav-text">关键路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter7-%E6%9F%A5%E6%89%BE"><span class="nav-number">1.7.</span> <span class="nav-text">Chapter7 查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.7.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.2.</span> <span class="nav-text">几种查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">顺序查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">1.7.3.</span> <span class="nav-text">折半查找（二分查找）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="nav-number">1.7.4.</span> <span class="nav-text">分块查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b%E6%A0%91"><span class="nav-number">1.7.5.</span> <span class="nav-text">B树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="nav-number">1.7.5.2.</span> <span class="nav-text">B树的插入与删除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b%E6%A0%91-1"><span class="nav-number">1.7.6.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE"><span class="nav-number">1.7.7.</span> <span class="nav-text">散列查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-number">1.7.7.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.7.2.</span> <span class="nav-text">常见散列函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%B2%E7%AA%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.7.3.</span> <span class="nav-text">冲突的处理方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87"><span class="nav-number">1.7.7.4.</span> <span class="nav-text">查找效率</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter8-%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.</span> <span class="nav-text">Chapter8 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="nav-number">1.8.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.</span> <span class="nav-text">内部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.1.1.</span> <span class="nav-text">简单插入排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.1.2.</span> <span class="nav-text">希尔排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.2.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.2.2.</span> <span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.3.1.</span> <span class="nav-text">简单选择排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.3.2.</span> <span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.2.3.2.1.</span> <span class="nav-text">堆的插入与删除操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">二路归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.5.</span> <span class="nav-text">基数排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.3.</span> <span class="nav-text">外部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">基本原理和方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%A5%E8%80%85%E6%A0%91"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">败者树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">置换-选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="nav-number">1.8.3.4.</span> <span class="nav-text">最佳归并树</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lightshaker</p>
  <div class="site-description" itemprop="description">It is our choices that show what we truly are, far more than our abilities.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lightshaker</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'j3EqSOqSYjPS414YtmiadN5W-gzGzoHsz',
      appKey     : '429Gb8wTQv1P09Fjbeyd9k5w',
      placeholder: "Hello",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
